//
// Module mopshub_lib.EMCI_Emulator.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 17:54:08 08/17/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module EMCI_Emulator #(
   // synopsys template
   parameter GENERATE_FEI4B = 0,
   parameter Kchar_eop      = 8'b11011100,  // K28.6
   parameter Kchar_sop      = 8'b00111100   // K28.1
)
( 
   // Port Declarations
   input   wire           bitCLK, 
   input   wire           data_10b_en, 
   input   wire    [9:0]  data_10b_in, 
   input   wire           reset, 
   output  wire    [9:0]  enc10bit_out_dbg, 
   input   wire    [1:0]  tx_elink2bit, 
   input   wire           bitCLKx2, 
   input   wire           DATA1bitIN, 
   input   wire           swap_tx_bits, 
   input   wire           bitCLKx4, 
   input   wire           reverse_stream_10b, 
   output  wire           fifo_full, 
   output  wire    [7:0]  HGFEDCBA, 
   output  wire    [1:0]  ISK, 
   input   wire           rst, 
   input   wire           reverse_10b_dbg
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         fifo_empty;
wire  [9:0]  fifo_dout;
wire  [9:0]  enc10bit_out;
reg   [9:0]  datain_enc10bit;
reg   [9:0]  enc10bit_r;
wire         send_out_trig;
reg   [2:0]  send_count;
wire         datain_valid      = 1'b1;
wire         elink_data_rdy;
wire  [9:0]  dec8b_Out_dbg;
wire         dec8b_rdy_dbg;
wire         BUSY;
wire         code_err;
wire         disp_err;
wire  [75:0] data_tra_out;
reg   [75:0] data_tra_out_reg  = 76'b0;
wire         cs_elink;
wire         buffer_elink_en;
wire         end_read_elink;              // request to bridge FSM 
wire         start_read_elink;
wire  [4:0]  addr;                        // request to caninterface block
reg          fifo_data_sop     = 1'b0;
reg          fifo_data_eop     = 1'b0;
wire         irq_elink_tra;


// Instances 
dec_8b10b_wrap dec_8b10b_wrap_emci( 
   .ABCDEIFGHJ_IN (datain_enc10bit), 
   .RBYTECLK      (bitCLK), 
   .datain_valid  (datain_valid), 
   .reset         (reset), 
   .BUSY          (BUSY), 
   .HGFEDCBA      (HGFEDCBA), 
   .ISK           (ISK), 
   .code_err      (code_err), 
   .disp_err      (disp_err)
); 

demux8_Nbit U_1( 
   .sel          (send_count), 
   .EDATA_2bit   (tx_elink2bit), 
   .enc10bit_out (enc10bit_out)
); 

elink_interface_SM elink_interface_SM0( 
   .abort             (), 
   .clk               (bitCLK), 
   .din_elink_flag    (), 
   .elink_dbg         (), 
   .fifo_data_eop     (fifo_data_eop), 
   .fifo_data_sop     (fifo_data_sop), 
   .fifo_elink_rdy    (elink_data_rdy), 
   .rst               (rst), 
   .start_write_elink (), 
   .timeoutrst        (), 
   .addr              (addr), 
   .buffer_elink_en   (buffer_elink_en), 
   .buffer_rec_en     (), 
   .cs_elink          (cs_elink), 
   .end_read_elink    (end_read_elink), 
   .end_write_elink   (), 
   .irq_elink_rec     (), 
   .irq_elink_tra     (irq_elink_tra), 
   .start_read_elink  (start_read_elink), 
   .statedeb          ()
); 

elink_to_fifo #(0,GENERATE_FEI4B) elink_to_fifo_emci( 
   .DATA1bitIN         (DATA1bitIN), 
   .bitCLKx2           (bitCLKx2), 
   .swap_tx_bits       (swap_tx_bits), 
   .bitCLK             (bitCLK), 
   .fifo_empty         (fifo_empty), 
   .fifo_flush         (reset), 
   .fifo_full          (fifo_full), 
   .fifo_dout          (fifo_dout), 
   .rx_elink2bit       (tx_elink2bit), 
   .bitCLKx4           (bitCLKx4), 
   .reset              (reset), 
   .reverse_stream_10b (reverse_stream_10b), 
   .fifo_rd_en         (cs_elink), 
   .fifo_wr_clk        (bitCLK), 
   .dec8b_Out_dbg      (dec8b_Out_dbg), 
   .dec8b_rdy_dbg      (dec8b_rdy_dbg), 
   .fifo_rd_clk        (bitCLK)
); 

rec_elink_buf rec_elink_buf_emci( 
   .clk          (bitCLK), 
   .data_rec_in  (fifo_dout[7:0]), 
   .buffer_en    (buffer_elink_en), 
   .rst          (rst), 
   .addr         (addr), 
   .data_rec_out (data_tra_out)
); 

triger_counter #(3'b100,3'b011) triger_counter_emci( 
   .rst          (reset), 
   .bitCLK       (bitCLK), 
   .request_trig (send_out_trig)
); 

// HDL Embedded Text Block 2 eb2
always@(posedge bitCLK)
if (reset)
datain_enc10bit <= 0;
else
begin
  if (data_10b_en ==1)
  datain_enc10bit <= data_10b_in;
  else
  datain_enc10bit <= enc10bit_out_dbg;     
end





// HDL Embedded Text Block 3 eb3
// HDL Embedded Text Block 2 eb2
// eb2 2      
assign   enc10bit_out_dbg =  enc10bit_r;
always @(posedge bitCLK)
  begin
   if (reset)
      enc10bit_r <= 10'b0;
   else if (send_out_trig  == 1)
      begin
        if (reverse_10b_dbg == 1)
        enc10bit_r <= enc10bit_out;
       else
        enc10bit_r <= {enc10bit_out[0],enc10bit_out[1],enc10bit_out[2],enc10bit_out[3],enc10bit_out[4],enc10bit_out[5],enc10bit_out[6],enc10bit_out[7],enc10bit_out[8],enc10bit_out[9]};                                  
      end
  end

always @(posedge bitCLK)
  begin
     if (send_out_trig == 1)
        send_count <= 3'b0; 
     else  
      send_count <= send_count + 1'b1;
  end






// HDL Embedded Text Block 5 FIFO_Write2

//Check FIFO output
assign elink_data_rdy = !fifo_empty;
always@(fifo_dout)
  begin
  if(fifo_dout == {2'b10,Kchar_sop})// 0x3c = 0011 1100 SOP (if 8b10b)
      begin
        fifo_data_sop = 1'b1;
        fifo_data_eop = 1'b0;
      end 
    else if(cs_elink && fifo_dout != {2'b10,Kchar_sop}&& fifo_dout != {2'b01,Kchar_eop})// data
      begin
        fifo_data_sop = 1'b0;
        fifo_data_eop = 1'b0;
      end   
    else if(fifo_dout == {2'b01,Kchar_eop})// 0xdc = 1101 1100 (if 8b10b)
      begin
       fifo_data_sop = 1'b0;
       fifo_data_eop = 1'b1;
      end
    else  
      begin
       fifo_data_sop = 1'b0;
       fifo_data_eop = 1'b0;
      end    
  end















































































































// HDL Embedded Text Block 6 Data_rdy_signal
//Save data into a buffer
always@(posedge bitCLK)
begin 
  if (rst)
  begin
    data_tra_out_reg <= 75'b0;
  end
  if (irq_elink_tra)
  begin
    data_tra_out_reg <= data_tra_out; 
  end 
  else
  begin
   data_tra_out_reg <= data_tra_out_reg; 
  end
end  
















































































































endmodule // EMCI_Emulator

