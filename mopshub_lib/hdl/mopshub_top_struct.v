//
// Module mopshub_lib.mopshub_top.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 09:25:21 11/03/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module mopshub_top #(
   // synopsys template
   parameter n_buses              = 5'b00111,
   parameter seialize_data_stream = 1'b1,
   parameter generate_mopshub     = 1
)
( 
   // Port Declarations
   input   wire           clk, 
   input   wire           clk_80, 
   input   wire           end_cnt_dbg, 
   input   wire           osc_auto_trim_mopshub, 
   input   wire           reset, 
   input   wire           reverse_stream_10b_rx, 
   input   wire           reverse_stream_10b_tx, 
   input   wire           rx0, 
   input   wire           rx1, 
   input   wire           rx2, 
   input   wire           rx3, 
   input   wire           rx4, 
   input   wire           rx5, 
   input   wire           rx6, 
   input   wire           rx7, 
   input   wire           rx_elink1bit, 
   input   wire    [1:0]  rx_elink2bit, 
   input   wire           swap_bits,              // 0 defaultwhen '1', the output bits will be swapped
   output  wire           can_rec_dbg, 
   output  wire           can_tra_dbg, 
   output  wire           irq_elink_rec_dbg, 
   output  wire           irq_elink_tra_dbg, 
   output  wire    [3:0]  mopshub_sm_dbg, 
   output  wire           power_bus_en, 
   output  wire           rx_data_rdy, 
   output  wire           rx_fifo_full_rdy, 
   output  wire           tx0, 
   output  wire           tx1, 
   output  wire           tx2, 
   output  wire           tx3, 
   output  wire           tx4, 
   output  wire           tx5, 
   output  wire           tx6, 
   output  wire           tx7, 
   output  wire           tx_data_rdy, 
   output  wire           tx_elink1bit, 
   output  wire    [1:0]  tx_elink2bit, 
   output  wire           tx_fifo_full_rdy
);


// Internal Declarations


// Local declarations

// Internal signal declarations
reg          bitCount1           = 0;
wire         buffer_en;
wire  [4:0]  can_rec_select;
wire  [4:0]  can_tra_select;
wire  [4:0]  can_tra_select_dbg  = 5'b1;
reg   [1:0]  data_2bit_in        = 2'b0;
wire  [1:0]  data_2bit_out;                //  @ 40MHz
wire  [75:0] data_rec_uplink;
wire  [75:0] data_tra_downlink;
reg   [1:0]  din2bit_r           = 2'b0;
wire         done_trim_osc;
reg          dout1bit_r          = 1'b0;
reg   [1:0]  dout2bit_r          = 2'b0;
wire         enc_stream          = 1;
wire         end_init;
wire         end_read_elink;
wire         end_trim_bus;
wire         end_write_elink;
wire         irq_can_rec_dbg;
wire         irq_can_tra_dbg;
wire         irq_elink_rec;
wire         irq_elink_tra;
wire  [4:0]  power_bus_cnt;
wire         power_bus_en_sig;
wire         rst;
wire         rst_mops_dbg;
wire         rx_data_rdy_in;
wire         rx_fifo_full_in;
wire         sign_on_sig;
wire         start_init;
wire         start_read_elink;
wire         start_trim_ack;
wire         start_write_link;
wire  [5:0]  statedeb;
wire         tx_data_rdy_in;
wire         tx_efifo_full_in;


// Instances 
elink_core #(8'b11011100,8'b00111100,generate_mopshub) elink_core0( 
   .rx_fifo_full          (rx_fifo_full_in), 
   .clk                   (clk), 
   .rst                   (rst), 
   .data_rec_uplink       (data_rec_uplink), 
   .start_write_elink     (start_write_link), 
   .tx_efifo_full         (tx_efifo_full_in), 
   .irq_elink_rec         (irq_elink_rec), 
   .irq_elink_tra         (irq_elink_tra), 
   .data_tra_out          (data_tra_downlink), 
   .end_write_elink       (end_write_elink), 
   .start_read_elink      (start_read_elink), 
   .end_read_elink        (end_read_elink), 
   .buffer_tra_en         (buffer_en), 
   .reverse_stream_10b_rx (reverse_stream_10b_rx), 
   .reverse_stream_10b_tx (reverse_stream_10b_tx), 
   .rx_data_rdy           (rx_data_rdy_in), 
   .tx_data_rdy           (tx_data_rdy_in), 
   .enc_stream            (enc_stream), 
   .data_2bit_in          (data_2bit_in), 
   .data_2bit_out         (data_2bit_out)
); 

mopshub_core #(n_buses) mopshub_core0( 
   .buffer_en             (buffer_en), 
   .can_tra_select_dbg    (can_tra_select_dbg), 
   .clk                   (clk), 
   .data_tra_downlink     (data_tra_downlink), 
   .end_cnt_dbg           (end_cnt_dbg), 
   .end_read_elink        (end_read_elink), 
   .end_write_elink       (end_write_elink), 
   .irq_elink_tra         (irq_elink_tra), 
   .osc_auto_trim_mopshub (osc_auto_trim_mopshub), 
   .rst                   (rst), 
   .rx0                   (rx0), 
   .rx1                   (rx1), 
   .rx2                   (rx2), 
   .rx3                   (rx3), 
   .rx4                   (rx4), 
   .rx5                   (rx5), 
   .rx6                   (rx6), 
   .rx7                   (rx7), 
   .can_rec_select        (can_rec_select), 
   .can_tra_select        (can_tra_select), 
   .data_rec_uplink       (data_rec_uplink), 
   .done_trim_osc_all     (done_trim_osc), 
   .end_init              (end_init), 
   .end_trim_bus          (end_trim_bus), 
   .irq_can_rec           (irq_can_rec_dbg), 
   .irq_can_tra           (irq_can_tra_dbg), 
   .mopshub_sm_dbg        (mopshub_sm_dbg), 
   .power_bus_cnt         (power_bus_cnt), 
   .power_bus_en          (power_bus_en_sig), 
   .rst_mops_dbg          (rst_mops_dbg), 
   .sign_on_sig           (sign_on_sig), 
   .start_init            (start_init), 
   .start_read_elink      (start_read_elink), 
   .start_trim_ack        (start_trim_ack), 
   .start_write_elink     (start_write_link), 
   .statedeb              (statedeb), 
   .tx0                   (tx0), 
   .tx1                   (tx1), 
   .tx2                   (tx2), 
   .tx3                   (tx3), 
   .tx4                   (tx4), 
   .tx5                   (tx5), 
   .tx6                   (tx6), 
   .tx7                   (tx7)
); 

top_led_for_synth top_led_for_synth0( 
   .clk                 (clk), 
   .irq_can_rec_dbg     (irq_can_rec_dbg), 
   .irq_can_tra_dbg     (irq_can_tra_dbg), 
   .irq_elink_rec       (irq_elink_rec), 
   .irq_elink_tra       (irq_elink_tra), 
   .reset               (reset), 
   .rx_data_rdy_in      (rx_data_rdy_in), 
   .rx_fifo_full_rdy_in (rx_fifo_full_in), 
   .tx_data_rdy_in      (tx_data_rdy_in), 
   .tx_fifo_full_rdy_in (tx_efifo_full_in), 
   .can_rec_dbg         (can_rec_dbg), 
   .can_tra_dbg         (can_tra_dbg), 
   .irq_elink_rec_dbg   (irq_elink_rec_dbg), 
   .irq_elink_tra_dbg   (irq_elink_tra_dbg), 
   .rx_data_rdy         (rx_data_rdy), 
   .rx_fifo_full_rdy    (rx_fifo_full_rdy), 
   .tx_data_rdy         (tx_data_rdy), 
   .tx_fifo_full_rdy    (tx_fifo_full_rdy)
); 

// HDL Embedded Text Block 1 eb1
// eb1 1   
assign rst = !reset;   
assign power_bus_en = power_bus_en_sig & rst;                                 
// HDL Embedded Text Block 3 eb3
//-------------------------------------------
//-- serialization of the 2-bit data output:
//-------------------------------------------                                       
always @(posedge clk_80)
begin
  bitCount1 <= ! bitCount1;
end



// HDL Embedded Text Block 5 eb5
//2 bits @ clk80, can interface 2-bit of GBT frame                                       
assign tx_elink2bit = data_2bit_out;
assign tx_elink1bit = dout1bit_r; //1 bit output

if (seialize_data_stream == 0) begin//:GBT_frame_case
always @(posedge clk)//serialized output with 160 clk
    if(bitCount1 == 0)
      dout2bit_r <= data_2bit_out[0]; //serialize the first bit
    else
   begin 
    dout2bit_r <= data_2bit_out; //serialize the second bit which is filled in the other block ?bitCount1 = 0
   end
end
else begin//:Elink_frame_case 
   always @(posedge clk_80)//serialized output
   begin
    if(bitCount1 == 0)
      begin
      dout1bit_r <= data_2bit_out[0]; //serialize the first bit
      end
    else
    begin
      dout1bit_r <= data_2bit_out[1]; //serialize the second bit which is filled in the other block ?bitCount1 = 0
      end
   end
end





























// HDL Embedded Text Block 8 eb6
// Serialization
if (seialize_data_stream == 0)begin//:GBT_frame_case
  always@(posedge clk)
  if (!rst)
    begin
     data_2bit_in <= 2'b0;
    end
  else
    begin
      if(swap_bits)
      data_2bit_in <= {rx_elink2bit[0],rx_elink2bit[1]}; 
      else
      data_2bit_in <= rx_elink2bit;
    end 
  end
else begin//:Elink_frame_case
  always@(posedge clk_80 )
    if (!rst)
       din2bit_r <= 2'b0;
    else
      din2bit_r <= {rx_elink1bit,din2bit_r[1]};

///swap the 2bits  
  always@(posedge clk)
    if (!rst)
      data_2bit_in <= 2'b0;
  else
    begin
      if(swap_bits)
        data_2bit_in <= din2bit_r;
      else
        data_2bit_in <= {din2bit_r[0],din2bit_r[1]};
    end      

end                                       
 

































endmodule // mopshub_top

