//
// Module mopshub_lib.mopshub_top.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 17:27:07 10/04/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module mopshub_top #(
   // synopsys template
   parameter n_buses              = 5'b11111,
   parameter seialize_data_stream = 1'b1
)
( 
   // Port Declarations
   input   wire    [4:0]  can_tra_select_dbg, 
   input   wire           clk, 
   input   wire           clk_80, 
   input   wire           end_cnt_dbg, 
   input   wire           osc_auto_trim_mopshub, 
   input   wire           rst, 
   input   wire           rx0, 
   input   wire           rx1, 
   input   wire           rx2, 
   input   wire           rx3, 
   input   wire           rx4, 
   input   wire           rx5, 
   input   wire           rx6, 
   input   wire           rx7, 
   input   wire           rx_elink1bit, 
   input   wire    [1:0]  rx_elink2bit, 
   output  wire    [3:0]  led, 
   output  wire    [4:0]  power_bus_cnt, 
   output  wire           power_bus_en, 
   output  wire    [5:0]  statedeb, 
   output  wire           tx0, 
   output  wire           tx1, 
   output  wire           tx2, 
   output  wire           tx3, 
   output  wire           tx4, 
   output  wire           tx5, 
   output  wire           tx6, 
   output  wire           tx7, 
   output  wire           tx_elink1bit, 
   output  wire    [1:0]  tx_elink2bit
);


// Internal Declarations


// Local declarations

// Internal signal declarations
reg          bitCount1         = 0;
wire         buffer_en;
wire  [4:0]  can_rec_select;
wire  [4:0]  can_tra_select;
reg   [1:0]  data_2bit_in      = 2'b0;
wire  [1:0]  data_2bit_out;              //  @ 40MHz
wire  [75:0] data_rec_uplink;
wire  [75:0] data_tra_uplink;
reg   [1:0]  din2bit_r         = 2'b0;
wire         done_trim_osc;
reg          dout1bit_r        = 1'b0;
reg   [1:0]  dout2bit_r        = 2'b0;
wire         enc_stream        = 1;
wire         end_init;
wire         end_read_elink;
wire         end_trim_bus;
wire         end_write_elink;
wire         irq_can_ack;
wire         irq_elink_rec;
wire         irq_elink_tra;
wire         rst_mops_dbg;
wire         rx_fifo_full;
wire         sign_on_sig;
wire         start_init;
wire         start_read_elink;
wire         start_trim_ack;
wire         start_write_link;
reg          swap_rx_bits      = 0;
reg          swap_tx_bits      = 0;      // 0 defaultwhen '1', the output bits will be swapped
wire         tx_efifo_full;


// Instances 
elink_core elink_core0( 
   .rx_fifo_full      (rx_fifo_full), 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_uplink   (data_rec_uplink), 
   .start_write_elink (start_write_link), 
   .tx_efifo_full     (tx_efifo_full), 
   .irq_elink_rec     (irq_elink_rec), 
   .irq_elink_tra     (irq_elink_tra), 
   .data_tra_out      (data_tra_uplink), 
   .end_write_elink   (end_write_elink), 
   .start_read_elink  (start_read_elink), 
   .end_read_elink    (end_read_elink), 
   .buffer_tra_en     (buffer_en), 
   .swap_rx_bits      (swap_rx_bits), 
   .swap_tx_bits      (swap_tx_bits), 
   .enc_stream        (enc_stream), 
   .data_2bit_in      (data_2bit_in), 
   .data_2bit_out     (data_2bit_out)
); 

mopshub_core #(n_buses) mopshub_core0( 
   .buffer_en             (buffer_en), 
   .can_tra_select_dbg    (can_tra_select_dbg), 
   .clk                   (clk), 
   .data_tra_uplink       (data_tra_uplink), 
   .end_cnt_dbg           (end_cnt_dbg), 
   .end_read_elink        (end_read_elink), 
   .end_write_elink       (end_write_elink), 
   .irq_elink_tra         (irq_elink_tra), 
   .osc_auto_trim_mopshub (osc_auto_trim_mopshub), 
   .rst                   (rst), 
   .rx0                   (rx0), 
   .rx1                   (rx1), 
   .rx2                   (rx2), 
   .rx3                   (rx3), 
   .rx4                   (rx4), 
   .rx5                   (rx5), 
   .rx6                   (rx6), 
   .rx7                   (rx7), 
   .can_rec_select        (can_rec_select), 
   .can_tra_select        (can_tra_select), 
   .data_rec_uplink       (data_rec_uplink), 
   .done_trim_osc_all     (done_trim_osc), 
   .end_init              (end_init), 
   .end_trim_bus          (end_trim_bus), 
   .irq_can_ack           (irq_can_ack), 
   .power_bus_cnt         (power_bus_cnt), 
   .power_bus_en          (power_bus_en), 
   .rst_mops_dbg          (rst_mops_dbg), 
   .sign_on_sig           (sign_on_sig), 
   .start_init            (start_init), 
   .start_read_elink      (start_read_elink), 
   .start_trim_ack        (start_trim_ack), 
   .start_write_elink     (start_write_link), 
   .statedeb              (statedeb), 
   .tx0                   (tx0), 
   .tx1                   (tx1), 
   .tx2                   (tx2), 
   .tx3                   (tx3), 
   .tx4                   (tx4), 
   .tx5                   (tx5), 
   .tx6                   (tx6), 
   .tx7                   (tx7)
); 

top_led_test top_led_test0( 
   .rst (rst), 
   .clk (clk), 
   .led (led)
); 

// HDL Embedded Text Block 3 eb3
//-------------------------------------------
//-- serialization of the 2-bit data output:
//-------------------------------------------                                       
always @(posedge clk_80)
begin
  bitCount1 <= ! bitCount1;
end



// HDL Embedded Text Block 5 eb5
//2 bits @ clk80, can interface 2-bit of GBT frame                                       
assign tx_elink2bit = data_2bit_out;
assign tx_elink1bit = dout1bit_r; //1 bit output

if (seialize_data_stream == 0) begin//:GBT_frame_case
always @(posedge clk)//serialized output with 160 clk
    if(bitCount1 == 0)
      dout2bit_r <= data_2bit_out[0]; //serialize the first bit
    else
   begin 
    dout2bit_r <= data_2bit_out; //serialize the second bit which is filled in the other block ?bitCount1 = 0
   end
end
else begin//:Elink_frame_case 
   always @(posedge clk_80)//serialized output
   begin
    if(bitCount1 == 0)
      begin
      dout1bit_r <= data_2bit_out[0]; //serialize the first bit
      end
    else
    begin
      dout1bit_r <= data_2bit_out[1]; //serialize the second bit which is filled in the other block ?bitCount1 = 0
      end
   end
end





























// HDL Embedded Text Block 8 eb6
// Serialization
if (seialize_data_stream == 0)begin//:GBT_frame_case
  always@(posedge clk)
  if (!rst)
    begin
     data_2bit_in <= 2'b0;
    end
  else
    begin
      if(swap_tx_bits)
      data_2bit_in <= {rx_elink2bit[0],rx_elink2bit[1]}; 
      else
      data_2bit_in <= rx_elink2bit;
    end 
  end
else begin//:Elink_frame_case
  always@(posedge clk_80 )
    if (!rst)
       din2bit_r <= 2'b0;
    else
      din2bit_r <= {rx_elink1bit,din2bit_r[1]};

///swap the 2bits  
  always@(posedge clk)
    if (!rst)
      data_2bit_in <= 2'b0;
  else
    begin
      if(swap_tx_bits)
        data_2bit_in <= din2bit_r;
      else
        data_2bit_in <= {din2bit_r[0],din2bit_r[1]};
    end      

end                                       
 
































endmodule // mopshub_top

