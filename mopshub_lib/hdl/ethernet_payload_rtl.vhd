-- VHDL Entity mopshub_lib.ethernet_payload.symbol
--
-- Created:
--          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
--          at - 13:05:35 02/01/23
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
--
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use work.ipbus.all;
use work.ipbus_reg_types.all;
use work.ipbus_decode_ipbus_mopshub.all;

ENTITY ethernet_payload IS
   PORT( 
      ipb_clk               : IN     std_logic;
      ipb_rst               : IN     std_logic;
      ipb_in                : IN     ipb_wbus;
      ipb_out               : OUT    ipb_rbus;
      start_write_elink_dbg : OUT    std_logic;
      data_tra_downlink     : IN     std_logic_vector (75 DOWNTO 0);
      data_rec_uplink       : IN     std_logic_vector (75 DOWNTO 0);
      data_rec_ethernet     : OUT    std_logic_vector (75 DOWNTO 0);
      status                : IN     std_logic_vector (31 DOWNTO 0) := X"abcdfedc";
      nuke                  : OUT    std_logic;
      soft_rst              : OUT    std_logic;
      userled               : OUT    std_logic
   );

-- Declarations

END ethernet_payload ;

--
-- VHDL Architecture mopshub_lib.ethernet_payload.rtl
--
-- Created:
--          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
--          at - 13:18:03 02/09/23
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
--


LIBRARY mopshub_lib;

ARCHITECTURE rtl OF ethernet_payload IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL ipbw : ipb_wbus_array(N_SLAVES - 1 DOWNTO 0);
   SIGNAL ipbr : ipb_rbus_array(N_SLAVES - 1 DOWNTO 0);
   SIGNAL ctrl : ipb_reg_v(0 DOWNTO 0);
   SIGNAL stat : ipb_reg_v(0 DOWNTO 0);


   -- Component Declarations
   COMPONENT ethernet_SM
   GENERIC (
      N_REG : positive := 3
   );
   PORT (
      clk                   : IN     std_logic ;
      rst                   : IN     std_logic ;
      ipb_slave_in          : IN     ipb_wbus  := IPB_WBUS_NULL;
      ipb_slave_out         : OUT    ipb_rbus ;
      start_write_elink_dbg : OUT    std_logic ;
      data_tra_downlink     : IN     std_logic_vector (75 DOWNTO 0);
      data_rec_uplink       : IN     std_logic_vector (75 DOWNTO 0);
      data_rec_ethernet     : OUT    std_logic_vector (75 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT ipbus_ctrlreg_v
   PORT (
      clk       : IN     bit;
      ipbus_out : IN     ipb_rbus_array;
      reset     : IN     bit;
      d         : OUT    bit;
      ipbus_in  : OUT    ipb_wbus_array;
      q         : OUT    bit
   );
   END COMPONENT;
   COMPONENT ipbus_fabric_sel
   PORT (
      ipb_from_slaves : IN     bit;
      ipb_in          : IN     bit;
      ipb_to_slaves   : IN     bit;
      ipb_out         : OUT    bit;
      sel             : OUT    bit
   );
   END COMPONENT;
   COMPONENT ipbus_reg_v
   PORT (
      clk       : IN     bit;
      ipbus_in  : IN     ipb_wbus_array;
      ipbus_out : IN     ipb_rbus_array;
      reset     : IN     bit;
      q         : OUT    bit
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : ethernet_SM USE ENTITY mopshub_lib.ethernet_SM;
   FOR ALL : ipbus_ctrlreg_v USE ENTITY mopshub_lib.ipbus_ctrlreg_v;
   FOR ALL : ipbus_fabric_sel USE ENTITY mopshub_lib.ipbus_fabric_sel;
   FOR ALL : ipbus_reg_v USE ENTITY mopshub_lib.ipbus_reg_v;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   stat(0) <= status;
   soft_rst <= ctrl(0)(0);
   nuke <= ctrl(0)(1);
   userled <= ctrl(0)(2);


   -- Instance port mappings.
   slave2 : ethernet_SM
      PORT MAP (
         clk                   => ipb_clk,
         rst                   => ipb_rst,
         ipb_slave_in          => ipbw(N_SLV_REG2),
         ipb_slave_out         => ipbr(N_SLV_REG2),
         start_write_elink_dbg => start_write_elink_dbg,
         data_tra_downlink     => data_tra_downlink,
         data_rec_uplink       => data_rec_uplink,
         data_rec_ethernet     => data_rec_ethernet
      );
   -- Slave 0: id / rst reg
   
   slave0 : ipbus_ctrlreg_v
      PORT MAP (
         clk       => ipb_clk,
         ipbus_out => ipbr(N_SLV_CSR),
         reset     => ipb_rst,
         d         => stat,
         ipbus_in  => ipbw(N_SLV_CSR),
         q         => ctrl
      );
   -- ipbus address decode
   
   fabric : ipbus_fabric_sel
      PORT MAP (
         ipb_from_slaves => ipbr,
         ipb_in => ipb_in,
         ipb_to_slaves => ipbw,
         ipb_out => ipb_out,
         sel => ipbus_sel_ipbus_mopshub(ipb_in.ipb_addr)
      );
   slave1 : ipbus_reg_v
      PORT MAP (
         clk       => ipb_clk,
         ipbus_in  => ipbw(N_SLV_REG),
         ipbus_out => ipbr(N_SLV_REG),
         reset     => ipb_rst,
         q         => OPEN
      );

END rtl;
