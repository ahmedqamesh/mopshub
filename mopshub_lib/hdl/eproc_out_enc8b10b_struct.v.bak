//
// Module mopshub_lib.EPROC_OUT_ENC8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:57:38 03/18/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
// 8b10b encoder for EPROC_OUT module
module EPROC_OUT_ENC8b10b #(
   // synopsys template
   // synopsys template
   parameter zeros2bit_const = 2'b0
)
( 
   // Port Declarations
   input   wire           bitCLKx4,          //bitCLKx4 for 8b/10b encoding [clk_160 MB/s]
   input   wire           bitCLK,            //bitCLK to send the 2bits EdataOUT [clk_40 MB/s]
   output  wire           getDataTrig,       //output Trig signal will enable reading from fifo (rd_en=1)
   input   wire    [9:0]  edataIN,           //Data stored in the FIFO
   input   wire           edataINrdy, 
   input   wire           fhCR_REVERSE_10B, 
   output  wire    [1:0]  EdataOUT,          // Genrated 2bits output data
   input   wire           rst                // reset all the counters and data
);

// Internal Declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
wire        inp_request_trig;
wire        inp_request_trig_out;
reg   [2:0] request_cycle_cnt     = 0;
reg   [2:0] send_count            = 0;
reg         send_out_trig         = 0;
wire  [9:0] enc10bit;
reg   [9:0] enc10bit_r;
wire  [1:0] zeros2bit             = 0;


// Instances 
//  Instances
//  -------------------------------------------------------------------------------------------
//  -- 8b10b encoding
//  -------------------------------------------------------------------------------------------
// 
// 
enc8b10b_wrap enc8b10bx( 
   .clk           (bitCLKx4), 
   .rst           (rst), 
   .dataCode      (edataIN[9:8]), 
   .dataIN        (edataIN[7:0]), 
   .dataINrdy     (edataINrdy), 
   .encDataOutrdy (), 
   .encDataOut    (enc10bit)
); 

mux8_Nbit #(2) bitMUX( 
   .data0(enc10bit_r[1:0]),
   .data1(enc10bit_r[3:2]),
   .data2(enc10bit_r[5:4]),
   .data3(enc10bit_r[7:6]),
   .data4(enc10bit_r[9:8]),
   .data5(zeros2bit),
   .data6(zeros2bit),
   .data7(zeros2bit),
   .sel(send_count),
   .data_out(EdataOUT)
); 

//  output Trig signal will enable reading from fifo (rd_en=1)
// 
//  generates a one clk-pulse pd clkss after trigger rising edge
// 
// 
pulse_pdxx_pwxx #(0,1) pulse_pd( 
   .clk      (bitCLKx4), 
   .trigger  (inp_request_trig), 
   .pulseout (inp_request_trig_out)
); 

// HDL Embedded Text Block 1 eb1
// output Trig signal will enable reading from fifo (rd_en=1)
//------------------------------------------------------------------------------------------------------
//-- input handshaking, request cycle 5 CLKs
// Asynchronous Systems(no global clock) operate at varying rates and communicate locally via handshaking
//-------------------------------------------------------------------------------------------------------
// Counter over the Clock signal
always @(posedge bitCLK)
  begin
     if (rst)
        request_cycle_cnt <= 3'b0;
     else 
      begin 
        if (inp_request_trig ==1)//-- 1 clk trigger       
        request_cycle_cnt <= 3'b0;
      else
        request_cycle_cnt <= request_cycle_cnt + 1;
    end
  end

// HDL Embedded Text Block 2 Trig_sig
//  request cycle 5 CLKs
assign inp_request_trig = (request_cycle_cnt == 3'b100) ? 1:0;  //cycle 5 CLKs
assign getDataTrig = inp_request_trig_out; //getDataTrig will enable reading signal from FIFO (rd_en)


// HDL Embedded Text Block 3 eb3
// HDL Embedded Text Block 3 eb3
always @(posedge bitCLK)
  begin
    send_out_trig <= inp_request_trig; //send_out_trig will be used later when sending out 2bits @bitCLK
  end
// HDL Embedded Text Block 4 data_reg
//Fill the register enc10bit_r with data 
always @(posedge bitCLK)
  begin
     if (rst)
        enc10bit_r <= 10'b0;
     else if (send_out_trig == 1)
        begin
         if (fhCR_REVERSE_10B == 0)//LSB send first 
          enc10bit_r <= {enc10bit[0],enc10bit[1],enc10bit[2],enc10bit[3],enc10bit[4],enc10bit[5],enc10bit[6],enc10bit[7],enc10bit[8],enc10bit[9]};
        else //MSB send first 
          enc10bit_r <= enc10bit;
      end
  end

// HDL Embedded Text Block 5 Counter
// HDL Embedded Text Block 5 eb5
//-------------------------------------------------------------------------------------------
//-- sending out 2 bits @ bitCLK using a MUX
//-------------------------------------------------------------------------------------------
// Counter over the select signal
always @(posedge bitCLK)
  begin
     if (rst)
        send_count <= 3'b0;
     else  
      send_count <= send_count + 1;
  end


endmodule // EPROC_OUT_ENC8b10b
// EPROC_OUT_ENC8b10b
