//
// Module mopshub_lib.osc_trim_sm.fsm
//
// Created:
//          by - Ahmed Qamesh (University of Wuppertal)
//          at - 10:01:13 11/14/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module osc_trim_sm( 
   // Port Declarations
   input   wire           abort, 
   input   wire           clk,                    // posedge
   input   wire           end_read_can,           // signal from CANopen block to indicate that it has read receive message buffer 
   input   wire           end_write_can, 
   input   wire           end_write_elink,        // Goes high when CANopen block finished reading the received message buffer register 
   input   wire           irq_can_rec,            // interrupt signal from canakari to indicate successful read of a new message by one of the 32 buses 
   input   wire           irq_can_tra,            // successful transmission interrupt signal from cankari 
   input   wire           irq_power_on_trim, 
   input   wire    [4:0]  n_buses, 
   input   wire           osc_auto_trim_mopshub, 
   input   wire           power_bus_en_done, 
   input   wire           reset_irq_can_done, 
   input   wire           rst,                    // lowactive
   input   wire           set_power_init, 
   input   wire           timeoutrst,             // timeout reset in case bridge controller does not respond in a specied amount of time 
   output  reg     [4:0]  can_bus_reg, 
   output  reg            end_can_proc, 
   output  reg            end_power_init, 
   output  reg            end_trim_bus, 
   output  reg            entimeout_trim, 
   output  reg            irq_can_ack,            // tto start transmitting CAN message 
   output  reg            osc_trim_mode, 
   output  reg            reset_irq_can,          // reset canakri interrupt 
   output  reg            reset_irq_osc_can, 
   output  reg            reset_irq_rec_can, 
   output  reg            rst_bus, 
   output  reg            send_mes_can, 
   output  reg            skip_osc_trim, 
   output  reg            start_power_init,       // Active High signal
   output  reg            start_power_on, 
   output  reg            start_read_can,         // to read canakari receive registers
   output  reg            start_trim_ack, 
   output  reg            start_trim_osc, 
   output  reg            start_write_elink, 
   output  reg     [7:0]  statedeb, 
   output  reg     [4:0]  trim_msg_reg
);


// Internal Declarations


// Declare any pre-registered internal signals
reg [4:0] can_bus_reg_cld;
reg [4:0] trim_msg_reg_cld;

// Module Declarations

// State encoding
parameter 
          ST_IDLE                     = 6'd0,
          ST_reset                    = 6'd1,
          ST_Start_Cnt                = 6'd2,
          ST_Break_Loop               = 6'd3,
          ST_End_Trim_bus             = 6'd4,
          ST_Check_Trim_Option        = 6'd5,
          ST_Done_Trim_bus            = 6'd6,
          ST_En_power1                = 6'd7,
          ST_Decide_Trim              = 6'd8,
          ST_MOPS_dbg                 = 6'd9,
          ST_Bus_enable               = 6'd10,
          ST_Bus_enable0              = 6'd11,
          Read_Resp                   = 6'd12,
          pass_to_elink               = 6'd13,
          Wait_Resp                   = 6'd14,
          rst_rec_irq_can             = 6'd15,
          finish_proc1                = 6'd16,
          rst_tra_irq_can             = 6'd17,
          Trim_ack                    = 6'd18,
          Start_write_trim            = 6'd19,
          pass_mes_to_can             = 6'd20,
          send_ack1                   = 6'd21,
          Wait_foR_sm                 = 6'd22,
          ST_Check_Trim_Single_Option = 6'd23,
          ST_End_Trim_Single_Bus      = 6'd24,
          ST_Done_Trim_Single_Bus     = 6'd25,
          ST_En_power_single          = 6'd26,
          Read_Resp1                  = 6'd27,
          pass_to_elink1              = 6'd28,
          Wait_Resp1                  = 6'd29,
          rst_rec_irq_can1            = 6'd30,
          finish_proc2                = 6'd31,
          rst_tra_irq_can1            = 6'd32,
          Trim_ack1                   = 6'd33,
          Start_write_trim1           = 6'd34,
          pass_mes_to_can1            = 6'd35,
          send_ack2                   = 6'd36,
          ST_Skip_bus                 = 6'd37,
          ST_rst_irq_can              = 6'd38,
          Wait_for_msg1               = 6'd39,
          rst_tra_irq_can2            = 6'd40,
          Start_write_trim2           = 6'd41,
          pass_mes_to_can2            = 6'd42;

reg [5:0] current_state, next_state;

// Wait State Signals
reg [8:0] csm_timer;
reg [8:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_MOPS_dbg;
reg       csm_to_Wait_foR_sm;
reg       csm_to_Wait_for_msg1;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   can_bus_reg_cld, 
   csm_timeout, 
   current_state, 
   end_read_can, 
   end_write_can, 
   end_write_elink, 
   irq_can_rec, 
   irq_can_tra, 
   irq_power_on_trim, 
   n_buses, 
   osc_auto_trim_mopshub, 
   power_bus_en_done, 
   reset_irq_can_done, 
   rst, 
   set_power_init, 
   trim_msg_reg_cld
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_MOPS_dbg = 1'b0;
   csm_to_Wait_foR_sm = 1'b0;
   csm_to_Wait_for_msg1 = 1'b0;
   case (current_state) 
      ST_IDLE: begin
         if (set_power_init ==1)
            next_state = ST_Check_Trim_Option;
         else if (irq_power_on_trim  ==1)
            next_state = ST_En_power_single;
         else
            next_state = ST_IDLE;
      end
      ST_reset: begin
         if (rst == 1)
            next_state = ST_IDLE;
         else
            next_state = ST_reset;
      end
      ST_Start_Cnt: begin
         if (set_power_init ==1)
            next_state = ST_Bus_enable;
         else
            next_state = ST_Decide_Trim;
      end
      ST_Break_Loop: begin
         if (can_bus_reg_cld ==n_buses)
            next_state = ST_Done_Trim_bus;
         else
            next_state = ST_Start_Cnt;
      end
      ST_End_Trim_bus: begin
         next_state = ST_Break_Loop;
      end
      ST_Check_Trim_Option: begin
         if (osc_auto_trim_mopshub ==1)
            next_state = ST_En_power1;
         else
            next_state = ST_Bus_enable0;
      end
      ST_Done_Trim_bus: begin
         next_state = ST_IDLE;
      end
      ST_En_power1: begin
         if (power_bus_en_done ==1) begin
            next_state = ST_MOPS_dbg;
            csm_to_ST_MOPS_dbg = 1'b1;
         end
         else
            next_state = ST_En_power1;
      end
      ST_Decide_Trim: begin
         if (osc_auto_trim_mopshub ==1) begin
            next_state = ST_MOPS_dbg;
            csm_to_ST_MOPS_dbg = 1'b1;
         end
         else
            next_state = ST_Break_Loop;
      end
      ST_MOPS_dbg: begin
         if (csm_timeout)
            next_state = Trim_ack;
         else
            next_state = ST_MOPS_dbg;
      end
      ST_Bus_enable: begin
         if (power_bus_en_done ==1)
            next_state = ST_Decide_Trim;
         else
            next_state = ST_Bus_enable;
      end
      ST_Bus_enable0: begin
         if (power_bus_en_done ==1)
            next_state = ST_Break_Loop;
         else
            next_state = ST_Bus_enable0;
      end
      Read_Resp: begin
         if (end_read_can == 1)
            next_state = pass_to_elink;
         else
            next_state = Read_Resp;
      end
      pass_to_elink: begin
         if (end_write_elink == 1) begin
            next_state = Wait_foR_sm;
            csm_to_Wait_foR_sm = 1'b1;
         end
         else
            next_state = pass_to_elink;
      end
      Wait_Resp: begin
         if (irq_can_rec == 1)
            next_state = Read_Resp;
         else
            next_state = Wait_Resp;
      end
      rst_rec_irq_can: begin
         if (reset_irq_can_done==1)
            next_state = finish_proc1;
         else
            next_state = rst_rec_irq_can;
      end
      finish_proc1: begin
         next_state = ST_End_Trim_bus;
      end
      rst_tra_irq_can: begin
         if (reset_irq_can_done ==1)
            next_state = Wait_Resp;
         else
            next_state = rst_tra_irq_can;
      end
      Trim_ack: begin
         next_state = Start_write_trim2;
      end
      Start_write_trim: begin
         if (end_write_can == 1)
            next_state = pass_mes_to_can;
         else
            next_state = Start_write_trim;
      end
      pass_mes_to_can: begin
         if (trim_msg_reg_cld ==n_buses)
            next_state = Start_write_trim2;
         else
            next_state = rst_tra_irq_can2;
      end
      send_ack1: begin
         next_state = rst_tra_irq_can;
      end
      Wait_foR_sm: begin
         if (csm_timeout)
            next_state = rst_rec_irq_can;
         else
            next_state = Wait_foR_sm;
      end
      ST_Check_Trim_Single_Option: begin
         if (osc_auto_trim_mopshub ==1)
            next_state = Trim_ack1;
         else
            next_state = ST_Done_Trim_Single_Bus;
      end
      ST_End_Trim_Single_Bus: begin
         next_state = ST_Done_Trim_Single_Bus;
      end
      ST_Done_Trim_Single_Bus: begin
         next_state = ST_IDLE;
      end
      ST_En_power_single: begin
         if (power_bus_en_done ==1)
            next_state = ST_Check_Trim_Single_Option;
         else
            next_state = ST_En_power_single;
      end
      Read_Resp1: begin
         if (end_read_can == 1)
            next_state = pass_to_elink1;
         else
            next_state = Read_Resp1;
      end
      pass_to_elink1: begin
         if (end_write_elink == 1)
            next_state = rst_rec_irq_can1;
         else
            next_state = pass_to_elink1;
      end
      Wait_Resp1: begin
         if (irq_can_rec == 1)
            next_state = Read_Resp1;
         else
            next_state = Wait_Resp1;
      end
      rst_rec_irq_can1: begin
         if (reset_irq_can_done ==1)
            next_state = finish_proc2;
         else
            next_state = rst_rec_irq_can1;
      end
      finish_proc2: begin
         next_state = ST_End_Trim_Single_Bus;
      end
      rst_tra_irq_can1: begin
         if (reset_irq_can_done ==1)
            next_state = Wait_Resp1;
         else
            next_state = rst_tra_irq_can1;
      end
      Trim_ack1: begin
         next_state = Start_write_trim1;
      end
      Start_write_trim1: begin
         if (end_write_can == 1)
            next_state = pass_mes_to_can1;
         else
            next_state = Start_write_trim1;
      end
      pass_mes_to_can1: begin
         if (irq_can_tra ==1)
            next_state = send_ack2;
         else
            next_state = pass_mes_to_can1;
      end
      send_ack2: begin
         next_state = rst_tra_irq_can1;
      end
      ST_Skip_bus: begin
         next_state = ST_rst_irq_can;
      end
      ST_rst_irq_can: begin
         if (reset_irq_can_done ==1)
            next_state = ST_Break_Loop;
         else
            next_state = ST_rst_irq_can;
      end
      Wait_for_msg1: begin
         if (csm_timeout)
            next_state = Start_write_trim;
         else
            next_state = Wait_for_msg1;
      end
      rst_tra_irq_can2: begin
         if (reset_irq_can_done ==1) begin
            next_state = Wait_for_msg1;
            csm_to_Wait_for_msg1 = 1'b1;
         end
         else
            next_state = rst_tra_irq_can2;
      end
      Start_write_trim2: begin
         if (end_write_can == 1)
            next_state = pass_mes_to_can2;
         else
            next_state = Start_write_trim2;
      end
      pass_mes_to_can2: begin
         if (irq_can_tra ==1)
            next_state = send_ack1;
         else
            next_state = pass_mes_to_can2;
      end
      default: 
         next_state = ST_reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   end_can_proc = 0;
   end_power_init = 0;
   end_trim_bus = 0;
   entimeout_trim = 1;
   irq_can_ack = 0;
   osc_trim_mode = 1;
   reset_irq_can = 0;
   reset_irq_osc_can = 0;
   reset_irq_rec_can = 0;
   rst_bus = 0;
   send_mes_can = 0;
   skip_osc_trim = 0;
   start_power_init = 0;
   start_power_on = 0;
   start_read_can = 0;
   start_trim_ack = 0;
   start_trim_osc = 0;
   start_write_elink = 0;

   // Combined Actions
   case (current_state) 
      ST_IDLE: begin
         entimeout_trim = 0;
         osc_trim_mode = 0;
      end
      ST_reset: begin
         entimeout_trim = 0 ;
         osc_trim_mode =0;
         start_power_init  =0;
      end
      ST_End_Trim_bus: begin
         end_trim_bus =1;
      end
      ST_Done_Trim_bus: begin
         end_power_init =1;
      end
      ST_En_power1: begin
         start_power_init  =1;
      end
      ST_MOPS_dbg: begin
         rst_bus =1;
      end
      ST_Bus_enable: begin
         start_power_init  =1;
      end
      ST_Bus_enable0: begin
         start_power_init  =1;
      end
      Read_Resp: begin
         start_read_can = 1 ;
      end
      pass_to_elink: begin
         start_write_elink = 1;
      end
      rst_rec_irq_can: begin
         reset_irq_can = 1 ;
         reset_irq_rec_can = 1 ;
      end
      finish_proc1: begin
         end_can_proc = 1;
      end
      rst_tra_irq_can: begin
         irq_can_ack = 1 ;
         reset_irq_can = 1 ;
         reset_irq_osc_can = 1 ;
      end
      Trim_ack: begin
         start_trim_ack =1;
      end
      Start_write_trim: begin
         start_trim_osc =1;
      end
      pass_mes_to_can: begin
         send_mes_can =1;
      end
      send_ack1: begin
         irq_can_ack = 1 ;
      end
      ST_End_Trim_Single_Bus: begin
         end_trim_bus =1;
      end
      ST_Done_Trim_Single_Bus: begin
         end_power_init =1;
      end
      ST_En_power_single: begin
         start_power_on =1;
      end
      Read_Resp1: begin
         start_read_can = 1 ;
      end
      pass_to_elink1: begin
         start_write_elink = 1;
      end
      rst_rec_irq_can1: begin
         reset_irq_can = 1 ;
         reset_irq_rec_can = 1 ;
      end
      finish_proc2: begin
         end_can_proc = 1;
      end
      rst_tra_irq_can1: begin
         reset_irq_can = 1 ;
         reset_irq_osc_can = 1 ;
      end
      Trim_ack1: begin
         start_trim_ack =1;
      end
      Start_write_trim1: begin
         start_trim_osc =1;
      end
      pass_mes_to_can1: begin
         send_mes_can =1;
      end
      send_ack2: begin
         irq_can_ack = 1 ;
      end
      ST_Skip_bus: begin
         skip_osc_trim = 1;
      end
      ST_rst_irq_can: begin
         reset_irq_osc_can  = 1 ;
      end
      rst_tra_irq_can2: begin
         irq_can_ack = 1 ;
         reset_irq_osc_can  = 1 ;
      end
      Start_write_trim2: begin
         start_trim_osc =1;
      end
      pass_mes_to_can2: begin
         send_mes_can =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_reset;
      csm_timer <= 9'd0;
   end
   else 
   begin
      if (abort) begin
         current_state <= ST_Skip_bus;
         csm_timer <= 9'd0;
      end
      else if (timeoutrst) begin
         current_state <= ST_Skip_bus;
         csm_timer <= 9'd0;
      end
      else 
      begin
         current_state <= next_state;
         csm_timer <= csm_next_timer;

         // Combined Actions
         case (current_state) 
            ST_reset: begin
               can_bus_reg_cld =1'b0;
               trim_msg_reg_cld  =1'b0;
            end
            ST_Start_Cnt: begin
               can_bus_reg_cld<=can_bus_reg_cld +1;
            end
            ST_Done_Trim_bus: begin
               can_bus_reg_cld<=1'b0;
            end
            pass_mes_to_can: begin
               trim_msg_reg_cld<=trim_msg_reg_cld +1;
            end
            Start_write_trim2: begin
               trim_msg_reg_cld =5'b0;
            end
         endcase
      end
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_MOPS_dbg,
   csm_to_Wait_foR_sm,
   csm_to_Wait_for_msg1
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 9'd0);
   if (csm_to_ST_MOPS_dbg == 1'b1) begin
      csm_next_timer = 9'd3;  //no cycles(4)-1=3
   end
   else if (csm_to_Wait_foR_sm == 1'b1) begin
      csm_next_timer = 9'd399;  //no cycles(400)-1=399
   end
   else if (csm_to_Wait_for_msg1 == 1'b1) begin
      csm_next_timer = 9'd399;  //no cycles(400)-1=399
   end
   else begin
      csm_next_timer = (csm_timeout)? 9'd0: (csm_timer - 9'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
begin
   statedeb = 8'b0;
   statedeb[5:0] = current_state;
end

// Concurrent Statements
// Clocked output assignments
always @(
   can_bus_reg_cld, 
   trim_msg_reg_cld
)
begin : clocked_output_proc
   can_bus_reg = can_bus_reg_cld;
   trim_msg_reg = trim_msg_reg_cld;
end
endmodule // osc_trim_sm
