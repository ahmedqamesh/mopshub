//
// Module mopshub_lib.osc_trim_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:14:13 01/28/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module osc_trim_SM( 
   // Port Declarations
   input   wire           clk,                    // posedge
   input   wire           end_cnt_dbg, 
   input   wire           end_osc_cnt, 
   input   wire           end_read_can,           // signal from CANopen block to indicate that it has read receive message buffer 
   input   wire           end_write_can, 
   input   wire           end_write_elink,        // Goes high when CANopen block finished reading the received message buffer register 
   input   wire           endwait,                // This signal indicates when message can't be decoded in one of the CANopen objects to go back to known state to receive message
   input   wire           irq_can_rec,            // interrupt signal from canakari to indicate successful read of a new message by one of the 32 buses 
   input   wire           irq_can_tra,            // successful transmission interrupt signal from cankari 
   input   wire           irq_trim_osc, 
   input   wire           osc_auto_trim_mopshub, 
   input   wire           reset_all_done, 
   input   wire           reset_irq_rec_done, 
   input   wire           reset_irq_tra_done, 
   input   wire           rst,                    // lowactive
   input   wire           timeoutrst,             // timeout reset in case bridge controller does not respond in a specied amount of time 
   output  reg            done_trim_osc_all, 
   output  reg            end_can_proc, 
   output  reg            end_trim_bus, 
   output  reg            entimeout_trim, 
   output  reg            ext_counter_gen, 
   output  reg            irq_can_ack,            // tto start transmitting CAN message 
   output  reg            osc_trim_mode, 
   output  reg            power_bus_en,           // Active High signal
   output  reg            reset_irq_can,          // reset canakri interrupt 
   output  reg            reset_irq_can_all,      // reset all canakri interrupt 
   output  reg            reset_irq_osc_can, 
   output  reg            reset_irq_rec_can, 
   output  reg            rst_bus, 
   output  reg            rst_osc_cnt, 
   output  reg            send_mes_can, 
   output  reg            skip_osc_trim, 
   output  reg            start_osc_cnt, 
   output  reg            start_read_can,         // to read canakari receive registers
   output  reg            start_trim_ack, 
   output  reg            start_trim_osc, 
   output  reg            start_write_elink, 
   output  reg     [5:0]  statedeb
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact        = 5'd0,
          Start            = 5'd1,
          reset            = 5'd2,
          ST_Skip_Bus      = 5'd3,
          rst_all_irq_can  = 5'd4,
          power_bus        = 5'd5,
          ST_Start_Cnt     = 5'd6,
          RST_MOPS_dbg     = 5'd7,
          Break_Loop       = 5'd8,
          finish_proc      = 5'd9,
          ST_CountRst      = 5'd10,
          Rread_Resp       = 5'd11,
          pass_to_elink    = 5'd12,
          Wait_Resp        = 5'd13,
          rst_rec_irq_can1 = 5'd14,
          finish_proc1     = 5'd15,
          rst_irq1         = 5'd16,
          s5               = 5'd17,
          s1               = 5'd18,
          Wait_Suc_tra     = 5'd19,
          s2               = 5'd20,
          send_ack1        = 5'd21,
          go_next          = 5'd22,
          Check_Trim       = 5'd23,
          ST_Done_Trim     = 5'd24;

reg [4:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   end_cnt_dbg, 
   end_osc_cnt, 
   end_read_can, 
   end_write_can, 
   end_write_elink, 
   irq_can_rec, 
   irq_can_tra, 
   irq_trim_osc, 
   osc_auto_trim_mopshub, 
   reset_all_done, 
   reset_irq_rec_done, 
   reset_irq_tra_done, 
   rst
)
begin : next_state_block_proc
   case (current_state) 
      waittoact: begin
         if (irq_trim_osc ==1)
            next_state = Check_Trim;
         else
            next_state = waittoact;
      end
      Start: begin
         next_state = waittoact;
      end
      reset: begin
         if (rst == 1)
            next_state = Start;
         else
            next_state = reset;
      end
      ST_Skip_Bus: begin
         next_state = rst_all_irq_can;
      end
      rst_all_irq_can: begin
         if (reset_all_done ==1)
            next_state = Break_Loop;
         else
            next_state = rst_all_irq_can;
      end
      power_bus: begin
         next_state = s5;
      end
      ST_Start_Cnt: begin
         next_state = power_bus;
      end
      RST_MOPS_dbg: begin
         next_state = ST_Start_Cnt;
      end
      Break_Loop: begin
         if (end_osc_cnt ==1 |  end_cnt_dbg ==1)
            next_state = ST_CountRst;
         else
            next_state = RST_MOPS_dbg;
      end
      finish_proc: begin
         next_state = Break_Loop;
      end
      ST_CountRst: begin
         next_state = ST_Done_Trim;
      end
      Rread_Resp: begin
         if (end_read_can == 1)
            next_state = pass_to_elink;
         else
            next_state = Rread_Resp;
      end
      pass_to_elink: begin
         if (end_write_elink == 1)
            next_state = rst_rec_irq_can1;
         else
            next_state = pass_to_elink;
      end
      Wait_Resp: begin
         if (irq_can_rec == 1)
            next_state = Rread_Resp;
         else
            next_state = Wait_Resp;
      end
      rst_rec_irq_can1: begin
         if (reset_irq_rec_done ==1)
            next_state = finish_proc1;
         else
            next_state = rst_rec_irq_can1;
      end
      finish_proc1: begin
         next_state = finish_proc;
      end
      rst_irq1: begin
         if (reset_irq_tra_done)
            next_state = go_next;
         else
            next_state = rst_irq1;
      end
      s5: begin
         next_state = s1;
      end
      s1: begin
         if (end_write_can == 1)
            next_state = s2;
         else
            next_state = s1;
      end
      Wait_Suc_tra: begin
         if (irq_can_tra ==1)
            next_state = send_ack1;
         else
            next_state = Wait_Suc_tra;
      end
      s2: begin
         next_state = Wait_Suc_tra;
      end
      send_ack1: begin
         next_state = rst_irq1;
      end
      go_next: begin
         next_state = Wait_Resp;
      end
      Check_Trim: begin
         if (osc_auto_trim_mopshub ==1)
            next_state = power_bus;
         else
            next_state = ST_Done_Trim;
      end
      ST_Done_Trim: begin
         next_state = waittoact;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   done_trim_osc_all = 0;
   end_can_proc = 0;
   end_trim_bus = 0;
   entimeout_trim = 1;
   ext_counter_gen = 0;
   irq_can_ack = 0;
   osc_trim_mode = 1;
   power_bus_en = 1;
   reset_irq_can = 0;
   reset_irq_can_all = 0;
   reset_irq_osc_can = 0;
   reset_irq_rec_can = 0;
   rst_bus = 0;
   rst_osc_cnt = 0;
   send_mes_can = 0;
   skip_osc_trim = 0;
   start_osc_cnt = 0;
   start_read_can = 0;
   start_trim_ack = 0;
   start_trim_osc = 0;
   start_write_elink = 0;

   // Combined Actions
   case (current_state) 
      waittoact: begin
         entimeout_trim = 0;
         osc_trim_mode = 0;
      end
      Start: begin
         power_bus_en =0;
      end
      reset: begin
         entimeout_trim = 0 ;
         osc_trim_mode =0;
         power_bus_en =0;
      end
      ST_Skip_Bus: begin
         skip_osc_trim = 1;
      end
      rst_all_irq_can: begin
         reset_irq_can_all = 1 ;
      end
      power_bus: begin
         rst_bus =1;
      end
      ST_Start_Cnt: begin
         start_osc_cnt =1;
      end
      RST_MOPS_dbg: begin
         ext_counter_gen=1;
      end
      finish_proc: begin
         end_trim_bus =1;
      end
      ST_CountRst: begin
         rst_osc_cnt =1;
      end
      Rread_Resp: begin
         start_read_can = 1 ;
      end
      pass_to_elink: begin
         start_write_elink = 1;
      end
      rst_rec_irq_can1: begin
         reset_irq_can = 1 ;
         reset_irq_rec_can = 1 ;
      end
      finish_proc1: begin
         end_can_proc = 1;
      end
      rst_irq1: begin
         reset_irq_can = 1 ;
         reset_irq_osc_can = 1 ;
      end
      s5: begin
         start_trim_ack =1;
      end
      s1: begin
         start_trim_osc =1;
      end
      s2: begin
         send_mes_can =1;
      end
      send_ack1: begin
         irq_can_ack = 1 ;
      end
      Check_Trim: begin
         power_bus_en =0;
      end
      ST_Done_Trim: begin
         done_trim_osc_all =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
   end
   else 
   begin
      if (endwait) begin
         current_state <= reset;
      end
      else if (timeoutrst) begin
         current_state <= ST_Skip_Bus;
      end
      else 
      begin
         current_state <= next_state;
      end
   end
end // Clocked Block

endmodule // osc_trim_SM
