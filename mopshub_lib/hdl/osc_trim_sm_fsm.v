//
// Module mopshub_lib.osc_trim_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 12:31:12 09/16/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module osc_trim_SM( 
   // Port Declarations
   input   wire      clk,                    // posedge
   input   wire      end_init, 
   input   wire      endwait,                // This signal indicates when message can't be decoded in one of the CANopen objects to go back to known state to receive message
   input   wire      osc_auto_trim_mopshub, 
   input   wire      osc_auto_trim_sent, 
   input   wire      rst,                    // lowactive
   input   wire      timeoutrst,             // timeout reset in case bridge controller does not respond in a specied amount of time 
   output  reg       abort_mes,              // Signals other state machines to come to a known statte 
   output  reg       entimeout,              // enable for timeout reset counter 
   output  reg       osc_trim_mode
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact       = 3'd0,
          Start           = 3'd1,
          reset           = 3'd2,
          endwaitst       = 3'd3,
          Wait_initialize = 3'd4,
          Send_Trim       = 3'd5;

reg [2:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   end_init, 
   osc_auto_trim_mopshub, 
   osc_auto_trim_sent, 
   rst
)
begin : next_state_block_proc
   case (current_state) 
      waittoact: begin
         next_state = waittoact;
      end
      Start: begin
         if (end_init ==1)
            next_state = Wait_initialize;
         else
            next_state = Start;
      end
      reset: begin
         if (rst == 1)
            next_state = Start;
         else
            next_state = reset;
      end
      endwaitst: begin
         next_state = waittoact;
      end
      Wait_initialize: begin
         if (osc_auto_trim_mopshub ==1)
            next_state = Send_Trim;
         else
            next_state = waittoact;
      end
      Send_Trim: begin
         if (osc_auto_trim_sent ==1)
            next_state = waittoact;
         else
            next_state = Send_Trim;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   abort_mes = 0;
   entimeout = 1;
   osc_trim_mode = 0;

   // Combined Actions
   case (current_state) 
      waittoact: begin
         entimeout = 0 ;
      end
      reset: begin
         abort_mes = 1 ;
         entimeout = 0 ;
      end
      Send_Trim: begin
         osc_trim_mode =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
   end
   else 
   begin
      if (timeoutrst) begin
         current_state <= endwaitst;
      end
      else if (endwait) begin
         current_state <= reset;
      end
      else 
      begin
         current_state <= next_state;
      end
   end
end // Clocked Block

endmodule // osc_trim_SM
