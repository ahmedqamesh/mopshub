//
// Module mopshub_lib.dec_8b10b_wrap.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 21:24:08 09/30/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module dec_8b10b_wrap #(
   // synopsys template
   parameter generate_mopshub = 0,
   parameter COMMAp           = 10'b0011111010,  //-K.28.5//comma / idle character
   parameter COMMAn           = 10'b1100000101,  //+K.28.5
   parameter EOCp             = 10'b0011110110,  //-K.28.6 //start-of-chunk and end-of-chunk characters
   parameter EOCn             = 10'b1100001001,  //+K.28.6
   parameter SOCp             = 10'b0011111001,  //-K.28.1
   parameter SOCn             = 10'b1100000110,  //+K.28.1
   parameter SOBp             = 10'b0011110101,  //-K.28.2 //start-of-busy and end-of-busy characters
   parameter SOBn             = 10'b1100001010,  //+K.28.2
   parameter EOBp             = 10'b0011110011,  //-K.28.3 
   parameter EOBn             = 10'b1100001100,  //+K.28.3 
   parameter FEI4B_COMMAp     = 10'b1100000110,  //+K.28.1
   parameter FEI4B_COMMAn     = 10'b0011111001,  //-K.28.1
   parameter FEI4B_EOCp       = 10'b1100000101,  //+K.28.5 
   parameter FEI4B_EOCn       = 10'b0011111010,  //-K.28.5 
   parameter FEI4B_SOCp       = 10'b1100000111,  //+K.28.7
   parameter FEI4B_SOCn       = 10'b0011111000   //-K.28.7
)
( 
   // Port Declarations
   input   wire           clk, 
   input   wire           datain_valid, 
   input   wire    [9:0]  enc10b_data_in, 
   input   wire           rst, 
   output  wire    [1:0]  ISK, 
   output  wire           busy, 
   output  wire           code_err, 
   output  wire    [7:0]  dec10b_data_out, 
   output  wire           dec10b_rdy, 
   output  wire           disp_err
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire        ISK_char;
wire        ISK_comma;
wire        ISK_eob;
wire        ISK_eoc;
reg   [1:0] ISK_r             = 0;
wire        ISK_sob;
wire        ISK_soc;
wire  [1:0] ISKcode;
wire  [7:0] Kchar_comma       = 8'b10111100;   //K28.5  BC
wire  [7:0] Kchar_eop         = 8'b11011100;   // K28.6 DC
wire  [7:0] Kchar_sop         = 8'b00111100;   // K28.1 3C
reg         busy_r;
reg   [7:0] dec10b_data_r     = 0;
reg         dec10b_rdy_r      = 0;
wire        dec8b_rdy;
reg         dec8b_rdy_r       = 0;
wire  [7:0] decoder_out;
reg         flag_pack         = 0;
wire        reset;
wire        valid_char_comma;
wire        valid_char_eop;
wire        valid_char_sop;


// Instances 
dec_8b10b dec_8b10b0( 
   .reset        (reset), 
   .clk          (clk), 
   .datain       (enc10b_data_in), 
   .datain_valid (datain_valid), 
   .ko           (ISK_char), 
   .dataout      (decoder_out), 
   .code_err     (code_err), 
   .disp_err     (disp_err)
); 

// HDL Embedded Text Block 2 ISKcode_asign
// ISKcode_asign 2                                        
assign ISKcode[0] = ((! ISK_soc) & (ISK_eoc ^ ISK_comma)) | ISK_sob | ISK_eob;
assign ISKcode[1] = ((! ISK_eoc) & (ISK_soc ^ ISK_comma)) | ISK_sob | ISK_eob;
// GBT_mode_Sig 1                                        
if (generate_mopshub == 0) 
  begin:EMCI_mode
   assign ISK_comma   = (enc10b_data_in == COMMAp |  enc10b_data_in == COMMAn )  ? 1: 0;
   assign ISK_soc     = (enc10b_data_in == SOCp   |  enc10b_data_in == SOCn   )  ? 1: 0;
   assign ISK_eoc     = (enc10b_data_in == EOCp   |  enc10b_data_in == EOCn   )  ? 1: 0;
   
   assign ISK_sob     = (enc10b_data_in == SOBp   |  enc10b_data_in == SOBn   )  ? 1: 0;
   assign ISK_eob     = (enc10b_data_in == EOBp   |  enc10b_data_in == EOBn   )  ? 1: 0;
  end
else
  begin:MOPSHUB_mode 
   assign ISK_comma   = (enc10b_data_in == FEI4B_COMMAp |  enc10b_data_in == FEI4B_COMMAn )  ? 1: 0;
   assign ISK_soc     = (enc10b_data_in == FEI4B_SOCp   |  enc10b_data_in == FEI4B_SOCn   )  ? 1: 0;
   assign ISK_eoc     = (enc10b_data_in == FEI4B_EOCp   |  enc10b_data_in == FEI4B_EOCn   )  ? 1: 0;
   assign ISK_sob     = 0;
   assign ISK_eob     = 0;    
  end

always@(posedge clk)
if (!rst)
   busy_r <= 0;
else
begin
if (!rst | ISK_eob ==1)
   busy_r <= 0; 
else if (ISK_sob ==1)
   busy_r <= 1;
end                                        
                                    










// HDL Embedded Text Block 3 isk_signal
// isk_signal 3 
always@(posedge clk)
if (!rst)
begin
   ISK_r <= 2'b00;
   //dec10b_data_r <= 0;
end
else
begin
if (ISK_char == 1)//edges of the data frame
   ISK_r <= ISKcode; 
else
   ISK_r <= 2'b00;
end                                        





// HDL Embedded Text Block 4 rdy_signal




// isk_signal 3 
always@(posedge clk)
if (!rst)
begin
   dec8b_rdy_r <= 1'b0;
end
else
begin
if (datain_valid)//edges of the data frame
   dec8b_rdy_r <= 1'b1;
else
   dec8b_rdy_r <= 1'b0;
end                                        
























// HDL Embedded Text Block 5 eb2
// eb2 5 
assign   ISK = ISK_r;
assign   dec10b_data_out = dec10b_data_r;
assign   busy = busy_r;  
assign   dec10b_rdy = dec10b_rdy_r;                                 










// HDL Embedded Text Block 6 test_before_Write1
//what to write into the FIFO?
assign dec8b_rdy = dec8b_rdy_r;  
assign valid_char_comma = (ISK_char == 1 & decoder_out == Kchar_comma) ? 1:0;
assign valid_char_sop   = (ISK_char == 1 & decoder_out == Kchar_sop  ) ? 1:0; //3c = 0011 1100 SOP (if 8b10b)
assign valid_char_eop   = (ISK_char == 1 & decoder_out == Kchar_eop  ) ? 1:0; //dc = 1101 1100 (if 8b10b)

always@(posedge clk)
if (!rst)
begin
  dec10b_rdy_r      <= 1'b0;
  flag_pack       <= 1'b0;
  dec10b_data_r   <= 0;
end
else 
begin
  //din_fifo <= dec10b_data_out;
  dec10b_data_r <= decoder_out;
  if(dec10b_rdy_r == 1)//always make sure you write only once
  begin
    dec10b_rdy_r   <= 1'b0;
    flag_pack    <= flag_pack;
  end
  else if(flag_pack == 1 && dec8b_rdy  == 1 && valid_char_comma)// ignore commas
  begin
    dec10b_rdy_r   <= 1'b0;
    flag_pack    <= flag_pack;
  end
  else if(flag_pack == 0 && dec8b_rdy  == 1 && valid_char_sop)// 03c = 0011 1100 SOP (if 8b10b)
  begin
    dec10b_rdy_r   <= 1'b1;
    flag_pack    <= 1'b1; //SOP detected. raise the flag, write everything
  end   
  else if(flag_pack == 1 && dec8b_rdy  == 1 && !valid_char_eop)// not EOP means it is data //flag_pack == 1 && 
  begin
    dec10b_rdy_r   <= 1'b1;
    flag_pack    <= 1'b1;
  end   
  else if(flag_pack == 1 && dec8b_rdy  == 1 && valid_char_eop)// 0dc = 1101 1100 (if 8b10b)
  begin
    dec10b_rdy_r   <= 1'b1;
    flag_pack    <= 1'b0; //EOP detected. drop the flag
  end 
  else
  begin
    dec10b_rdy_r   <= 1'b0;
    flag_pack    <= flag_pack;
  end 
end




































































// HDL Embedded Text Block 9 reset_assign
assign reset = !rst;




























endmodule // dec_8b10b_wrap

