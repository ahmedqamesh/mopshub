//
// Module mopshub_lib.dec_8b10b_wrap.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:35:34 02/24/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module dec_8b10b_wrap( 
   // Port Declarations
   input   wire    [7:0]  Kchar_comma,     //K28.5  BC
   input   wire    [7:0]  Kchar_eop,       // K28.6 DC
   input   wire    [7:0]  Kchar_sop,       // K28.1 3C
   input   wire           clk, 
   input   wire           datain_valid, 
   input   wire    [9:0]  enc10b_data_in, 
   input   wire           rst, 
   output  wire    [1:0]  ISK, 
   output  wire    [7:0]  dec8b_data_out, 
   output  wire           dec8b_rdy
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0] COMMAn            = 10'b1100000101;   //+K.28.5
wire  [9:0] COMMAp            = 10'b0011111010;   //-K.28.5//comma / idle character
wire  [9:0] EOBn              = 10'b1100001100;   //+K.28.3 
wire  [9:0] EOBp              = 10'b0011110011;   //-K.28.3 
wire  [9:0] EOCn              = 10'b1100001001;   //+K.28.6
wire  [9:0] EOCp              = 10'b0011110110;   //-K.28.6 end-of-chunk characters
wire        ISK_char;
wire        ISK_comma;
wire        ISK_eob;
wire        ISK_eoc;
reg   [1:0] ISK_r             = 0;
wire        ISK_sob;
wire        ISK_soc;
wire  [1:0] ISKcode;
reg   [1:0] ISKcode_r         = 2'b0;
wire  [9:0] SOBn              = 10'b1100001010;   //+K.28.2
wire  [9:0] SOBp              = 10'b0011110101;   //-K.28.2 //start-of-busy and end-of-busy characters
wire  [9:0] SOCn              = 10'b1100000110;   //+K.28.1 Ã˜Â¹Ã˜Â¨Ã˜Â¯Ã˜Â§Ã™Â„Ã™Â„Ã™Â‡ ÃsÃ˜Â˜Â§Ã™Â„Ã™Â‡Ã˜Â¯Ã™Â„Ã™Â‚
wire  [9:0] SOCp              = 10'b0011111001;   //-K.28.1
reg         busy_r;
wire        code_err;
wire        dataout_valid;
reg         dataout_valid_r   = 0;
reg   [7:0] dec8b_data_r      = 0;
reg         dec8b_rdy_r       = 0;
wire  [7:0] decoder_out;
wire        disp_err;
reg         flag_pack         = 0;
wire        valid_char_comma;
wire        valid_char_eop;
wire        valid_char_sop;


// Instances 
dec_8b10b dec_8b10b0( 
   .rst          (rst), 
   .clk          (clk), 
   .datain       (enc10b_data_in), 
   .datain_valid (datain_valid), 
   .ko           (ISK_char), 
   .dataout      (decoder_out), 
   .code_err     (code_err), 
   .disp_err     (disp_err)
); 

// HDL Embedded Text Block 2 ISKcode_asign
// ISKcode_asign 2                                        
assign ISK_comma   = (enc10b_data_in == COMMAp |  enc10b_data_in == COMMAn )  ? 1: 0;
assign ISK_soc     = (enc10b_data_in == SOCp   |  enc10b_data_in == SOCn   )  ? 1: 0;
assign ISK_eoc     = (enc10b_data_in == EOCp   |  enc10b_data_in == EOCn   )  ? 1: 0;
assign ISK_sob     = (enc10b_data_in == SOBp   |  enc10b_data_in == SOBn   )  ? 1: 0;
assign ISK_eob     = (enc10b_data_in == EOBp   |  enc10b_data_in == EOBn   )  ? 1: 0;
assign ISKcode[0]  = ((! ISK_soc) & (ISK_eoc ^ ISK_comma)) | ISK_sob | ISK_eob;
assign ISKcode[1]  = ((! ISK_eoc) & (ISK_soc ^ ISK_comma)) | ISK_sob | ISK_eob;


always@(posedge clk)
if (!rst)
begin
  busy_r <= 0;
  ISKcode_r <=2'b0;
end
else
begin
  ISKcode_r <=ISKcode;
  if (ISK_eob ==1)//end of busy detected 
  busy_r <= 0; 
  else if (ISK_sob ==1)//start of busy detected 
  busy_r <= 1;
end                                        






















// HDL Embedded Text Block 3 isk_signal
// isk_signal 3 
always@(posedge clk)
if (!rst)
begin
   ISK_r <= 2'b00;
end
else
begin
if (ISK_char == 1)//edges of the data frame
   ISK_r <= ISKcode_r; 
else
   ISK_r <= 2'b00;
end                                        









// HDL Embedded Text Block 4 rdy_signal
// isk_signal 3 
always@(posedge clk)
if (!rst)
begin
   dataout_valid_r <= 1'b0;
end
else
begin
if (datain_valid)//edges of the data frame
   dataout_valid_r <= 1'b1;
else
   dataout_valid_r <= 1'b0;
end                                        


























// HDL Embedded Text Block 6 test_before_Write1
//what to write into the FIFO?
assign ISK = ISK_r;  
assign dataout_valid = dataout_valid_r;  
assign dec8b_data_out = dec8b_data_r;
assign dec8b_rdy = dec8b_rdy_r;                                
assign valid_char_comma = (ISK_char == 1 & decoder_out == Kchar_comma) ? 1:0;
assign valid_char_sop   = (ISK_char == 1 & decoder_out == Kchar_sop  ) ? 1:0; //3c = 0011 1100 SOP (if 8b10b)
assign valid_char_eop   = (ISK_char == 1 & decoder_out == Kchar_eop  ) ? 1:0; //dc = 1101 1100 (if 8b10b)

always@(posedge clk)
if (!rst)
begin
  dec8b_rdy_r    <= 1'b0;
  flag_pack      <= 1'b0;
  dec8b_data_r   <= 0;
end
else 
begin
  dec8b_data_r <= decoder_out;
  if(dec8b_rdy_r == 1)//always make sure you write only once
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end
  else if(flag_pack == 1 && dataout_valid  == 1 && valid_char_comma)// ignore commas
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end
  else if(flag_pack == 0 && dataout_valid  == 1 && valid_char_sop)// 03c = 0011 1100 SOP (if 8b10b)
  begin
    dec8b_rdy_r   <= 1'b1;
    flag_pack     <= 1'b1; //SOP detected. raise the flag, write everything
  end   
  else if(flag_pack == 1 && dataout_valid  == 1 && !valid_char_eop)// not EOP means it is data //flag_pack == 1 && 
  begin
    dec8b_rdy_r   <= 1'b1;
    flag_pack     <= 1'b1;
  end   
  else if(flag_pack == 1 && dataout_valid  == 1 && valid_char_eop)// 0dc = 1101 1100 (if 8b10b)
  begin
    dec8b_rdy_r    <= 1'b1;
    flag_pack      <= 1'b0; //EOP detected. drop the flag
  end 
  else
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end 
end
















































































endmodule // dec_8b10b_wrap

