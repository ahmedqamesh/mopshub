//
// Module mopshub_lib.dbg_uart_top.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 10:46:44 07/05/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module dbg_uart_top( 
   // Port Declarations
   input   wire            clk, 
   input   wire            m_axi_lite_arready, 
   input   wire            m_axi_lite_awready, 
   input   wire    [1:0]   m_axi_lite_bresp, 
   input   wire            m_axi_lite_bvalid, 
   input   wire    [31:0]  m_axi_lite_rdata, 
   input   wire    [1:0]   m_axi_lite_rresp, 
   input   wire            m_axi_lite_rvalid, 
   input   wire            m_axi_lite_wready, 
   input   wire            reset, 
   input   wire    [7:0]   statedb_can_mux, 
   input   wire    [7:0]   statedeb_can, 
   input   wire    [7:0]   statedeb_elink_rec, 
   input   wire    [7:0]   statedeb_elink_tra, 
   input   wire    [7:0]   statedeb_main, 
   input   wire    [7:0]   statedeb_osc_trim, 
   input   wire    [7:0]   statedeb_spi, 
   output  wire    [3:0]   m_axi_lite_araddr, 
   output  wire            m_axi_lite_arvalid, 
   output  wire    [3:0]   m_axi_lite_awaddr, 
   output  wire            m_axi_lite_awvalid, 
   output  wire            m_axi_lite_bready, 
   output  wire            m_axi_lite_rready, 
   output  wire    [31:0]  m_axi_lite_wdata, 
   output  wire            m_axi_lite_wstrb, 
   output  wire            m_axi_lite_wvalid
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [7:0]  data7             = 8'b0;
wire  [7:0]  data_out;
wire         rst;                        // should be used through VIO
wire  [31:0] rx_uart_data;
reg   [31:0] rx_uart_data_reg;
wire  [7:0]  select_port;
wire  [31:0] tx_uart_data;


// Instances 
dbg_uart_sm dbg_uart_sm0( 
   .axi_uart_test      (), 
   .clk                (clk), 
   .fifo_dbg_out_rdy   (), 
   .out_rx_dv          (), 
   .rst                (rst), 
   .rx_uart_addr_ready (m_axi_lite_arready), 
   .rx_uart_valid      (m_axi_lite_rvalid), 
   .tx_uart_ready      (m_axi_lite_wready), 
   .w_tx_done          (), 
   .fifo_dbg_out_read  (), 
   .in_tx_dv           (), 
   .rx_uart_addr       (m_axi_lite_araddr), 
   .rx_uart_addr_valid (m_axi_lite_arvalid), 
   .rx_uart_ready      (m_axi_lite_rready), 
   .select_dbg_sm      (), 
   .tx_uart_addr       (m_axi_lite_awaddr), 
   .tx_uart_data       (tx_uart_data), 
   .tx_uart_valid      (m_axi_lite_wvalid), 
   .write_dbg_fifo     ()
); 

mux8_1_8bit mux8_1_8bit0( 
   .clk      (clk), 
   .rst      (rst), 
   .data0    (statedeb_main), 
   .data1    (statedeb_can), 
   .data2    (statedb_can_mux), 
   .data3    (statedeb_osc_trim), 
   .data4    (statedeb_elink_tra), 
   .data5    (statedeb_elink_rec), 
   .data6    (statedeb_spi), 
   .data7    (data7), 
   .sel      (select_port), 
   .en_sel   (), 
   .data_out (data_out)
); 

// HDL Embedded Text Block 3 eb3
// eb1 1                                        
assign rst = !reset;                               
//Tx signals
assign m_axi_lite_awvalid = m_axi_lite_wvalid;//valid signal for address
assign m_axi_lite_bready = m_axi_lite_wvalid || m_axi_lite_bvalid;
//assign tx_uart_data = 16'b0;
//assign m_axi_lite_wdata = {tx_uart_data,select_port,data_out};                                      
assign m_axi_lite_wstrb = 4'd15;

//Rx Signals 
//the address
// 1. The master assert the ARVALID signal when it drives valid address
// 2. ARVALID must remain asserted until the rising clock edge after the slave asserts the ARREADY signal.
// Read data channel
// 1.The slave can assert the RVALID signal only when it drives valid read data
// 2. RVALID must remain asserted until the rising clock edge after the master asserts RREADY
// 3. The master interface uses the RREADY signal to indicate that it accepts the data
assign rx_uart_data = rx_uart_data_reg;
assign m_axi_lite_wdata  = rx_uart_data_reg;
assign select_port = rx_uart_data_reg[7:0];
always@(posedge clk)
begin 
  if(!rst) rx_uart_data_reg <= 32'b0;
   else
   begin 
    if (m_axi_lite_rready ==1'b1) rx_uart_data_reg <= m_axi_lite_rdata;
    else rx_uart_data_reg <= rx_uart_data_reg;
   end
end










































endmodule // dbg_uart_top

