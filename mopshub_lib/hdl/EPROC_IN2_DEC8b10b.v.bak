//
// Module mopshub_lib.EPROC_IN2_DEC8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:00:00 04/03/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2018.1 (Build 12)
//

`resetall
`timescale 1ns/10ps
module EPROC_IN2_DEC8b10b( 
   // Port Declarations
   input   wire           bitCLK, 
   input   wire           rst, 
   input   wire           swap_inputbits, 
   input   wire    [1:0]  edataIN, 
   output  wire    [9:0]  DATA_OUT, 
   output  wire           DATA_RDY
);


// Internal Declarations


// Local declarations

// Internal signal declarations
reg   [11:0] EDATAbitstreamSREG    = 0;                //12 bit (2 x 5 = 10, plus 2 more)
reg   [9:0]  FEI4B_COMMAn          = 10'b0011111001;
reg   [9:0]  FEI4B_COMMAp          = 10'b1100000110;
reg          align_select          = 0;
reg   [4:0]  alignment_sreg        = 0;
wire  [1:0]  comma_valid_bits;
wire         comma_valid_bits_or;
reg   [1:0]  edata_in_r;
wire  [1:0]  edata_in_s;
reg   [9:0]  word10b               = 0;
wire  [1:0]  word10b_align_array;
wire         word10b_align_rdy_s;
reg          word10b_rdy           = 0;


// Instances 
// HDL Embedded Text Block 1 eb1
// eb1 1   
assign edata_in_s = edata_in_r;                                     


// HDL Embedded Text Block 2 eb2
// eb1 1   
//sign  EDATAbitstreamSREG_s = EDATAbitstreamSREG;                                   
always@(posedge bitCLK)
if (rst)
  begin
    EDATAbitstreamSREG <=0;
  end
else
  begin
    EDATAbitstreamSREG <= {edata_in_s ,EDATAbitstreamSREG[11:2]};
  end  








// HDL Embedded Text Block 3 alignment_word10b_rdy
// eb1 1                                        
always@(posedge bitCLK)
if (rst)
  begin
    word10b_rdy <=0;
  end
else
  begin
    word10b_rdy <= word10b_align_rdy_s;
  end  








// HDL Embedded Text Block 4 eb4
// --------------------------------------------------------------------
//--clock1
//-- alignment selector state
//---------------------------------------------------------------------                                       
always@(posedge bitCLK)
if (rst)
  begin
    alignment_sreg <=5'b0;
  end
else 
begin
if (comma_valid_bits_or == 1)
  begin
    alignment_sreg <= 5'b10000; 
  end  
else
    alignment_sreg <= {alignment_sreg[0],alignment_sreg[4:1]};
end








// HDL Embedded Text Block 6 eb6
// eb1 1                                        
assign word10b_align_rdy_s = alignment_sreg[4];








// HDL Embedded Text Block 7 eb7
// eb1 1                                        
always@(posedge bitCLK)
if (rst)
  begin
    align_select <=0;
  end
else if( comma_valid_bits_or ==1) 
  begin
    align_select <= (comma_valid_bits[0] & comma_valid_bits[1]);
  end  








// HDL Embedded Text Block 8 alignment_word10b
// Prepare_8b10b_data                                     
always@(posedge bitCLK)
if (rst)
  begin
    word10b <=0;
  end
else
    case (align_select)
      
        1'b0 :begin //bit0 word got comma => align to bit0
          word10b <= word10b_align_array[0];
          end
        1'b1 :begin //bit1 word got comma => align to bit1
          word10b <= word10b_align_array[1];
          end     
    endcase











// HDL Embedded Text Block 9 eb9

//-------------------------------------------------------------------------------------------
//-- at this stage: word10b and word10b_rdy are aligned
//-------------------------------------------------------------------------------------------                                     
assign DATA_OUT    = word10b;
assign DATA_RDY = word10b_rdy;










// HDL Embedded Text Block 10 eb3

assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);




// HDL Embedded Text Block 11 eb8
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//-------------------------------------------------------------------------------------------                                      
//1 10bit-word per alignment, comma is valid if two first words have comma...
assign comma_valid_bits[0] = (word10b_align_array[0] == FEI4B_COMMAp | word10b_align_array[0]== FEI4B_COMMAn) ? 1:0;
assign comma_valid_bits[1] = (word10b_align_array[1] == FEI4B_COMMAp | word10b_align_array[1]== FEI4B_COMMAn) ? 1:0;
// HDL Embedded Text Block 12 eb10
 
assign word10b_align_array[0] =  EDATAbitstreamSREG [9:0];
assign word10b_align_array[1] =  EDATAbitstreamSREG [1+9:1+0];









// HDL Embedded Text Block 13 eb5
  // buffer the output data
  
always @ (swap_inputbits, edataIN)
begin
  if (swap_inputbits)
  edata_in_r = {edataIN[0],edataIN[1]};
  else     
  edata_in_r = edataIN;
end
  


endmodule // EPROC_IN2_DEC8b10b

