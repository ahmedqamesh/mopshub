//
// Module mopshub_lib.fifo_core_wrapper.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 13:59:42 08/11/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module fifo_core_wrapper( 
   // Port Declarations
   input   wire    [7:0]  Kchar_comma, 
   input   wire    [9:0]  din_fifo, 
   input   wire           flush_fifo, 
   input   wire           rclk, 
   input   wire           rd_en,            //  rden doesn't have to be asserted when empty flag is enabled. 
   input   wire           rst, 
   input   wire           wclk, 
   input   wire           wr_en,            // wren doesn't have to be asserted when "full" flag is asserted. The word passed to the write side will be losted. wren can be asserted continuously, or occasionally.
   input   wire           wr_en_comma, 
   output  wire    [9:0]  dout_fifo, 
   output  wire           full_fifo,        //  The flag is asserted on the next clock cycle the last available word has been written if no data has been read.
   output  wire           rdy_fifo, 
   output  wire           read_fifo_empty   // The flag is asserted on the next clock cycle last available word has been read if no further info has been stored.
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire        arempty;
wire        awfull;
wire  [9:0] dout10bit_async_fifo;
reg   [9:0] dout_async_fifo_reg;
reg         dout_rdy_async_fifo_reg;
reg         rd_en_data_tx;
wire        rd_en_s;
reg         rrst_n;
reg         wrst_n;


// Instances 
fifo_async #(10,18) fifo_async0( 
   .wclk      (wclk), 
   .wrst_n    (wrst_n), 
   .winc      (wr_en), 
   .wdata     (din_fifo), 
   .wfull     (full_fifo), 
   .awfull    (awfull), 
   .rclk      (rclk), 
   .rrst_n    (rrst_n), 
   .rinc      (rd_en_s), 
   .dout_fifo (dout10bit_async_fifo), 
   .rempty    (read_fifo_empty), 
   .arempty   (arempty)
); 

// HDL Embedded Text Block 1 eb1
initial dout_rdy_async_fifo_reg  = 1'b0;
initial dout_async_fifo_reg      = {2'b11,8'b10111100};
initial rd_en_data_tx         = 1'b0;
initial rrst_n         = 1'b0;
initial wrst_n         = 1'b0;

assign dout_fifo = dout_async_fifo_reg;
assign rdy_fifo = dout_rdy_async_fifo_reg;
assign rd_en_s     = (rd_en && !read_fifo_empty);               

always @(posedge rclk) begin
    rrst_n <= rst;
end
always @(posedge wclk) begin
    wrst_n <= rst;
end
always @ (posedge rclk)
  if (!rst) rd_en_data_tx       <=1'b0;
  else rd_en_data_tx  <= rd_en_s;  
                          
always @ (posedge rclk)
  if (!rst) 
  begin 
  dout_async_fifo_reg       <={2'b11,Kchar_comma};
  dout_rdy_async_fifo_reg   <= 1'b0;
  end
  else
    begin
      if (rd_en_data_tx == 1)      
      begin
        dout_async_fifo_reg  <= dout10bit_async_fifo ;
        dout_rdy_async_fifo_reg   <= 1'b1;
      end
      else if (wr_en_comma && rd_en )      
      begin
        dout_async_fifo_reg  <= {2'b11,Kchar_comma};
        dout_rdy_async_fifo_reg   <= 1'b1;
      end
      else
      begin                  
        dout_async_fifo_reg  <= dout_async_fifo_reg; 
        dout_rdy_async_fifo_reg   <= 1'b0;
      end
    end                                     



























endmodule // fifo_core_wrapper

