//
// Module mopshub_lib.EPROC_IN2_DEC8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 17:01:32 04/04/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2018.1 (Build 12)
//

`resetall
`timescale 1ns/10ps
module EPROC_IN2_DEC8b10b( 
   // Port Declarations
   input   wire           bitCLK, 
   input   wire    [1:0]  edataIN, 
   input   wire           rst, 
   input   wire           swap_inputbits, 
   output  wire    [9:0]  DATA_OUT, 
   output  wire           DATA_RDY
);


// Internal Declarations


// Local declarations

// Internal signal declarations
reg   [9:0]  COMMAn                     = 10'b1100000101;   //+K.28.5
reg   [9:0]  COMMAp                     = 10'b0011111010;   //-K.28.5//comma / idle character
reg   [11:0] EDATAbitstreamSREG         = 0;                //12 bit (2 x 5 = 10, plus 2 more)
reg   [9:0]  FEI4B_COMMAn               = 10'b0011111001;
reg   [9:0]  FEI4B_COMMAp               = 10'b1100000110;
reg          align_select               = 0;
reg   [4:0]  alignment_sreg             = 0;
wire  [1:0]  comma_valid_bits;
wire         comma_valid_bits_or;
wire         dir                        = 1;                // Declare input to shift in either left or right direction
wire  [11:0] dout_dbg;
reg   [1:0]  edata_in_r;
wire  [1:0]  edata_in_s;
wire         en                         = 1;                // Declare input for enable to switch the shift register on/off
reg   [9:0]  word10b                    = 0;
wire  [9:0]  word10b_align_array [1:0];                     //2 words of 10bit
wire         word10b_align_rdy_s;
reg          word10b_rdy                = 0;


// Instances 
bitstream_shift_register U_0( 
   .din  (edata_in_s), 
   .clk  (bitCLK), 
   .en   (en), 
   .dir  (dir), 
   .rst  (rst), 
   .dout (dout_dbg)
); 

// HDL Embedded Text Block 1 eb1
// eb1 1   
assign edata_in_s = edata_in_r;                                     


// HDL Embedded Text Block 3 alignment_word10b_rdy
// eb1 1                                        
always@(posedge bitCLK)
if (rst)
  begin
    word10b_rdy <=0;
  end
else
  begin
    word10b_rdy <= word10b_align_rdy_s;
  end  








// HDL Embedded Text Block 4 alignment_sreg
// --------------------------------------------------------------------
//--clock1
//-- alignment selector state
//--------------------------------------------------------------------- 
assign word10b_align_rdy_s = alignment_sreg[4];                                      
always@(posedge bitCLK)
if (rst)
  begin
    alignment_sreg <=5'b0;
  end
else 
begin
if (comma_valid_bits_or == 1)
  begin
    alignment_sreg <= 5'b10000; 
  end  
else
    alignment_sreg <= {alignment_sreg[0],alignment_sreg[4:1]};
end









// HDL Embedded Text Block 7 align_select
// eb1 1                                        
always@(posedge bitCLK)
if (rst)
  begin
    align_select <=0;
  end
else if( comma_valid_bits_or ==1) 
  begin
    align_select <= (!comma_valid_bits[0] & comma_valid_bits[1]);
  end  









// HDL Embedded Text Block 8 alignment_word10b
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------

always@(posedge bitCLK)
if (rst)
  begin
    word10b <=0;
  end
else
    case (align_select)
      
        1'b0 :begin //when bit0 word got comma => align to word10b0
          word10b <= word10b_align_array[0];
          end
        1'b1 :begin //when bit1 word got comma => align to word10b1
          word10b <= word10b_align_array[1];
          end     
    endcase













// HDL Embedded Text Block 9 eb9

//-------------------------------------------------------------------------------------------
//-- at this stage: word10b and word10b_rdy are aligned
//-------------------------------------------------------------------------------------------                                     
assign DATA_OUT    = word10b;
assign DATA_RDY = word10b_rdy;










// HDL Embedded Text Block 10 eb3

assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);




// HDL Embedded Text Block 11 eb4
always@(posedge bitCLK)
if (rst)
  begin
    EDATAbitstreamSREG <=0;
  end
else
  begin
    EDATAbitstreamSREG <= dout_dbg;
  end  







// HDL Embedded Text Block 12 eb10
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 

assign  word10b_align_array[0] =  EDATAbitstreamSREG [9:0];
assign  word10b_align_array[1] =  EDATAbitstreamSREG [1+9:1+0];
//assign  word10b_align_array[0] =  { EDATAbitstreamSREG [0],
//                                    EDATAbitstreamSREG [1],
//                                    EDATAbitstreamSREG [2],
//                                    EDATAbitstreamSREG [3],
//                                    EDATAbitstreamSREG [4],
//                                    EDATAbitstreamSREG [5],
//                                    EDATAbitstreamSREG [6],
//                                    EDATAbitstreamSREG [7],
//                                    EDATAbitstreamSREG [8],
//                                    EDATAbitstreamSREG [9]};
//                                  
//assign  word10b_align_array[1] =  { EDATAbitstreamSREG [1+0],
//                                    EDATAbitstreamSREG [1+1],
//                                    EDATAbitstreamSREG [1+2],
//                                    EDATAbitstreamSREG [1+3],
//                                    EDATAbitstreamSREG [1+4],
//                                    EDATAbitstreamSREG [1+5],
//                                    EDATAbitstreamSREG [1+6],
//                                    EDATAbitstreamSREG [1+7],
//                                    EDATAbitstreamSREG [1+8],
//                                    EDATAbitstreamSREG [1+9]};//MSB send first

//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma...
assign comma_valid_bits[0] = (word10b_align_array[0] == COMMAp | word10b_align_array[0]== COMMAn) ? 1:0;
assign comma_valid_bits[1] = (word10b_align_array[1] == COMMAp | word10b_align_array[1]== COMMAn) ? 1:0;

















// HDL Embedded Text Block 13 eb5
  // buffer the output data
  
always @ (swap_inputbits, edataIN)
begin
  if (swap_inputbits)
  edata_in_r = {edataIN[0],edataIN[1]};
  else     
  edata_in_r = edataIN;
end
  


endmodule // EPROC_IN2_DEC8b10b

