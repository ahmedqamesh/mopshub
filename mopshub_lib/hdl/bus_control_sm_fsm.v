//
// Module mopshub_lib.bus_control_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 16:20:54 02/16/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module bus_control_SM( 
   // Port Declarations
   input   wire           abort,         // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,           // posedge
   input   wire           cnt_done, 
   input   wire           end_cnt, 
   input   wire           rst,           // synchronous low active
   input   wire           start_bus_en,  // initialize request from bridge FSM of bridge controller 
   input   wire           start_mon_en, 
   input   wire           timeoutrst,    // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [4:0]  addr,          // request to caninterface block
   output  reg            bus_en_done,   // indication to bridge FSM when initialization is finished 
   output  reg            cs_m, 
   output  reg            cs_p, 
   output  reg            entimeout, 
   output  reg            mon_en_done, 
   output  reg            start_cnt, 
   output  reg            start_init, 
   output  reg     [5:0]  statedeb       // State debug signal 
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact         = 6'd0,
          reset             = 6'd1,
          ST_Init           = 6'd2,
          st_rest           = 6'd3,
          ST_Config         = 6'd4,
          accmask           = 6'd5,
          accmask1          = 6'd6,
          write_csrs        = 6'd7,
          ST_calibration    = 6'd8,
          endinit           = 6'd9,
          start             = 6'd10,
          ST_Init_1         = 6'd11,
          st_Init_2         = 6'd12,
          ST_Config1        = 6'd13,
          write_csrs1       = 6'd14,
          ST_Gain_calibrate = 6'd15,
          endinit1          = 6'd16,
          start1            = 6'd17,
          ST_Rest_1         = 6'd18,
          ST_Rest_2         = 6'd19,
          ST_Rest_4         = 6'd20,
          ST_Rest_RS_1      = 6'd21,
          ST_Rest_RS_2      = 6'd22,
          St_wait           = 6'd23,
          St_wait1          = 6'd24,
          St_wait2          = 6'd25,
          ST_Config2        = 6'd26,
          ST_Config3        = 6'd27,
          ST_Config4        = 6'd28,
          ST_Read_reg       = 6'd29,
          ST_Read_RS_3      = 6'd30,
          ST_Read_reg1      = 6'd31,
          ST_Read_RS_4      = 6'd32,
          St_wait3          = 6'd33,
          write_csrs2       = 6'd34,
          write_csrs3       = 6'd35,
          write_csrs4       = 6'd36,
          write_csrs5       = 6'd37,
          write_csrs6       = 6'd38,
          write_csrs7       = 6'd39,
          ST_Read_reg2      = 6'd40,
          ST_Read_RS_5      = 6'd41,
          St_wait4          = 6'd42,
          ST_calibrate1     = 6'd43,
          ST_calibrate2     = 6'd44,
          ST_calibrate3     = 6'd45,
          ST_Rest_RS_3      = 6'd46,
          ST_Rest_RS_4      = 6'd47,
          ST_Rest_RS_5      = 6'd48,
          ST_Rest_RS_6      = 6'd49;

reg [5:0] current_state, next_state;

// Wait State Signals
reg [3:0] csm_timer;
reg [3:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_Init_1;
reg       csm_to_ST_Rest_2;
reg       csm_to_ST_Rest_RS_2;
reg       csm_to_ST_Read_RS_3;
reg       csm_to_ST_Read_RS_4;
reg       csm_to_ST_Read_RS_5;
reg       csm_to_ST_Rest_RS_3;
reg       csm_to_ST_Rest_RS_4;
reg       csm_to_ST_Rest_RS_5;
reg       csm_to_ST_Rest_RS_6;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   csm_timeout, 
   current_state, 
   rst, 
   start_bus_en, 
   start_mon_en
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_Init_1 = 1'b0;
   csm_to_ST_Rest_2 = 1'b0;
   csm_to_ST_Rest_RS_2 = 1'b0;
   csm_to_ST_Read_RS_3 = 1'b0;
   csm_to_ST_Read_RS_4 = 1'b0;
   csm_to_ST_Read_RS_5 = 1'b0;
   csm_to_ST_Rest_RS_3 = 1'b0;
   csm_to_ST_Rest_RS_4 = 1'b0;
   csm_to_ST_Rest_RS_5 = 1'b0;
   csm_to_ST_Rest_RS_6 = 1'b0;
   case (current_state) 
      waittoact: begin
         if (start_bus_en  == 1)
            next_state = start;
         else if (start_mon_en ==1)
            next_state = start1;
         else
            next_state = waittoact;
      end
      reset: begin
         if (rst == 1)
            next_state = waittoact;
         else
            next_state = reset;
      end
      ST_Init: begin
         next_state = st_rest;
      end
      st_rest: begin
         next_state = ST_Config;
      end
      ST_Config: begin
         next_state = write_csrs;
      end
      accmask: begin
         next_state = accmask1;
      end
      accmask1: begin
         next_state = endinit;
      end
      write_csrs: begin
         next_state = ST_calibration;
      end
      ST_calibration: begin
         next_state = accmask;
      end
      endinit: begin
         next_state = waittoact;
      end
      start: begin
         next_state = ST_Init;
      end
      ST_Init_1: begin
         if (csm_timeout)
            next_state = st_Init_2;
         else
            next_state = ST_Init_1;
      end
      st_Init_2: begin
         next_state = ST_Rest_1;
      end
      ST_Config1: begin
         next_state = ST_Config2;
      end
      write_csrs1: begin
         next_state = write_csrs2;
      end
      ST_Gain_calibrate: begin
         next_state = ST_Rest_RS_3;
         csm_to_ST_Rest_RS_3 = 1'b1;
      end
      endinit1: begin
         next_state = waittoact;
      end
      start1: begin
         next_state = ST_Init_1;
         csm_to_ST_Init_1 = 1'b1;
      end
      ST_Rest_1: begin
         next_state = ST_Rest_2;
         csm_to_ST_Rest_2 = 1'b1;
      end
      ST_Rest_2: begin
         if (csm_timeout)
            next_state = ST_Rest_4;
         else
            next_state = ST_Rest_2;
      end
      ST_Rest_4: begin
         next_state = St_wait;
      end
      ST_Rest_RS_1: begin
         next_state = ST_Rest_RS_2;
         csm_to_ST_Rest_RS_2 = 1'b1;
      end
      ST_Rest_RS_2: begin
         if (csm_timeout)
            next_state = St_wait1;
         else
            next_state = ST_Rest_RS_2;
      end
      St_wait: begin
         next_state = ST_Rest_RS_1;
      end
      St_wait1: begin
         next_state = ST_Read_reg;
      end
      St_wait2: begin
         next_state = ST_Config1;
      end
      ST_Config2: begin
         next_state = ST_Config3;
      end
      ST_Config3: begin
         next_state = ST_Config4;
      end
      ST_Config4: begin
         next_state = ST_Read_reg1;
      end
      ST_Read_reg: begin
         next_state = ST_Read_RS_3;
         csm_to_ST_Read_RS_3 = 1'b1;
      end
      ST_Read_RS_3: begin
         if (csm_timeout)
            next_state = St_wait2;
         else
            next_state = ST_Read_RS_3;
      end
      ST_Read_reg1: begin
         next_state = ST_Read_RS_4;
         csm_to_ST_Read_RS_4 = 1'b1;
      end
      ST_Read_RS_4: begin
         if (csm_timeout)
            next_state = St_wait3;
         else
            next_state = ST_Read_RS_4;
      end
      St_wait3: begin
         next_state = write_csrs1;
      end
      write_csrs2: begin
         next_state = write_csrs3;
      end
      write_csrs3: begin
         next_state = write_csrs4;
      end
      write_csrs4: begin
         next_state = write_csrs5;
      end
      write_csrs5: begin
         next_state = write_csrs6;
      end
      write_csrs6: begin
         next_state = write_csrs7;
      end
      write_csrs7: begin
         next_state = St_wait4;
      end
      ST_Read_reg2: begin
         next_state = ST_Read_RS_5;
         csm_to_ST_Read_RS_5 = 1'b1;
      end
      ST_Read_RS_5: begin
         if (csm_timeout)
            next_state = ST_Gain_calibrate;
         else
            next_state = ST_Read_RS_5;
      end
      St_wait4: begin
         next_state = ST_Read_reg2;
      end
      ST_calibrate1: begin
         next_state = ST_Rest_RS_4;
         csm_to_ST_Rest_RS_4 = 1'b1;
      end
      ST_calibrate2: begin
         next_state = ST_Rest_RS_5;
         csm_to_ST_Rest_RS_5 = 1'b1;
      end
      ST_calibrate3: begin
         next_state = ST_Rest_RS_6;
         csm_to_ST_Rest_RS_6 = 1'b1;
      end
      ST_Rest_RS_3: begin
         if (csm_timeout)
            next_state = ST_calibrate1;
         else
            next_state = ST_Rest_RS_3;
      end
      ST_Rest_RS_4: begin
         if (csm_timeout)
            next_state = ST_calibrate2;
         else
            next_state = ST_Rest_RS_4;
      end
      ST_Rest_RS_5: begin
         if (csm_timeout)
            next_state = ST_calibrate3;
         else
            next_state = ST_Rest_RS_5;
      end
      ST_Rest_RS_6: begin
         if (csm_timeout)
            next_state = endinit1;
         else
            next_state = ST_Rest_RS_6;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   addr = 5'b11111;
   bus_en_done = 0;
   cs_m = 1;
   cs_p = 1;
   entimeout = 1;
   mon_en_done = 0;
   start_cnt = 0;
   start_init = 0;

   // Combined Actions
   case (current_state) 
      waittoact: begin
         entimeout =0;
      end
      ST_Init: begin
         addr = 5'b01111;
         cs_p = 0 ;
      end
      st_rest: begin
         addr = 5'b01110;
         cs_p = 0 ;
      end
      ST_Config: begin
         addr = 5'b10010 ;
         cs_p = 0 ;
      end
      accmask: begin
         addr = 5'b10001 ;
         cs_p = 0 ;
      end
      accmask1: begin
         addr = 5'b10000 ;
         cs_p = 0 ;
      end
      write_csrs: begin
         addr = 5'b00101;
         cs_p = 0 ;
      end
      ST_calibration: begin
         addr = 5'b00100 ;
         cs_p = 0 ;
      end
      endinit: begin
         bus_en_done=1;
      end
      start: begin
         start_init =1;
      end
      ST_Init_1: begin
         addr = 5'h1;
         cs_m = 0 ;
      end
      st_Init_2: begin
         addr = 5'h2;
         cs_m = 0 ;
      end
      ST_Config1: begin
         addr = 5'h3 ;
         cs_m = 0 ;
      end
      write_csrs1: begin
         addr = 5'h9;
         cs_m = 0 ;
      end
      ST_Gain_calibrate: begin
         addr = 5'hF ;
         cs_m =0 ;
      end
      endinit1: begin
         mon_en_done=1;
      end
      start1: begin
         start_init =1;
      end
      ST_Rest_1: begin
         addr = 5'h3;
         cs_m = 0 ;
      end
      ST_Rest_2: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      ST_Rest_4: begin
         addr = 5'h5;
         cs_m = 0 ;
      end
      ST_Rest_RS_1: begin
         addr = 5'h3;
         cs_m = 0 ;
      end
      ST_Rest_RS_2: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      St_wait: begin
         cs_m = 0 ;
      end
      St_wait1: begin
         cs_m = 0 ;
      end
      St_wait2: begin
         cs_m = 0 ;
      end
      ST_Config2: begin
         addr = 5'h4 ;
         cs_m = 0 ;
      end
      ST_Config3: begin
         addr = 5'h8 ;
         cs_m = 0 ;
      end
      ST_Config4: begin
         addr = 5'h4 ;
         cs_m = 0 ;
      end
      ST_Read_reg: begin
         addr = 5'h7;
         cs_m = 0 ;
      end
      ST_Read_RS_3: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      ST_Read_reg1: begin
         addr = 5'h7;
         cs_m = 0 ;
      end
      ST_Read_RS_4: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      St_wait3: begin
         cs_m = 0 ;
      end
      write_csrs2: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      write_csrs3: begin
         addr = 5'hA;
         cs_m = 0 ;
      end
      write_csrs4: begin
         addr = 5'hB;
         cs_m = 0 ;
      end
      write_csrs5: begin
         addr = 5'hC;
         cs_m = 0 ;
      end
      write_csrs6: begin
         addr = 5'hD;
         cs_m = 0 ;
      end
      write_csrs7: begin
         addr = 5'hB;
         cs_m = 0 ;
      end
      ST_Read_reg2: begin
         addr = 5'hE;
         cs_m = 0 ;
      end
      ST_Read_RS_5: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      St_wait4: begin
         cs_m = 0 ;
      end
      ST_calibrate1: begin
         addr = 5'h10 ;
         cs_m =0 ;
      end
      ST_calibrate2: begin
         addr = 5'h11 ;
         cs_m =0 ;
      end
      ST_calibrate3: begin
         addr = 5'h12 ;
         cs_m =0 ;
      end
      ST_Rest_RS_3: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      ST_Rest_RS_4: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      ST_Rest_RS_5: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
      ST_Rest_RS_6: begin
         addr = 5'h4;
         cs_m = 0 ;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
      csm_timer <= 4'd0;
   end
   else if (timeoutrst) begin
      current_state <= reset;
      csm_timer <= 4'd0;
   end
   else if (abort) begin
      current_state <= reset;
      csm_timer <= 4'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_Init_1,
   csm_to_ST_Rest_2,
   csm_to_ST_Rest_RS_2,
   csm_to_ST_Read_RS_3,
   csm_to_ST_Read_RS_4,
   csm_to_ST_Read_RS_5,
   csm_to_ST_Rest_RS_3,
   csm_to_ST_Rest_RS_4,
   csm_to_ST_Rest_RS_5,
   csm_to_ST_Rest_RS_6
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 4'd0);
   if (csm_to_ST_Init_1 == 1'b1) begin
      csm_next_timer = 4'd14;  //no cycles(15)-1=14
   end
   else if (csm_to_ST_Rest_2 == 1'b1) begin
      csm_next_timer = 4'd1;  //no cycles(2)-1=1
   end
   else if (csm_to_ST_Rest_RS_2 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Read_RS_3 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Read_RS_4 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Read_RS_5 == 1'b1) begin
      csm_next_timer = 4'd11;  //no cycles(12)-1=11
   end
   else if (csm_to_ST_Rest_RS_3 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Rest_RS_4 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Rest_RS_5 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else if (csm_to_ST_Rest_RS_6 == 1'b1) begin
      csm_next_timer = 4'd2;  //no cycles(3)-1=2
   end
   else begin
      csm_next_timer = (csm_timeout)? 4'd0: (csm_timer - 4'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
statedeb = current_state;

endmodule // bus_control_SM
