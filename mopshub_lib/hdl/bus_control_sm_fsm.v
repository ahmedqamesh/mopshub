//
// Module mopshub_lib.bus_control_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:43:16 02/15/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module bus_control_SM( 
   // Port Declarations
   input   wire           abort,              // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,                // posedge
   input   wire           end_cnt, 
   input   wire           power_bus_en,       // initialize request from bridge FSM of bridge controller 
   input   wire           rst,                // synchronous low active
   input   wire           timeoutrst,         // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [4:0]  addr,               // request to caninterface block
   output  reg            cs_can, 
   output  reg            initi,              // request to caninterface block
   output  reg            power_bus_en_done,  // indication to bridge FSM when initialization is finished 
   output  reg            rst_cnt, 
   output  reg            start_cnt, 
   output  reg            start_init, 
   output  reg     [5:0]  statedeb,           // State debug signal 
   output  reg            write               // request to caninterface block
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact = 4'd0,
          reset     = 4'd1,
          prescalar = 4'd2,
          general   = 4'd3,
          encom     = 4'd4,
          accmask   = 4'd5,
          accmask1  = 4'd6,
          idr3      = 4'd7,
          idr4      = 4'd8,
          endinit   = 4'd9,
          start     = 4'd10;

reg [3:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   power_bus_en, 
   rst
)
begin : next_state_block_proc
   case (current_state) 
      waittoact: begin
         if (power_bus_en  == 1)
            next_state = start;
         else
            next_state = waittoact;
      end
      reset: begin
         if (rst == 1)
            next_state = waittoact;
         else
            next_state = reset;
      end
      prescalar: begin
         next_state = general;
      end
      general: begin
         next_state = encom;
      end
      encom: begin
         next_state = idr3;
      end
      accmask: begin
         next_state = accmask1;
      end
      accmask1: begin
         next_state = endinit;
      end
      idr3: begin
         next_state = idr4;
      end
      idr4: begin
         next_state = accmask;
      end
      endinit: begin
         next_state = waittoact;
      end
      start: begin
         next_state = prescalar;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   addr = 5'b11111;
   cs_can = 0;
   initi = 0;
   power_bus_en_done = 0;
   rst_cnt = 0;
   start_cnt = 0;
   start_init = 0;
   write = 1;

   // Combined Actions
   case (current_state) 
      prescalar: begin
         initi = 1 ;
         addr = 5'b01111;
         write = 0 ;
         cs_can = 1 ;
      end
      general: begin
         initi = 1;
         addr = 5'b01110;
         write = 0 ;
         cs_can = 1 ;
      end
      encom: begin
         initi = 1;
         addr = 5'b10010 ;
         write = 0 ;
         cs_can = 1 ;
      end
      accmask: begin
         initi = 1 ;
         addr = 5'b10001 ;
         write = 0 ;
         cs_can = 1 ;
      end
      accmask1: begin
         initi = 1 ;
         addr = 5'b10000 ;
         write = 0 ;
         cs_can = 1 ;
      end
      idr3: begin
         addr = 5'b00101;
         initi = 1 ;
         write = 0 ;
         cs_can = 1 ;
      end
      idr4: begin
         initi = 1;
         addr = 5'b00100 ;
         write = 0 ;
         cs_can = 1 ;
      end
      endinit: begin
         power_bus_en_done=1;
      end
      start: begin
         start_init =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
   end
   else if (timeoutrst) begin
      current_state <= reset;
   end
   else if (abort) begin
      current_state <= reset;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

// State-As-Output assignment
always @(current_state)
begin
   statedeb = 6'b0;
   statedeb[3:0] = current_state;
end

endmodule // bus_control_SM
