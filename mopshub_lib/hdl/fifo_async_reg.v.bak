//
// Module mopshub_lib.fifo_async_reg.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 19:54:29 04/24/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module fifo_async_reg#(
   // synopsys template
   parameter DSIZE       = 10,
   parameter ASIZE       = 16
)( 
  // Port Declarations
  input   wire           wclk, 
  input   wire           rclk, 
  input   wire    [DSIZE-1:0]  wdata, 
  input   wire           rinc, 
  input   wire           wrst_n, 
  input   wire           rrst_n,
  input   wire           winc, 
  output  wire           aempty, 
  output  wire           afull, 
  output  wire           empty, 
  output  wire    [DSIZE-1:0]  dout_fifo, 
  output  wire           full
  );
  
  // Internal Declarations
  reg [DSIZE-1:0] data_reg_cval0;
  reg [DSIZE-1:0] data_reg_cval1;
  reg [DSIZE-1:0] data_reg_cval2;
  reg [DSIZE-1:0] data_reg_cval3;
  reg [DSIZE-1:0] data_reg_cval4;
  reg [DSIZE-1:0] data_reg_cval5;
 
  
  wire [DSIZE-1:0] data_reg_nval0; 
  wire [DSIZE-1:0] data_reg_nval1;
  wire [DSIZE-1:0] data_reg_nval2;
  wire [DSIZE-1:0] data_reg_nval3;
  wire [DSIZE-1:0] data_reg_nval4;
  wire [DSIZE-1:0] data_reg_nval5;

  wire temp_rinc; //never read from an empty FIFO
  wire temp_winc; //never write to a full FIFO
  wire temp_full;
  wire temp_empty;
  
  
  reg  [ASIZE-1:0] waddr_cval; //Represents the current value of the address pointer
  wire [ASIZE-1:0] waddr_nval; //Represents the next value of the address pointer

  // Instances 
  assign full = temp_full;
  assign empty = temp_empty;
  
  assign dout_fifo = data_reg_cval0;
    
  assign afull  = !temp_full;
  assign aempty = !temp_empty;
  
  assign temp_rinc  = wrst_n & rinc & !temp_empty;
  assign temp_winc  = wrst_n & winc & !temp_full;
  assign temp_empty = (waddr_cval == 0);
  assign temp_full  = (waddr_cval == 20);
 
 //updates the address pointer based on the write and read operations
 //ensures that waddr_nval reflects the correct address for the next clock cycle.
  // waddr_cval ==waddr_nval if no read or write  waddr_nval retains its current value
  // When Writing waddr_cval incremented to move to the next location in the FIFO
  // When Reading waddr_cval decrement to move to the previous location in the FIFO.
  assign waddr_nval =  (!wrst_n) ? 0
                      : temp_winc  ? waddr_cval + 1'b1
                      : temp_rinc ? waddr_cval - 1'b1
                      : waddr_cval;
    
// write address waddr_cval based on the next write address value waddr_nval
  always @(posedge wclk)
  begin 
    if (!wrst_n) waddr_cval <=  0;
    else 
    waddr_cval <= waddr_nval;
   end
 //The contents of the data_reg_cval registers are updated with the corresponding values from the data_reg_nval registers 
  always @(posedge wclk)
  begin 
    if (!wrst_n)
    begin
        data_reg_cval0[DSIZE-1:0]  <= 10'b0 ;
        data_reg_cval1[DSIZE-1:0]  <= 10'b0  ;
        data_reg_cval2[DSIZE-1:0]  <= 10'b0  ;
        data_reg_cval3[DSIZE-1:0]  <= 10'b0 ;
        data_reg_cval4[DSIZE-1:0]  <= 10'b0  ;
        data_reg_cval5[DSIZE-1:0]  <= 10'b0  ;
        end
    else 
    begin
      data_reg_cval0[DSIZE-1:0]  <= data_reg_nval0[DSIZE-1:0] ;
      data_reg_cval1[DSIZE-1:0]  <= data_reg_nval1[DSIZE-1:0] ;
      data_reg_cval2[DSIZE-1:0]  <= data_reg_nval2[DSIZE-1:0] ;
      data_reg_cval3[DSIZE-1:0]  <= data_reg_nval3[DSIZE-1:0] ;
      data_reg_cval4[DSIZE-1:0]  <= data_reg_nval4[DSIZE-1:0] ;
      data_reg_cval5[DSIZE-1:0]  <= data_reg_nval5[DSIZE-1:0] ;
    end
  end


//assignments determine the values of data_reg_nval based on the write and read operations, as well as the current address pointer waddr_cval 
// (1) If temp_winc is 1 while temp_rinc is 0(indicating a write increment operation is enabled). 
//     The value of data_reg_cval0 is assigned to data_reg_nval0[DSIZE-1:0].
// (2) If temp_rinc is 1 while temp_winc is 0(indicating a read increment operation is enabled). 
//     The value of data_reg_cval1 is assigned to data_reg_nval0[DSIZE-1:0].
// (3) If both temp_winc and temp_rinc are false, the current value of data_reg_cval0[DSIZE-1:0] is retained in data_reg_nval0[DSIZE-1:0].                                            
  assign data_reg_nval0[DSIZE-1:0] = temp_winc ? data_reg_cval0[DSIZE-1:0] 
                                   : temp_rinc ? data_reg_cval1[DSIZE-1:0] : data_reg_cval0[DSIZE-1:0];
  
  assign data_reg_nval1[DSIZE-1:0] = temp_winc ? (waddr_cval == 0) ? wdata : data_reg_cval1[DSIZE-1:0]
                                   : temp_rinc ? data_reg_cval2[DSIZE-1:0] : data_reg_cval1[DSIZE-1:0];
  
  assign data_reg_nval2[DSIZE-1:0] = temp_winc ? (waddr_cval == 1) ? wdata : data_reg_cval2[DSIZE-1:0]
                                   : temp_rinc ? data_reg_cval3[DSIZE-1:0] : data_reg_cval2[DSIZE-1:0];
                                              
  assign data_reg_nval3[DSIZE-1:0] = temp_winc ? (waddr_cval == 2) ? wdata : data_reg_cval3[DSIZE-1:0]
                                   : temp_rinc ? data_reg_cval4[DSIZE-1:0] : data_reg_cval3[DSIZE-1:0];
  
  assign data_reg_nval4[DSIZE-1:0] = temp_winc ? (waddr_cval == 3) ? wdata : data_reg_cval4[DSIZE-1:0]
                                   : temp_rinc ? data_reg_cval5[DSIZE-1:0] : data_reg_cval4[DSIZE-1:0];
  
  assign data_reg_nval5[DSIZE-1:0] = temp_winc ? (waddr_cval == 4) ? wdata : data_reg_cval5[DSIZE-1:0] 
                                   : temp_rinc ? data_reg_cval5[DSIZE-1:0] : data_reg_cval5[DSIZE-1:0];
  
endmodule 

