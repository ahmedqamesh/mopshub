//
// Module mopshub_lib.elink_core.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 11:59:58 03/01/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_core #(
   // synopsys template
   parameter Kchar_sop   = 8'b00111100,  // K28.1 3C
   parameter Kchar_eop   = 8'b11011100,  // K28.6 DC
   parameter Kchar_comma = 8'b10111100   //K28.5  BC
)
( 
   // Port Declarations
   input   wire            clk, 
   input   wire            rst, 
   input   wire            enc_stream, 
   output  wire            rx_fifo_full, 
   input   wire    [75:0]  data_rec_uplink, 
   input   wire            start_write_elink, 
   output  wire            tx_efifo_full, 
   output  wire            irq_elink_rec, 
   output  wire            irq_elink_tra, 
   output  wire            end_write_elink, 
   input   wire            start_read_elink, 
   output  wire            end_read_elink, 
   input   wire    [1:0]   data_2bit_in, 
   output  wire    [1:0]   data_2bit_out, 
   input   wire            fifo_flush, 
   output  wire            tx_data_rdy, 
   output  wire            rx_data_rdy, 
   output  wire    [75:0]  data_tra_out, 
   output  wire            buffer_tra_en, 
   output  wire    [31:0]  data_tra_spi_out, 
   output  wire            irq_spi_tra, 
   output  wire            buffer_spi_tra_en, 
   input   wire    [31:0]  data_rec_spi_in, 
   output  wire            end_write_elink_spi, 
   input   wire            start_write_elink_spi, 
   input   wire            timeoutrst,             // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   input   wire            abort
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         timeoutrst_elink_tra;                    // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
wire  [4:0]  addr_write;                              // request to caninterface block
wire         cs_ewrite;
wire  [9:0]  data_rec_10bitout;
wire  [7:0]  data_rec_8bitout;
wire  [1:0]  data_rec_delimiter;
wire         cs_eread;
reg          fifo_data_packet;
reg          fifo_data_sop           = 1'b0;
reg          fifo_data_eop           = 1'b0;
reg          spi_power_reg           = 1'b0;
reg          spi_mon_reg             = 1'b0;
reg          can_id_reg              = 1'b0;
wire  [4:0]  addr_read;                               // request to caninterface block
wire  [9:0]  data_tra_10bitin;
wire         buffer_elink_en;
wire  [5:0]  statedeb_rec;
wire  [6:0]  statedeb_tra;
wire         buffer_rec_en;
wire         rx_fifo_empty;
wire         tx_fifo_empty;
wire         can_id;
wire         spi_mon;
wire         buffer_elink_spi_en;
wire         buffer_spi_rec_en;
wire  [7:0]  data_rec_spi_8bitout;
wire  [1:0]  data_rec_spi_delimiter;
wire         spi_mode;
wire         spi_power;
wire         entimeout_elink_rec;                     // enable for timeout reset counter 
wire         entimeout_elink_tra;                     // enable for timeout reset counter 
wire  [31:0] time_limit_trim         = 32'd1000000;   //corresponds to 25 msec if the FPGA freq is 40Mhz


// Instances 
buffer_rec_elink rec_elink_buf0( 
   .data_rec_in        (data_rec_uplink), 
   .addr               (addr_write), 
   .Kchar_eop          (), 
   .Kchar_sop          (), 
   .data_rec_8bitout   (data_rec_8bitout), 
   .data_rec_delimiter (data_rec_delimiter)
); 

buffer_rec_spi buffer_rec_spi0( 
   .data_rec_in        (data_rec_spi_in), 
   .addr               (addr_write), 
   .Kchar_eop          (), 
   .Kchar_sop          (), 
   .data_rec_8bitout   (data_rec_spi_8bitout), 
   .data_rec_delimiter (data_rec_spi_delimiter)
); 

buffer_tra_elink tra_elink_buf0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_elink_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_out)
); 

buffer_tra_spi buffer_tra_spi0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_elink_spi_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_spi_out)
); 

elink_interface_rec_SM elink_interface_rec_SM0( 
   .abort                 (abort), 
   .clk                   (clk), 
   .rst                   (rst), 
   .start_write_elink     (start_write_elink), 
   .start_write_elink_spi (start_write_elink_spi), 
   .timeoutrst            (timeoutrst), 
   .addr_write            (addr_write), 
   .buffer_rec_en         (buffer_rec_en), 
   .buffer_spi_rec_en     (buffer_spi_rec_en), 
   .cs_ewrite             (cs_ewrite), 
   .end_write_elink       (end_write_elink), 
   .end_write_elink_spi   (end_write_elink_spi), 
   .entimeout             (entimeout_elink_rec), 
   .irq_elink_rec         (irq_elink_rec), 
   .spi_mode              (spi_mode), 
   .statedeb              (statedeb_rec)
); 

elink_interface_tra_SM elink_interface_tra_SM0( 
   .abort               (abort), 
   .can_id              (can_id), 
   .clk                 (clk), 
   .fifo_data_eop       (fifo_data_eop), 
   .fifo_data_sop       (fifo_data_sop), 
   .fifo_elink_rdy      (rx_data_rdy), 
   .fifo_packet_rdy     (fifo_data_packet), 
   .rst                 (rst), 
   .spi_mon             (spi_mon), 
   .start_read_elink    (start_read_elink), 
   .timeoutrst          (timeoutrst_elink_tra), 
   .addr_read           (addr_read), 
   .buffer_elink_en     (buffer_elink_en), 
   .buffer_elink_spi_en (buffer_elink_spi_en), 
   .buffer_spi_en       (buffer_spi_tra_en), 
   .buffer_tra_en       (buffer_tra_en), 
   .cs_eread            (cs_eread), 
   .end_read_elink      (end_read_elink), 
   .entimeout           (entimeout_elink_tra), 
   .irq_elink_tra       (irq_elink_tra), 
   .irq_spi_tra         (irq_spi_tra), 
   .statedeb            (statedeb_tra)
); 

elink_to_fifo #(Kchar_comma,Kchar_eop,Kchar_sop) elink_to_fifo0( 
   .fifo_flush    (fifo_flush), 
   .fifo_full     (rx_fifo_full), 
   .fifo_dout     (data_tra_10bitin), 
   .clk           (clk), 
   .fifo_rd_en    (cs_eread), 
   .data_2bit_in  (data_2bit_in), 
   .rst           (rst), 
   .enc_stream    (enc_stream), 
   .rx_fifo_empty (rx_fifo_empty)
); 

fifo_to_elink #(Kchar_comma,Kchar_eop,Kchar_sop) fifo_to_elink0( 
   .fifo_wr_en    (cs_ewrite), 
   .clk           (clk), 
   .fifo_din      (data_rec_10bitout), 
   .fifo_flush    (fifo_flush), 
   .data_2bit_out (data_2bit_out), 
   .efifo_empty   (tx_fifo_empty), 
   .efifo_full    (tx_efifo_full), 
   .rst           (rst), 
   .enc_stream    (enc_stream)
); 

timout_rst timout_rst1( 
   .clk        (clk), 
   .entimeout  (entimeout_elink_tra), 
   .time_limit (time_limit_trim), 
   .rst        (rst), 
   .timeoutrst (timeoutrst_elink_tra)
); 

// HDL Embedded Text Block 6 FIFO_read1

//Check FIFO output
assign can_id     = can_id_reg;
assign spi_mon    = spi_mon_reg;
assign spi_power  = spi_power_reg;
always@(*) 
  begin
  if(cs_eread && data_tra_10bitin == {2'b10,Kchar_sop})// 0x3c = 0011 1100 SOP (if 8b10b)
      begin
        fifo_data_sop    = 1'b1;
        fifo_data_eop    = 1'b0;
        fifo_data_packet = 1'b0;
        can_id_reg       = 1'b0;
        spi_mon_reg      = 1'b0;
        spi_power_reg    = 1'b0;
      end 
    else if(cs_eread && data_tra_10bitin != {2'b10,Kchar_sop}&& data_tra_10bitin != {2'b01,Kchar_eop} && data_tra_10bitin[9:8] == 2'b00)// data
      begin
        fifo_data_sop    = 1'b0;
        fifo_data_eop    = 1'b0;
        fifo_data_packet = 1'b1;
        if (addr_read ==5'h02)//detect the first Byte
          case(data_tra_10bitin[7:0])
            8'h080 : 
            begin
              spi_mon_reg   = 1'b1;
              can_id_reg    = 1'b0;
              spi_power_reg = 1'b0;
            end
            8'h090 : 
            begin
              spi_mon_reg   = 1'b0;
              can_id_reg    = 1'b0;
              spi_power_reg = 1'b1;
            end
            8'h000 :begin 
                can_id_reg     = 1'b1;
                spi_mon_reg    = 1'b0;
                spi_power_reg  = 1'b1;
                    end
            default:
            begin
              can_id_reg    = 1'b1;
              spi_mon_reg   = 1'b0;
              spi_power_reg = 1'b0;
              end
            endcase
        else
          begin
            can_id_reg    = 1'b0;
            spi_mon_reg   = 1'b0;
            spi_power_reg = 1'b0;
            end        
            
      end   
    else if(cs_eread && data_tra_10bitin == {2'b01,Kchar_eop})// 0xdc = 1101 1100 (if 8b10b)
      begin
       fifo_data_sop    = 1'b0;
       fifo_data_eop    = 1'b1;
       fifo_data_packet = 1'b0;
       can_id_reg       = 1'b0;
       spi_mon_reg      = 1'b0;
       spi_power_reg    = 1'b0;
      end
    else  
      begin
       can_id_reg       = 1'b0;
       spi_mon_reg      = 1'b0;
       spi_power_reg    = 1'b0;
       fifo_data_sop    = 1'b0;
       fifo_data_eop    = 1'b0;
       fifo_data_packet = 1'b0;
      end    
  end

































































































































































// HDL Embedded Text Block 9 rdy
assign rx_data_rdy = !rx_fifo_empty;
assign tx_data_rdy = !tx_fifo_empty;














































































































































// HDL Embedded Text Block 10 FIFO_write1
assign data_rec_10bitout =(spi_mode ==1)?{data_rec_spi_delimiter,data_rec_spi_8bitout}:{data_rec_delimiter,data_rec_8bitout}; 








































































































































endmodule // elink_core

