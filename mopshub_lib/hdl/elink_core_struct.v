//
// Module mopshub_lib.elink_core.struct
//
// Created:
//          by - Ahmed Qamesh (University of Wuppertal)
//          at - 17:05:33 05/12/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_core( 
   // Port Declarations
   input   wire            clk, 
   input   wire            rst, 
   output  wire            rx_fifo_full, 
   input   wire    [75:0]  data_rec_uplink, 
   input   wire            start_write_elink, 
   output  wire            tx_efifo_full, 
   output  wire            irq_elink_rec, 
   output  wire            irq_elink_tra, 
   output  wire            end_write_elink, 
   input   wire            start_read_elink, 
   output  wire            end_read_elink, 
   input   wire    [1:0]   data_2bit_in, 
   output  wire    [1:0]   data_2bit_out, 
   input   wire            fifo_flush, 
   output  wire            tx_data_rdy, 
   output  wire            rx_data_rdy, 
   output  wire    [75:0]  data_tra_out, 
   output  wire            buffer_tra_en, 
   output  wire    [75:0]  data_tra_mon_spi, 
   input   wire    [75:0]  data_rec_spi_in, 
   output  wire            end_write_elink_spi, 
   input   wire            start_write_elink_spi, 
   input   wire            timeoutrst,             // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   input   wire            abort, 
   input   wire    [9:0]   data_10bit_in_dbg, 
   input   wire            dbg_elink, 
   input   wire            dbg_spi, 
   output  wire    [7:0]   statedeb_elink_tra, 
   output  wire    [7:0]   statedeb_elink_rec, 
   output  wire            word10b_rdy, 
   input   wire            start_write_elink_dbg, 
   input   wire    [75:0]  data_rec_dbg_in, 
   output  wire            end_write_elink_dbg, 
   output  wire            irq_elink_eth, 
   output  wire    [75:0]  data_tra_power_spi, 
   output  wire            irq_spi_power_on, 
   output  wire            buffer_eth_en, 
   output  wire            irq_spi_mon_tra, 
   output  wire    [9:0]   dec10b_in_dbg, 
   output  wire            dec10b_in_rdy_dbg, 
   input   wire            data_rdy_10bit_in_dbg, 
   input   wire    [7:0]   Kchar_comma, 
   input   wire    [7:0]   Kchar_eop, 
   input   wire    [7:0]   Kchar_sop, 
   input   wire    [9:0]   COMMAn, 
   input   wire    [9:0]   COMMAp, 
   output  wire            start_read_eth_fifo, 
   input   wire            sign_on_signal, 
   input   wire            end_elink_proc, 
   input   wire            clk_elink, 
   input   wire            endwait, 
   output  wire            enc10b_out_rdy_dbg, 
   output  wire            code_err, 
   output  wire            disp_err, 
   output  wire            rst_id_rec, 
   output  wire            irq_spi_power_off, 
   input   wire    [3:0]   mopshub_id, 
   output  wire    [9:0]   enc10b_out_dbg
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         timeoutrst_elink_tra;    // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
wire  [4:0]  addr_write;              // request to caninterface block
wire         cs_ewrite;
wire  [9:0]  data_rec_10bitout;
wire  [9:0]  data_rec_can_10bitout;
wire  [9:0]  data_rec_dbg_10bitout;
wire  [9:0]  data_rec_spi_10bitout;
wire         cs_eread;
reg          fifo_data_packet;
reg          fifo_data_sop;
reg          fifo_data_eop;
reg          spi_power_on_reg;
reg          spi_power_off_reg;
reg          rst_id_reg;
reg          spi_mon_reg;
reg          can_id_reg;
wire  [4:0]  addr_read;               // request to caninterface block
wire  [9:0]  data_tra_10bitin;
wire         buffer_elink_en;
wire         buffer_rec_en;
wire         rx_fifo_empty;
wire         tx_fifo_empty;
wire         can_id_code;
wire         spi_mon_id_code;
wire         buffer_mon_spi_en;
wire         buffer_spi_rec_en;
wire         spi_rec_mode;
wire         spi_power_off_id_code;
wire         spi_power_on_id_code;
wire         entimeout_elink_rec;     // enable for timeout reset counter 
wire         entimeout_elink_tra;     // enable for timeout reset counter 
wire         spi_tra_mode;
wire         dbg_rec_mode;
wire         can_rec_mode;
wire         buffer_power_spi_en;
reg          partial_reconfig_reg;
wire         partial_reconfig_rec;
wire         rst_mopshub_mode;
wire  [9:0]  data_rec_rst_10bitout;   // Output data to be written on the CAN bus
wire  [75:0] data_rec_rst_in;         // input data from the SCB or Object Dictionary side
wire  [31:0] time_limit;


// Instances 
buffer_rec_elink buffer_rec_elink_can( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_uplink), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_can_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_rec_elink buffer_rec_elink_dbg( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_dbg_in), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_dbg_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_rec_elink buffer_rec_elink_rst( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_rst_in), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_rst_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_rec_elink buffer_rec_elink_spi( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_spi_in), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_spi_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_tra_elink tra_elink_buf0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_elink_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_out)
); 

buffer_tra_elink tra_elink_buf_spi_mon0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_mon_spi_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_mon_spi)
); 

buffer_tra_elink tra_elink_buf_spi_power0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_power_spi_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_power_spi)
); 

buffer_tristate_elink buffer_tristate_elink0( 
   .clk          (clk), 
   .rst          (rst), 
   .data_tra_in0 (data_rec_can_10bitout), 
   .data_tra_in1 (data_rec_dbg_10bitout), 
   .data_tra_in2 (data_rec_spi_10bitout), 
   .data_tra_in3 (data_rec_rst_10bitout), 
   .buffer_en0   (can_rec_mode), 
   .buffer_en1   (dbg_rec_mode), 
   .buffer_en2   (spi_rec_mode), 
   .buffer_en3   (rst_mopshub_mode), 
   .Kchar_comma  (Kchar_comma), 
   .data_tra_out (data_rec_10bitout)
); 

elink_interface_rec_sm elink_interface_rec_SM0( 
   .abort               (abort), 
   .can_id              (can_id_code), 
   .clk                 (clk), 
   .end_elink_proc      (end_elink_proc), 
   .endwait             (endwait), 
   .fifo_data_eop       (fifo_data_eop), 
   .fifo_data_sop       (fifo_data_sop), 
   .fifo_elink_rdy      (rx_data_rdy), 
   .fifo_packet_rdy     (fifo_data_packet), 
   .rst                 (rst), 
   .spi_mon_id          (spi_mon_id_code), 
   .spi_power_off_id    (spi_power_off_id_code), 
   .spi_power_on_id     (spi_power_on_id_code), 
   .start_read_elink    (start_read_elink), 
   .timeoutrst          (timeoutrst_elink_tra), 
   .addr_read           (addr_read), 
   .buffer_elink_en     (buffer_elink_en), 
   .buffer_eth_en       (buffer_eth_en), 
   .buffer_mon_spi_en   (buffer_mon_spi_en), 
   .buffer_power_spi_en (buffer_power_spi_en), 
   .buffer_tra_en       (buffer_tra_en), 
   .cs_eread            (cs_eread), 
   .end_read_elink      (end_read_elink), 
   .entimeout           (entimeout_elink_tra), 
   .irq_elink_eth       (irq_elink_eth), 
   .irq_elink_tra       (irq_elink_tra), 
   .irq_spi_mon_tra     (irq_spi_mon_tra), 
   .irq_spi_power_off   (irq_spi_power_off), 
   .irq_spi_power_on    (irq_spi_power_on), 
   .spi_tra_mode        (spi_tra_mode), 
   .statedeb            (statedeb_elink_rec)
); 

elink_interface_tra_sm elink_interface_tra_SM0( 
   .abort                 (abort), 
   .clk                   (clk), 
   .endwait               (endwait), 
   .rst                   (rst), 
   .sign_in_signal        (sign_on_signal), 
   .start_write_elink_can (start_write_elink), 
   .start_write_elink_dbg (start_write_elink_dbg), 
   .start_write_elink_spi (start_write_elink_spi), 
   .timeoutrst            (timeoutrst), 
   .tx_efifo_full         (tx_efifo_full), 
   .addr_write            (addr_write), 
   .buffer_rec_en         (buffer_rec_en), 
   .buffer_spi_rec_en     (buffer_spi_rec_en), 
   .can_rec_mode          (can_rec_mode), 
   .cs_ewrite             (cs_ewrite), 
   .dbg_rec_mode          (dbg_rec_mode), 
   .end_write_elink       (end_write_elink), 
   .end_write_elink_dbg   (end_write_elink_dbg), 
   .end_write_elink_spi   (end_write_elink_spi), 
   .entimeout             (entimeout_elink_rec), 
   .irq_elink_rec         (irq_elink_rec), 
   .rst_mopshub_mode      (rst_mopshub_mode), 
   .spi_rec_mode          (spi_rec_mode), 
   .start_read_eth_fifo   (start_read_eth_fifo), 
   .statedeb              (statedeb_elink_tra)
); 

elink_receiver elink_receiver0( 
   .fifo_flush    (fifo_flush), 
   .fifo_full     (rx_fifo_full), 
   .fifo_dout     (data_tra_10bitin), 
   .clk           (clk), 
   .fifo_rd_en    (cs_eread), 
   .data_2bit_in  (data_2bit_in), 
   .rst           (rst), 
   .rx_fifo_empty (rx_fifo_empty), 
   .dec10b_in     (dec10b_in_dbg), 
   .dec10b_in_rdy (dec10b_in_rdy_dbg), 
   .COMMAn        (COMMAn), 
   .COMMAp        (COMMAp), 
   .Kchar_comma   (Kchar_comma), 
   .Kchar_eop     (Kchar_eop), 
   .Kchar_sop     (Kchar_sop), 
   .word10b_rdy   (word10b_rdy), 
   .clk_elink     (clk_elink), 
   .code_err      (code_err), 
   .disp_err      (disp_err)
); 

elink_transmitter elink_transmitter0( 
   .fifo_wr_en            (cs_ewrite), 
   .clk                   (clk), 
   .fifo_din              (data_rec_10bitout), 
   .fifo_flush            (fifo_flush), 
   .data_2bit_out         (data_2bit_out), 
   .efifo_empty           (tx_fifo_empty), 
   .efifo_full            (tx_efifo_full), 
   .rst                   (rst), 
   .Kchar_comma           (Kchar_comma), 
   .data_10bit_in_dbg     (data_10bit_in_dbg), 
   .data_rdy_10bit_in_dbg (data_rdy_10bit_in_dbg), 
   .dbg_elink             (dbg_elink), 
   .enc10b_out_rdy        (enc10b_out_rdy_dbg), 
   .clk_elink             (clk_elink), 
   .enc10b_out            (enc10b_out_dbg)
); 

timeout_rst_module timeout_rst_module0( 
   .clk            (clk), 
   .enable_timeout (entimeout_elink_tra), 
   .time_limit     (time_limit), 
   .rst            (rst), 
   .rst_timeout    (timeoutrst_elink_tra)
); 

// HDL Embedded Text Block 6 FIFO_read1
//Check FIFO output
assign can_id_code             = can_id_reg;
assign rst_id_rec         = rst_id_reg && fifo_data_packet&& !buffer_elink_en;
assign spi_mon_id_code         = spi_mon_reg;
assign spi_power_on_id_code    = spi_power_on_reg;
assign spi_power_off_id_code   = spi_power_off_reg;
assign partial_reconfig_rec   = partial_reconfig_reg;
assign data_rec_rst_in ={1'b0,3'h4,4'h0,mopshub_id,64'h0};
always@(posedge clk) 
   if(!rst)
   begin
     partial_reconfig_reg  <= 1'b0;
     can_id_reg          <= 1'b0;
     rst_id_reg          <= 1'b0;
     spi_mon_reg         <= 1'b0;
     spi_power_on_reg    <= 1'b0;
     spi_power_off_reg   <= 1'b0;
     fifo_data_sop    <= 1'b0;
     fifo_data_eop    <= 1'b0;
     fifo_data_packet <= 1'b0;
   end
   else 
  begin
  // Detect SOP  
  if(cs_eread && data_tra_10bitin == {2'b10,Kchar_sop})// 0x3c = 0011 1100 SOP (if 8b10b)
      begin
        fifo_data_sop    <= 1'b1;
        fifo_data_eop    <= 1'b0;
        fifo_data_packet <= 1'b0;
        can_id_reg       <= 1'b0;
        spi_mon_reg      <= 1'b0;
        rst_id_reg          <= 1'b0;
        spi_power_on_reg    <= 1'b0;
        spi_power_off_reg   <= 1'b0;
        partial_reconfig_reg  <= 1'b0;
      end 
  // Detect DATA  
  else if(cs_eread && data_tra_10bitin != {2'b10,Kchar_sop}&& data_tra_10bitin != {2'b01,Kchar_eop} && data_tra_10bitin[9:8] == 2'b00)// data
      begin
        fifo_data_sop    <= 1'b0;
        fifo_data_eop    <= 1'b0;
        fifo_data_packet <= 1'b1;
        partial_reconfig_reg  <= 1'b0;
        if (addr_read ==5'h02)//detect the first Byte
          case(data_tra_10bitin[7:0])
            8'h10 : //Partial reconfig
            begin
              partial_reconfig_reg  <= 1'b1;
              spi_mon_reg   <= 1'b0;
              can_id_reg    <= 1'b0;
              spi_power_on_reg   <= 1'b0;
              spi_power_off_reg  <= 1'b0;
              rst_id_reg          <= 1'b0;
            end
            8'h20 : //Identify SPI mon Read
            begin
              can_id_reg    <= 1'b0;
              spi_power_on_reg    <= 1'b0;
              spi_power_off_reg   <= 1'b0;
              partial_reconfig_reg  <= 1'b0;
              rst_id_reg          <= 1'b0;
              if (dbg_spi) // Measurement Board 
                begin 
                  can_id_reg    <= 1'b1;
                  spi_mon_reg   <= 1'b0;
                end
              else // MOPSHUB Board 
                begin 
                  spi_mon_reg   <= 1'b1;
                  can_id_reg    <= 1'b0;
                end
            end
            8'h21 : //Identify SPI mon Init
            begin
              can_id_reg    <= 1'b0;
              spi_power_on_reg    <= 1'b0;
              spi_power_off_reg   <= 1'b0;
              partial_reconfig_reg  <= 1'b0;
              rst_id_reg          <= 1'b0;
              if (dbg_spi) // Measurement Board 
                begin 
                  can_id_reg    <= 1'b1;
                  spi_mon_reg   <= 1'b0;
                end
              else // MOPSHUB Board 
                begin 
                  spi_mon_reg   <= 1'b1;
                  can_id_reg    <= 1'b0;
                end
            end
            8'h30 : //Identify SPI powering off
            begin
              spi_mon_reg   <= 1'b0;
              can_id_reg    <= 1'b0;
              spi_power_on_reg   <= 1'b0;
              spi_power_off_reg <= 1'b1;
              partial_reconfig_reg  <= 1'b0;
              rst_id_reg          <= 1'b0;
            end
            8'h31 : //Identify SPI powering on
            begin
              spi_mon_reg   <= 1'b0;
              can_id_reg    <= 1'b0;
              spi_power_on_reg <= 1'b1;
              spi_power_off_reg   <= 1'b0;
              partial_reconfig_reg  <= 1'b0;
              rst_id_reg          <= 1'b0;
            end
            8'h40 : //Identify Reset Signal
            begin
              can_id_reg    <= 1'b1;
              rst_id_reg    <= 1'b1;
              spi_power_on_reg    <= 1'b0;
              spi_power_off_reg   <= 1'b0;
              partial_reconfig_reg  <= 1'b0;
              spi_mon_reg   <= 1'b0;
             end
                  
            
//            8'h00 :
//            begin  //Identify rest
//              can_id_reg    <= 1'b1;
//              spi_mon_reg   <= 1'b0;
//              spi_power_on_reg    <= 1'b0;
//              spi_power_off_reg   <= 1'b0;
//              partial_reconfig_reg  <= 1'b0;
//            end
            default:
            begin
              can_id_reg    <= 1'b1;
              rst_id_reg    <= 1'b0;
              spi_mon_reg   <= 1'b0;
              spi_power_on_reg     <= 1'b0;
              spi_power_off_reg    <= 1'b0;
              partial_reconfig_reg <= 1'b0;
              end
            endcase
        else
          begin
            can_id_reg    <= 1'b0;
            spi_mon_reg   <= 1'b0;
            rst_id_reg    <= 1'b0;
            spi_power_on_reg     <= 1'b0;
            spi_power_off_reg    <= 1'b0;
            partial_reconfig_reg <= 1'b0;
          end                    
      end 
  // Detect EOP  
  else if(cs_eread&&  data_tra_10bitin == {2'b01,Kchar_eop})// 0xdc = 1101 1100 EOP(if 8b10b)
      begin
       fifo_data_sop    <= 1'b0;
       fifo_data_eop    <= 1'b1;
       fifo_data_packet <= 1'b0; 
       can_id_reg       <= 1'b0;
       spi_mon_reg      <= 1'b0;
       spi_power_on_reg    <= 1'b0;
       spi_power_off_reg   <= 1'b0; 
       partial_reconfig_reg  <= 1'b0;      
      end
  
  else  
    begin
     partial_reconfig_reg  <= 1'b0;
     rst_id_reg    <= 1'b0;
     can_id_reg       <= 1'b0;
     spi_mon_reg      <= 1'b0;
     spi_power_on_reg    <= 1'b0;
     spi_power_off_reg   <= 1'b0;
     fifo_data_sop    <= 1'b0;
     fifo_data_eop    <= 1'b0;
     fifo_data_packet <= 1'b0;
    end    
  end

















// HDL Embedded Text Block 9 rdy
assign rx_data_rdy = !rx_fifo_empty;
assign tx_data_rdy = !tx_fifo_empty;





























































































































// HDL Embedded Text Block 11 id
// Wire_assign 1                     
initial    fifo_data_sop           = 1'b0;
initial    fifo_data_eop           = 1'b0;
initial    fifo_data_packet        = 1'b0;
initial    spi_power_on_reg        = 1'b0;
initial    spi_power_off_reg       = 1'b0;
initial    spi_mon_reg             = 1'b0;
initial    can_id_reg              = 1'b0;
initial    rst_id_reg              = 1'b0;
assign     time_limit         = 32'd1000000;   //corresponds to 25 msec if the FPGA freq is 40Mhz

































































































































endmodule // elink_core

