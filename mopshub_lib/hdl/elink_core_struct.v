//
// Module mopshub_lib.elink_core.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:20:20 04/06/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_core( 
   // Port Declarations
   input   wire            clk, 
   input   wire            rst, 
   output  wire            rx_fifo_full, 
   input   wire    [75:0]  data_rec_uplink, 
   input   wire            start_write_elink, 
   output  wire            tx_efifo_full, 
   output  wire            irq_elink_rec, 
   output  wire            irq_elink_tra, 
   output  wire            end_write_elink, 
   input   wire            start_read_elink, 
   output  wire            end_read_elink, 
   input   wire    [1:0]   data_2bit_in, 
   output  wire    [1:0]   data_2bit_out, 
   input   wire            fifo_flush, 
   output  wire            tx_data_rdy, 
   output  wire            rx_data_rdy, 
   output  wire    [75:0]  data_tra_out, 
   output  wire            buffer_tra_en, 
   output  wire    [75:0]  data_tra_mon_spi, 
   input   wire    [75:0]  data_rec_spi_in, 
   output  wire            end_write_elink_spi, 
   input   wire            start_write_elink_spi, 
   input   wire            timeoutrst,             // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   input   wire            abort, 
   input   wire    [9:0]   data_10bit_in_dbg, 
   input   wire            dbg_elink, 
   input   wire            rdy_dbg, 
   input   wire            dbg_spi, 
   output  wire            word10b_rdy, 
   input   wire            start_write_elink_dbg, 
   input   wire    [75:0]  data_rec_dbg_in, 
   output  wire            end_write_elink_dbg, 
   output  wire            irq_elink_eth, 
   output  wire    [75:0]  data_tra_power_spi, 
   output  wire            irq_spi_power_off, 
   output  wire            irq_spi_power_on, 
   output  wire            buffer_eth_en, 
   output  wire            irq_spi_mon_tra
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         timeoutrst_elink_tra;    // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
wire  [4:0]  addr_write;              // request to caninterface block
wire         cs_ewrite;
wire  [9:0]  data_rec_10bitout;
wire  [9:0]  data_rec_can_10bitout;
wire  [9:0]  data_rec_dbg_10bitout;
wire  [9:0]  data_rec_spi_10bitout;
wire         cs_eread;
reg          fifo_data_packet;
reg          fifo_data_sop;
reg          fifo_data_eop;
reg          spi_power_on_reg;
reg          spi_power_off_reg;
reg          spi_mon_reg;
reg          can_id_reg;
wire  [4:0]  addr_read;               // request to caninterface block
wire  [9:0]  data_tra_10bitin;
wire         buffer_elink_en;
wire  [6:0]  statedeb_rec;
wire  [6:0]  statedeb_tra;
wire         buffer_rec_en;
wire         rx_fifo_empty;
wire         tx_fifo_empty;
wire         can_id;
wire         spi_mon_id;
wire         buffer_mon_spi_en;
wire         buffer_spi_rec_en;
wire         spi_rec_mode;
wire         spi_power_on_id;
wire         spi_power_off_id;
wire         entimeout_elink_rec;     // enable for timeout reset counter 
wire         entimeout_elink_tra;     // enable for timeout reset counter 
reg   [31:0] time_limit_trim;         //corresponds to 25 msec if the FPGA freq is 40Mhz
reg   [7:0]  Kchar_comma;
reg   [7:0]  Kchar_eop;
reg   [7:0]  Kchar_sop;
reg   [9:0]  COMMAn;
reg   [9:0]  COMMAp;
wire         spi_tra_mode;
wire         dbg_rec_mode;
wire         can_rec_mode;
wire         buffer_power_spi_en;


// Instances 
buffer_rec_elink buffer_rec_elink_can( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_uplink), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_can_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_rec_elink buffer_rec_elink_dbg( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_dbg_in), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_dbg_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_rec_elink buffer_rec_elink_spi( 
   .clk               (clk), 
   .rst               (rst), 
   .data_rec_in       (data_rec_spi_in), 
   .addr              (addr_write), 
   .data_rec_10bitout (data_rec_spi_10bitout), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .Kchar_comma       (Kchar_comma)
); 

buffer_tra_elink tra_elink_buf0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_elink_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_out)
); 

buffer_tra_elink tra_elink_buf_spi_mon0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_mon_spi_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_mon_spi)
); 

buffer_tra_elink tra_elink_buf_spi_power0( 
   .clk             (clk), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_power_spi_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_power_spi)
); 

buffer_tristate_elink buffer_tristate_elink0( 
   .clk          (clk), 
   .rst          (rst), 
   .data_tra_in0 (data_rec_can_10bitout), 
   .data_tra_in1 (data_rec_dbg_10bitout), 
   .data_tra_in2 (data_rec_spi_10bitout), 
   .buffer_en0   (can_rec_mode), 
   .buffer_en1   (dbg_rec_mode), 
   .buffer_en2   (spi_rec_mode), 
   .Kchar_comma  (Kchar_comma), 
   .data_tra_out (data_rec_10bitout)
); 

elink_interface_rec_SM elink_interface_rec_SM0( 
   .abort                 (abort), 
   .clk                   (clk), 
   .rst                   (rst), 
   .start_write_elink     (start_write_elink), 
   .start_write_elink_dbg (start_write_elink_dbg), 
   .start_write_elink_spi (start_write_elink_spi), 
   .timeoutrst            (timeoutrst), 
   .addr_write            (addr_write), 
   .buffer_rec_en         (buffer_rec_en), 
   .buffer_spi_rec_en     (buffer_spi_rec_en), 
   .can_rec_mode          (can_rec_mode), 
   .cs_ewrite             (cs_ewrite), 
   .dbg_rec_mode          (dbg_rec_mode), 
   .end_write_elink       (end_write_elink), 
   .end_write_elink_dbg   (end_write_elink_dbg), 
   .end_write_elink_spi   (end_write_elink_spi), 
   .entimeout             (entimeout_elink_rec), 
   .irq_elink_rec         (irq_elink_rec), 
   .spi_rec_mode          (spi_rec_mode), 
   .statedeb              (statedeb_rec)
); 

elink_interface_tra_SM elink_interface_tra_SM0( 
   .abort               (abort), 
   .can_id              (can_id), 
   .clk                 (clk), 
   .fifo_data_eop       (fifo_data_eop), 
   .fifo_data_sop       (fifo_data_sop), 
   .fifo_elink_rdy      (rx_data_rdy), 
   .fifo_packet_rdy     (fifo_data_packet), 
   .rst                 (rst), 
   .spi_mon_id          (spi_mon_id), 
   .spi_power_off_id    (spi_power_off_id), 
   .spi_power_on_id     (spi_power_on_id), 
   .start_read_elink    (start_read_elink), 
   .timeoutrst          (timeoutrst_elink_tra), 
   .addr_read           (addr_read), 
   .buffer_elink_en     (buffer_elink_en), 
   .buffer_eth_en       (buffer_eth_en), 
   .buffer_mon_spi_en   (buffer_mon_spi_en), 
   .buffer_power_spi_en (buffer_power_spi_en), 
   .buffer_tra_en       (buffer_tra_en), 
   .cs_eread            (cs_eread), 
   .end_read_elink      (end_read_elink), 
   .entimeout           (entimeout_elink_tra), 
   .irq_elink_eth       (irq_elink_eth), 
   .irq_elink_tra       (irq_elink_tra), 
   .irq_spi_mon_tra     (irq_spi_mon_tra), 
   .irq_spi_power_off   (irq_spi_power_off), 
   .irq_spi_power_on    (irq_spi_power_on), 
   .spi_tra_mode        (spi_tra_mode), 
   .statedeb            (statedeb_tra)
); 

elink_to_fifo elink_to_fifo0( 
   .fifo_flush    (fifo_flush), 
   .fifo_full     (rx_fifo_full), 
   .fifo_dout     (data_tra_10bitin), 
   .clk           (clk), 
   .fifo_rd_en    (cs_eread), 
   .data_2bit_in  (data_2bit_in), 
   .rst           (rst), 
   .rx_fifo_empty (rx_fifo_empty), 
   .COMMAn        (COMMAn), 
   .COMMAp        (COMMAp), 
   .Kchar_comma   (Kchar_comma), 
   .Kchar_eop     (Kchar_eop), 
   .Kchar_sop     (Kchar_sop), 
   .word10b_rdy   (word10b_rdy)
); 

fifo_to_elink fifo_to_elink0( 
   .fifo_wr_en        (cs_ewrite), 
   .clk               (clk), 
   .fifo_din          (data_rec_10bitout), 
   .fifo_flush        (fifo_flush), 
   .data_2bit_out     (data_2bit_out), 
   .efifo_empty       (tx_fifo_empty), 
   .efifo_full        (tx_efifo_full), 
   .rst               (rst), 
   .Kchar_comma       (Kchar_comma), 
   .Kchar_sop         (Kchar_sop), 
   .Kchar_eop         (Kchar_eop), 
   .data_10bit_in_dbg (data_10bit_in_dbg), 
   .COMMAn            (COMMAn), 
   .COMMAp            (COMMAp), 
   .rdy_dbg           (rdy_dbg), 
   .dbg_elink         (dbg_elink)
); 

timout_rst timout_rst1( 
   .clk        (clk), 
   .entimeout  (entimeout_elink_tra), 
   .time_limit (time_limit_trim), 
   .rst        (rst), 
   .timeoutrst (timeoutrst_elink_tra)
); 

// HDL Embedded Text Block 6 FIFO_read1
//Check FIFO output
assign can_id      = can_id_reg;
assign spi_mon_id  = spi_mon_reg;
assign spi_power_on_id    = spi_power_on_reg;
assign spi_power_off_id   = spi_power_off_reg;
always@(*) 
  begin
  // Detect SOP  
  if(cs_eread && data_tra_10bitin == {2'b10,Kchar_sop})// 0x3c = 0011 1100 SOP (if 8b10b)
      begin
        fifo_data_sop    = 1'b1;
        fifo_data_eop    = 1'b0;
        fifo_data_packet = 1'b0;
        can_id_reg       = 1'b0;
        spi_mon_reg      = 1'b0;
        spi_power_on_reg    = 1'b0;
        spi_power_off_reg   = 1'b0;
      end 
  // Detect DATA  
  else if(cs_eread && data_tra_10bitin != {2'b10,Kchar_sop}&& data_tra_10bitin != {2'b01,Kchar_eop} && data_tra_10bitin[9:8] == 2'b00)// data
      begin
        fifo_data_sop    = 1'b0;
        fifo_data_eop    = 1'b0;
        fifo_data_packet = 1'b1;
        if (addr_read ==5'h02)//detect the first Byte
          case(data_tra_10bitin[7:0])
            8'h20 : //Identify SPI mon
            begin
              can_id_reg    = 1'b0;
              spi_power_on_reg    = 1'b0;
              spi_power_off_reg   = 1'b0;
              if (dbg_spi) // Measurement Board 
                begin 
                  can_id_reg    = 1'b1;
                  spi_mon_reg   = 1'b0;
                end
              else // MOPSHUB Board 
                begin 
                  spi_mon_reg   = 1'b1;
                  can_id_reg    = 1'b0;
                end
            end
            8'h90 : //Identify SPI powering off
            begin
              spi_mon_reg   = 1'b0;
              can_id_reg    = 1'b0;
              spi_power_on_reg   = 1'b0;
              spi_power_off_reg = 1'b1;
            end
            8'h91 : //Identify SPI powering on
            begin
              spi_mon_reg   = 1'b0;
              can_id_reg    = 1'b0;
              spi_power_on_reg = 1'b1;
              spi_power_off_reg   = 1'b0;
            end
//            8'h00 :
//            begin  //Identify CAN not needed now 
//              can_id_reg     = 1'b1;
//              spi_mon_reg    = 1'b0;
//              spi_power_on_reg  = 1'b1;
//              spi_power_off_reg = 1'b0;
//            end
            default:
            begin
              can_id_reg    = 1'b1;
              spi_mon_reg   = 1'b0;
              spi_power_on_reg    = 1'b0;
              spi_power_off_reg   = 1'b0;
              end
            endcase
        else
          begin
            can_id_reg    = 1'b0;
            spi_mon_reg   = 1'b0;
            spi_power_on_reg    = 1'b0;
            spi_power_off_reg   = 1'b0;
          end                    
      end 
  // Detect EOP  
  else if(cs_eread&&  data_tra_10bitin == {2'b01,Kchar_eop})// 0xdc = 1101 1100 EOP(if 8b10b)
      begin
       fifo_data_sop    = 1'b0;
       fifo_data_eop    = 1'b1;
       fifo_data_packet = 1'b0; 
       can_id_reg       = 1'b0;
       spi_mon_reg      = 1'b0;
       spi_power_on_reg    = 1'b0;
       spi_power_off_reg   = 1'b0;       
      end
  
  else  
    begin
     can_id_reg       = 1'b0;
     spi_mon_reg      = 1'b0;
     spi_power_on_reg    = 1'b0;
     spi_power_off_reg   = 1'b0;
     fifo_data_sop    = 1'b0;
     fifo_data_eop    = 1'b0;
     fifo_data_packet = 1'b0;
    end    
  end














































































































































































































// HDL Embedded Text Block 9 rdy
assign rx_data_rdy = !rx_fifo_empty;
assign tx_data_rdy = !tx_fifo_empty;





























































































































// HDL Embedded Text Block 11 K_Code
// Wire_assign 1                     
initial    fifo_data_sop           = 1'b0;
initial    fifo_data_eop           = 1'b0;
initial    fifo_data_packet        = 1'b0;
initial    spi_power_on_reg        = 1'b0;
initial    spi_power_off_reg       = 1'b0;
initial    spi_mon_reg             = 1'b0;
initial    can_id_reg              = 1'b0;
initial    time_limit_trim         = 32'd1000000;   //corresponds to 25 msec if the FPGA freq is 40Mhz


initial Kchar_comma = 8'b10111100;//K28.5  BC
initial Kchar_eop = 8'b11011100;// K28.6 DC
initial Kchar_sop = 8'b00111100;// K28.1 3C
initial COMMAn = 10'b1100000101;
initial COMMAp = 10'b0011111010;





























































































































endmodule // elink_core

