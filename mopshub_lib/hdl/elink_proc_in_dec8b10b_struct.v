//
// Module mopshub_lib.elink_proc_in_dec8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 16:01:34 02/04/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_proc_in_dec8b10b( 
   // Port Declarations
   input   wire    [1:0]  DATA_IN, 
   input   wire           clk, 
   input   wire           rst, 
   output  wire           word10b_rdy, 
   output  wire           dec8b_rdy, 
   input   wire    [9:0]  COMMAn, 
   input   wire    [9:0]  COMMAp, 
   input   wire    [7:0]  Kchar_comma, 
   input   wire    [7:0]  Kchar_eop, 
   input   wire    [7:0]  Kchar_sop, 
   output  wire    [7:0]  dec8b_data_in, 
   output  wire           disp_err, 
   output  wire           code_err, 
   output  wire    [1:0]  ISK
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [11:0] bitstream_in;
wire  [9:0]  word10b;
wire         ISK_char;
wire         dataout_valid;
wire         ISK_sob;
wire  [7:0]  decoder_out;
wire         ISK_soc;
reg          flag_pack;
reg   [9:0]  EOCn;               //+K.28.6
reg          dec8b_rdy_r;
reg   [1:0]  ISK_r;
reg   [9:0]  SOCn;               //+K.28.1 Ã˜Â¹Ã˜Â¨Ã˜Â¯Ã˜Â§Ã™Â„Ã™Â„Ã™Â‡ ÃsÃ˜Â˜Â§Ã™Â„Ã™Â‡Ã˜Â¯Ã™Â„Ã™Â‚
wire  [1:0]  ISKcode;
reg   [9:0]  SOCp;               //-K.28.1
reg          dataout_valid_r;
wire         valid_char_eop;
reg          busy_r;
wire         ISK_comma;
reg   [9:0]  EOBn;               //+K.28.3 
wire         valid_char_sop;
wire         ISK_eoc;
reg   [9:0]  EOCp;               //-K.28.6 end-of-chunk characters
reg   [1:0]  ISKcode_r;
reg   [9:0]  EOBp;               //-K.28.3 
reg   [9:0]  SOBn;               //+K.28.2
reg   [7:0]  dec8b_data_r;
wire         ISK_eob;
wire         valid_char_comma;
reg   [9:0]  SOBp;               //-K.28.2 //start-of-busy and end-of-busy characters


// Instances 
bitstream_shift_register bitstream_deserializer00( 
   .din  (DATA_IN), 
   .clk  (clk), 
   .rst  (rst), 
   .dout (bitstream_in)
); 

dec_8b10b_mopshub dec_8b10b_mopshub0( 
   .rst          (rst), 
   .clk          (clk), 
   .datain       (word10b), 
   .datain_valid (word10b_rdy), 
   .Kchar_comma  (Kchar_comma), 
   .ko           (ISK_char), 
   .dataout      (decoder_out), 
   .code_err     (code_err), 
   .disp_err     (disp_err)
); 

sync_detector sync_detector0( 
   .bitstream_in (bitstream_in), 
   .clk          (clk), 
   .rst          (rst), 
   .word10b      (word10b), 
   .word10b_rdy  (word10b_rdy), 
   .COMMAp       (COMMAp), 
   .COMMAn       (COMMAn)
); 

// HDL Embedded Text Block 3 ISKcode_asign1
// ISKcode_asign 2  
initial busy_r = 1'b0;                                      
assign ISK_comma   = (word10b == COMMAp |  word10b == COMMAn )  ? 1: 0;
assign ISK_soc     = (word10b == SOCp   |  word10b == SOCn   )  ? 1: 0;
assign ISK_eoc     = (word10b == EOCp   |  word10b == EOCn   )  ? 1: 0;
assign ISK_sob     = (word10b == SOBp   |  word10b == SOBn   )  ? 1: 0;
assign ISK_eob     = (word10b == EOBp   |  word10b == EOBn   )  ? 1: 0;
assign ISKcode[0]  = ((! ISK_soc) & (ISK_eoc ^ ISK_comma)) | ISK_sob | ISK_eob;
assign ISKcode[1]  = ((! ISK_eoc) & (ISK_soc ^ ISK_comma)) | ISK_sob | ISK_eob;

always@(posedge clk)
if (!rst)
begin
  busy_r <= 0;
  ISKcode_r <=2'b0;
end
else
begin
  ISKcode_r <=ISKcode;
  if (ISK_eob ==1)//end of busy detected 
  busy_r <= 0; 
  else if (ISK_sob ==1)//start of busy detected 
  busy_r <= 1;
end                                        





























// HDL Embedded Text Block 4 isk_signal1
// isk_signal 3 
always@(posedge clk)
if (!rst) ISK_r <= 2'b00;
else
  begin
    if (ISK_char == 1) ISK_r <= ISKcode_r; //edges of the data frame
    else ISK_r <= 2'b00;
  end                                        










// HDL Embedded Text Block 5 rdy_signal1
// isk_signal 3 
always@(posedge clk)
if (!rst) dataout_valid_r <= 1'b0;
else
  begin 
    if (word10b_rdy) dataout_valid_r <= 1'b1;//edges of the data frame
    else dataout_valid_r <= 1'b0;
  end                                        




























// HDL Embedded Text Block 6 Wire_assign2
// Wire_assign 1                     
initial dataout_valid_r   = 0;
initial dec8b_data_r      = 0;
initial dec8b_rdy_r       = 0;
initial flag_pack         = 0;
initial ISK_r             = 0;
initial ISKcode_r         = 2'b0;
initial EOBn              = 10'h30C;   //+K.28.3 //1100001100
initial EOBp              = 10'hF3;   //-K.28.3 //0011110011
initial EOCn              = 10'h309;   //+K.28.6 //1100001001
initial EOCp              = 10'hF6;   //-K.28.6 //0011110110 end-of-chunk characters
initial SOBn              = 10'h30A;   //+K.28.2 //1100001010
initial SOBp              = 10'hF5;   //-K.28.2 //0011110101 start-of-busy and end-of-busy characters
initial SOCn              = 10'h306;   //+K.28.1 //1100000110 Ã˜Â¹Ã˜Â¨Ã˜Â¯Ã˜Â§Ã™Â„Ã™Â„Ã™Â‡ ÃsÃ˜Â˜Â§Ã™Â„Ã™Â‡Ã˜Â¯Ã™Â„Ã™Â‚
initial SOCp              = 10'hF9;   //-K.28.1  //0011111001
                     










// HDL Embedded Text Block 7 test_before_Write2
//what to write into the FIFO?
assign ISK = ISK_r;  
assign dataout_valid = dataout_valid_r;  
assign dec8b_data_in = dec8b_data_r;
assign dec8b_rdy = dec8b_rdy_r;                                
assign valid_char_comma = (ISK_char == 1 & decoder_out == Kchar_comma) ? 1:0;
assign valid_char_sop   = (ISK_char == 1 & decoder_out == Kchar_sop  ) ? 1:0; //3c = 0011 1100 SOP (if 8b10b)
assign valid_char_eop   = (ISK_char == 1 & decoder_out == Kchar_eop  ) ? 1:0; //dc = 1101 1100 (if 8b10b)

always@(posedge clk)
if (!rst)
begin
  dec8b_rdy_r    <= 1'b0;
  flag_pack      <= 1'b0;
  dec8b_data_r   <= 0;
end
else 
begin
  dec8b_data_r <= decoder_out;
  if(dec8b_rdy_r == 1)//always make sure you write only once
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end
  else if(flag_pack == 1 && dataout_valid  == 1 && valid_char_comma)// ignore commas
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end
  else if(flag_pack == 0 && dataout_valid  == 1 && valid_char_sop)// 03c = 0011 1100 SOP (if 8b10b)
  begin
    dec8b_rdy_r   <= 1'b1;
    flag_pack     <= 1'b1; //SOP detected. raise the flag, write everything
  end   
  else if(flag_pack == 1 && dataout_valid  == 1 && !valid_char_eop)// not EOP means it is data //flag_pack == 1 && 
  begin
    dec8b_rdy_r   <= 1'b1;
    flag_pack     <= 1'b1;
  end   
  else if(flag_pack == 1 && dataout_valid  == 1 && valid_char_eop)// 0dc = 1101 1100 (if 8b10b)
  begin
    dec8b_rdy_r    <= 1'b1;
    flag_pack      <= 1'b0; //EOP detected. drop the flag
  end 
  else
  begin
    dec8b_rdy_r   <= 1'b0;
    flag_pack     <= flag_pack;
  end 
end



















































































endmodule // elink_proc_in_dec8b10b

