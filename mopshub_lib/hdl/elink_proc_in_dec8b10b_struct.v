//
// Module mopshub_lib.elink_proc_in_dec8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 20:49:38 08/16/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_proc_in_dec8b10b #(
   // synopsys template
   parameter GENERATE_FEI4B = 0
)
( 
   // Port Declarations
   input   wire    [1:0]  DATA_IN, 
   input   wire           bitCLK, 
   input   wire           bitCLKx4, 
   input   wire           reset, 
   input   wire           swap_tx_bits, 
   input   wire           reverse_stream_10b, 
   output  wire           data_rdy, 
   output  wire    [7:0]  HGFEDCBA, 
   output  wire    [1:0]  ISK
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         BUSY;
reg          align_select         = 0;
reg   [4:0]  alignment_sreg       = 5'b0;
// Port Declarations
wire  [9:0]  bitstream_align0;               //2 words of 10bit
wire  [9:0]  bitstream_align1;
wire  [11:0] bitstream_in;
wire         code_err;
wire  [1:0]  comma_valid_bits;
wire         comma_valid_bits_or;
wire         disp_err;
reg   [9:0]  word10b              = 10'b0;
reg          request_cycle_cnt    = 3'b0;


// Instances 
bitstream_deserializer bitstream_deserializer0( 
   .DATA_IN      (DATA_IN), 
   .bitCLK       (bitCLK), 
   .reset        (reset), 
   .swap_tx_bits (swap_tx_bits), 
   .dout         (bitstream_in)
); 

dec_8b10b_wrap #(0) dec_8b10b_wrap0( 
   .ABCDEIFGHJ_IN (word10b), 
   .RBYTECLK      (bitCLKx4), 
   .datain_valid  (data_rdy), 
   .reset         (reset), 
   .BUSY          (BUSY), 
   .HGFEDCBA      (HGFEDCBA), 
   .ISK           (ISK), 
   .code_err      (code_err), 
   .disp_err      (disp_err)
); 

sync_detector #(GENERATE_FEI4B) sync_detector0( 
   .bitstream_align0   (bitstream_align0), 
   .comma_valid_bits   (comma_valid_bits), 
   .bitstream_in       (bitstream_in), 
   .bitCLK             (bitCLK), 
   .reverse_stream_10b (reverse_stream_10b), 
   .reset              (reset), 
   .bitstream_align1   (bitstream_align1)
); 

// HDL Embedded Text Block 7 align_select
// eb1 1
//check if there are valid bits
assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);
assign data_rdy  = alignment_sreg[4]; 



always@(posedge bitCLK)
if (reset)
begin
  align_select <=0;
  alignment_sreg <=5'b0; //alignment selector state
end
else 
begin
  if(comma_valid_bits_or ==1) 
  begin
    align_select <= (!comma_valid_bits[0]) & comma_valid_bits[1];
    alignment_sreg <= 5'b10000; 
  end 
  else
  begin
    alignment_sreg <= {alignment_sreg[0],alignment_sreg[4:1]};
  end 
end














// HDL Embedded Text Block 8 alignment_word10b
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------

always@(posedge bitCLK)
if (reset)
  begin
    word10b <=10'b0;
  end
else
    case (align_select)
        1'b0 :begin //when bit0 word got comma => align to bitstream_align_array0
          word10b <= bitstream_align0;
          end
        1'b1 :begin //when bit1 word got comma => align to bitstream_align_array1
          word10b <= bitstream_align1;
          end     
    endcase

























endmodule // elink_proc_in_dec8b10b

