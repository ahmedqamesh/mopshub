//
// Module mopshub_lib.elink_interface_tra_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 15:23:49 10/09/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_interface_tra_sm( 
   // Port Declarations
   input   wire           abort,                  // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,                    // posedge
   input   wire           endwait, 
   input   wire           rst,                    // synchronous low active
   input   wire           sign_on_signal, 
   input   wire           start_write_elink,      // request from bridge FSM
   input   wire           start_write_elink_dbg, 
   input   wire           start_write_elink_spi, 
   input   wire           timeoutrst,             // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   input   wire           tx_efifo_full, 
   output  reg     [4:0]  addr_write,             // request to caninterface block
   output  reg            buffer_rec_en, 
   output  reg            buffer_spi_rec_en, 
   output  reg            can_rec_mode, 
   output  reg            cs_ewrite, 
   output  reg            dbg_rec_mode, 
   output  reg            end_write_elink,        // request to bridge FSM
   output  reg            end_write_elink_dbg, 
   output  reg            end_write_elink_spi, 
   output  reg            entimeout,              // enable for timeout reset counter 
   output  reg            irq_elink_rec, 
   output  reg            rst_mopshub_mode, 
   output  reg            spi_rec_mode, 
   output  reg            start_read_eth_fifo, 
   output  reg     [7:0]  statedeb
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Declare any pre-registered internal signals
reg [4:0] addr_write_cld;

// Module Declarations

// State encoding
parameter 
          ST_waittoact        = 6'd0,
          ST_reset            = 6'd1,
          store_WB0           = 6'd2,
          ST_wait_can_rq      = 6'd3,
          store_SOP           = 6'd4,
          store_Eop           = 6'd5,
          WB0                 = 6'd6,
          W_SOP               = 6'd7,
          W_Eop               = 6'd8,
          store_SPI0          = 6'd9,
          ST_wait_can_rq_SPI  = 6'd10,
          store_SOP_SPI       = 6'd11,
          store_Eop_spi       = 6'd12,
          w_SPI0              = 6'd13,
          W_SOP_SPI           = 6'd14,
          W_Eop_spi           = 6'd15,
          ST_end_write_en_DBG = 6'd16,
          store_WB0_DBG       = 6'd17,
          ST_wait_can_rq_DBG  = 6'd18,
          st_write_data_DBG   = 6'd19,
          store_SOP_DBG       = 6'd20,
          Store_Eop_DBG       = 6'd21,
          WB0_DBG             = 6'd22,
          W_SOP_DBG           = 6'd23,
          W_Eop_DBG           = 6'd24,
          Store_Comma_DBG     = 6'd25,
          store_WB0_rst       = 6'd26,
          store_SOP_rst       = 6'd27,
          store_Eop_rst       = 6'd28,
          WB0_rst             = 6'd29,
          W_SOP_rst           = 6'd30,
          W_Eop_rst           = 6'd31,
          ST_endwait          = 6'd32,
          W_Comma_DBG         = 6'd33,
          end_Write_rst1      = 6'd34,
          end_Write_rst       = 6'd35,
          end_Write_rst2      = 6'd36,
          ST_wait_rq_rst      = 6'd37,
          store_Comma_rst1    = 6'd38,
          W_Comma_rst2        = 6'd39,
          store_Comma_rst2    = 6'd40,
          W_Comma_rst3        = 6'd41,
          W_Comma_rst1        = 6'd42,
          store_Comma_rst     = 6'd43,
          store_Comma_rst4    = 6'd44,
          W_Comma_rst5        = 6'd45,
          store_Comma_rst3    = 6'd46,
          W_Comma_rst4        = 6'd47,
          store_Comma_rst5    = 6'd48,
          W_Comma_rst6        = 6'd49;

reg [5:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   addr_write_cld, 
   current_state, 
   rst, 
   sign_on_signal, 
   start_write_elink, 
   start_write_elink_dbg, 
   start_write_elink_spi, 
   tx_efifo_full
)
begin : next_state_block_proc
   case (current_state) 
      ST_waittoact: begin
         if (start_write_elink == 1)
            next_state = W_SOP;
         else if (start_write_elink_spi ==1)
            next_state = W_SOP_SPI;
         else if (start_write_elink_dbg == 1)
            next_state = st_write_data_DBG;
         else if (sign_on_signal == 1)
            next_state = W_SOP_rst;
         else
            next_state = ST_waittoact;
      end
      ST_reset: begin
         if (rst == 1)
            next_state = ST_waittoact;
         else
            next_state = ST_reset;
      end
      store_WB0: begin
         if (addr_write_cld == 5'hC)
            next_state = W_Eop;
         else
            next_state = WB0;
      end
      ST_wait_can_rq: begin
         next_state = end_Write_rst1;
      end
      store_SOP: begin
         next_state = WB0;
      end
      store_Eop: begin
         next_state = W_Comma_rst2;
      end
      WB0: begin
         if (!tx_efifo_full)
            next_state = store_WB0;
         else
            next_state = WB0;
      end
      W_SOP: begin
         if (!tx_efifo_full)
            next_state = store_SOP;
         else
            next_state = W_SOP;
      end
      W_Eop: begin
         if (!tx_efifo_full)
            next_state = store_Eop;
         else
            next_state = W_Eop;
      end
      store_SPI0: begin
         if (addr_write_cld == 5'hC)
            next_state = W_Eop_spi;
         else
            next_state = w_SPI0;
      end
      ST_wait_can_rq_SPI: begin
         next_state = end_Write_rst2;
      end
      store_SOP_SPI: begin
         next_state = w_SPI0;
      end
      store_Eop_spi: begin
         next_state = W_Comma_rst3;
      end
      w_SPI0: begin
         if (!tx_efifo_full)
            next_state = store_SPI0;
         else
            next_state = w_SPI0;
      end
      W_SOP_SPI: begin
         if (!tx_efifo_full)
            next_state = store_SOP_SPI;
         else
            next_state = W_SOP_SPI;
      end
      W_Eop_spi: begin
         if (!tx_efifo_full)
            next_state = store_Eop_spi;
         else
            next_state = W_Eop_spi;
      end
      ST_end_write_en_DBG: begin
         next_state = ST_waittoact;
      end
      store_WB0_DBG: begin
         if (addr_write_cld == 5'hC)
            next_state = W_Eop_DBG;
         else
            next_state = WB0_DBG;
      end
      ST_wait_can_rq_DBG: begin
         if (!tx_efifo_full)
            next_state = ST_end_write_en_DBG;
         else
            next_state = ST_wait_can_rq_DBG;
      end
      st_write_data_DBG: begin
         next_state = W_SOP_DBG;
      end
      store_SOP_DBG: begin
         next_state = WB0_DBG;
      end
      Store_Eop_DBG: begin
         next_state = W_Comma_DBG;
      end
      WB0_DBG: begin
         if (!tx_efifo_full)
            next_state = store_WB0_DBG;
         else
            next_state = WB0_DBG;
      end
      W_SOP_DBG: begin
         if (!tx_efifo_full)
            next_state = store_SOP_DBG;
         else
            next_state = W_SOP_DBG;
      end
      W_Eop_DBG: begin
         if (!tx_efifo_full)
            next_state = Store_Eop_DBG;
         else
            next_state = W_Eop_DBG;
      end
      Store_Comma_DBG: begin
         if (!tx_efifo_full)
            next_state = ST_wait_can_rq_DBG;
         else
            next_state = Store_Comma_DBG;
      end
      store_WB0_rst: begin
         if (addr_write_cld == 5'hC)
            next_state = W_Eop_rst;
         else
            next_state = WB0_rst;
      end
      store_SOP_rst: begin
         next_state = WB0_rst;
      end
      store_Eop_rst: begin
         next_state = W_Comma_rst1;
      end
      WB0_rst: begin
         if (!tx_efifo_full)
            next_state = store_WB0_rst;
         else
            next_state = WB0_rst;
      end
      W_SOP_rst: begin
         if (!tx_efifo_full)
            next_state = store_SOP_rst;
         else
            next_state = W_SOP_rst;
      end
      W_Eop_rst: begin
         if (!tx_efifo_full)
            next_state = store_Eop_rst;
         else
            next_state = W_Eop_rst;
      end
      ST_endwait: begin
         next_state = ST_waittoact;
      end
      W_Comma_DBG: begin
         if (!tx_efifo_full)
            next_state = Store_Comma_DBG;
         else
            next_state = W_Comma_DBG;
      end
      end_Write_rst1: begin
         next_state = ST_waittoact;
      end
      end_Write_rst: begin
         next_state = ST_waittoact;
      end
      end_Write_rst2: begin
         next_state = ST_waittoact;
      end
      ST_wait_rq_rst: begin
         next_state = end_Write_rst;
      end
      store_Comma_rst1: begin
         next_state = W_Comma_rst5;
      end
      W_Comma_rst2: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst1;
         else
            next_state = W_Comma_rst2;
      end
      store_Comma_rst2: begin
         next_state = W_Comma_rst6;
      end
      W_Comma_rst3: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst2;
         else
            next_state = W_Comma_rst3;
      end
      W_Comma_rst1: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst;
         else
            next_state = W_Comma_rst1;
      end
      store_Comma_rst: begin
         next_state = W_Comma_rst4;
      end
      store_Comma_rst4: begin
         next_state = ST_wait_can_rq;
      end
      W_Comma_rst5: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst4;
         else
            next_state = W_Comma_rst5;
      end
      store_Comma_rst3: begin
         next_state = ST_wait_rq_rst;
      end
      W_Comma_rst4: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst3;
         else
            next_state = W_Comma_rst4;
      end
      store_Comma_rst5: begin
         next_state = ST_wait_can_rq_SPI;
      end
      W_Comma_rst6: begin
         if (!tx_efifo_full)
            next_state = store_Comma_rst5;
         else
            next_state = W_Comma_rst6;
      end
      default: 
         next_state = ST_reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   buffer_rec_en = 0;
   buffer_spi_rec_en = 0;
   can_rec_mode = 0;
   cs_ewrite = 0;
   dbg_rec_mode = 0;
   end_write_elink = 0;
   end_write_elink_dbg = 0;
   end_write_elink_spi = 0;
   entimeout = 1;
   irq_elink_rec = 0;
   rst_mopshub_mode = 0;
   spi_rec_mode = 0;
   start_read_eth_fifo = 0;

   // Combined Actions
   case (current_state) 
      ST_waittoact: begin
         entimeout = 0 ;
      end
      ST_reset: begin
         entimeout = 0 ;
      end
      store_WB0: begin
         cs_ewrite = 1 ;
         buffer_rec_en =1;
         can_rec_mode=1;
      end
      ST_wait_can_rq: begin
         irq_elink_rec =1;
         can_rec_mode=1;
      end
      store_SOP: begin
         cs_ewrite =1;
         can_rec_mode=1;
      end
      store_Eop: begin
         cs_ewrite =1;
         can_rec_mode=1;
      end
      WB0: begin
         can_rec_mode=1;
      end
      W_SOP: begin
         can_rec_mode=1;
      end
      W_Eop: begin
         can_rec_mode=1;
      end
      store_SPI0: begin
         cs_ewrite = 1 ;
         buffer_spi_rec_en  =1;
         spi_rec_mode =1;
      end
      ST_wait_can_rq_SPI: begin
         irq_elink_rec =1;
         spi_rec_mode =1;
      end
      store_SOP_SPI: begin
         cs_ewrite =1;
         spi_rec_mode =1;
      end
      store_Eop_spi: begin
         cs_ewrite =1;
         spi_rec_mode =1;
      end
      w_SPI0: begin
         spi_rec_mode =1;
      end
      W_SOP_SPI: begin
         spi_rec_mode =1;
      end
      W_Eop_spi: begin
         spi_rec_mode =1;
      end
      ST_end_write_en_DBG: begin
         end_write_elink_dbg =1;
         dbg_rec_mode = 1'b1;
      end
      store_WB0_DBG: begin
         cs_ewrite = 1 ;
         buffer_rec_en =1;
         dbg_rec_mode = 1'b1;
      end
      ST_wait_can_rq_DBG: begin
         irq_elink_rec =1;
         dbg_rec_mode = 1'b1;
      end
      st_write_data_DBG: begin
         dbg_rec_mode = 1'b1;
         start_read_eth_fifo =1'b1;
      end
      store_SOP_DBG: begin
         cs_ewrite =1;
         dbg_rec_mode = 1'b1;
      end
      Store_Eop_DBG: begin
         cs_ewrite =1;
         buffer_rec_en =1;
         dbg_rec_mode = 1'b1;
      end
      WB0_DBG: begin
         dbg_rec_mode = 1'b1;
      end
      W_SOP_DBG: begin
         dbg_rec_mode = 1'b1;
      end
      W_Eop_DBG: begin
         dbg_rec_mode = 1'b1;
      end
      Store_Comma_DBG: begin
         cs_ewrite =1;
         buffer_rec_en =1;
         dbg_rec_mode = 1'b1;
      end
      store_WB0_rst: begin
         cs_ewrite = 1 ;
         buffer_rec_en =1;
         rst_mopshub_mode=1;
      end
      store_SOP_rst: begin
         cs_ewrite =1;
         rst_mopshub_mode=1;
      end
      store_Eop_rst: begin
         cs_ewrite =1;
         rst_mopshub_mode=1;
      end
      WB0_rst: begin
         rst_mopshub_mode=1;
      end
      W_SOP_rst: begin
         rst_mopshub_mode=1;
      end
      W_Eop_rst: begin
         rst_mopshub_mode=1;
      end
      W_Comma_DBG: begin
         dbg_rec_mode = 1'b1;
      end
      end_Write_rst1: begin
         can_rec_mode=1;
         end_write_elink =1;
      end
      end_Write_rst: begin
         rst_mopshub_mode=1;
         end_write_elink =1;
      end
      end_Write_rst2: begin
         end_write_elink_spi =1;
         spi_rec_mode =1;
      end
      ST_wait_rq_rst: begin
         irq_elink_rec =1;
         rst_mopshub_mode=1;
      end
      store_Comma_rst1: begin
         cs_ewrite = 1 ;
         can_rec_mode=1;
      end
      W_Comma_rst2: begin
         can_rec_mode=1;
      end
      store_Comma_rst2: begin
         cs_ewrite = 1 ;
         spi_rec_mode =1;
      end
      W_Comma_rst3: begin
         spi_rec_mode =1;
      end
      W_Comma_rst1: begin
         rst_mopshub_mode=1;
      end
      store_Comma_rst: begin
         cs_ewrite = 1 ;
         rst_mopshub_mode=1;
      end
      store_Comma_rst4: begin
         cs_ewrite = 1 ;
         can_rec_mode=1;
      end
      W_Comma_rst5: begin
         can_rec_mode=1;
      end
      store_Comma_rst3: begin
         cs_ewrite = 1 ;
         rst_mopshub_mode=1;
      end
      W_Comma_rst4: begin
         rst_mopshub_mode=1;
      end
      store_Comma_rst5: begin
         cs_ewrite = 1 ;
         spi_rec_mode =1;
      end
      W_Comma_rst6: begin
         spi_rec_mode =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_reset;
   end
   else if (timeoutrst) begin
      current_state <= ST_reset;
   end
   else if (abort) begin
      current_state <= ST_endwait;
   end
   else if (endwait) begin
      current_state <= ST_reset;
   end
   else 
   begin
      current_state <= next_state;

      // Combined Actions
      case (current_state) 
         ST_reset: begin
            addr_write_cld <=1'b0;
         end
         store_WB0: begin
            addr_write_cld <= addr_write_cld;
         end
         store_SOP: begin
            addr_write_cld = 5'h1 ;
         end
         store_Eop: begin
            addr_write_cld = 5'hC;
         end
         WB0: begin
            addr_write_cld <= addr_write_cld+1;
         end
         W_SOP: begin
            addr_write_cld = 5'h1 ;
         end
         W_Eop: begin
            addr_write_cld = 5'hC;
         end
         store_SPI0: begin
            //addr_write_cld = 5'h2;
            addr_write_cld <= addr_write_cld ;
         end
         store_SOP_SPI: begin
            addr_write_cld = 5'h1  ;
         end
         store_Eop_spi: begin
            addr_write_cld = 5'hC;
         end
         w_SPI0: begin
            addr_write_cld <= addr_write_cld +1;
         end
         W_SOP_SPI: begin
            addr_write_cld = 5'h1 ;
         end
         W_Eop_spi: begin
            addr_write_cld = 5'hC;
         end
         store_WB0_DBG: begin
            addr_write_cld <= addr_write_cld ;
         end
         ST_wait_can_rq_DBG: begin
            addr_write_cld = 5'b0;
         end
         store_SOP_DBG: begin
            addr_write_cld = 5'h1 ;
         end
         Store_Eop_DBG: begin
            addr_write_cld = 5'hC;
         end
         WB0_DBG: begin
            addr_write_cld <= addr_write_cld +1;
         end
         W_SOP_DBG: begin
            addr_write_cld = 5'h1 ;
         end
         W_Eop_DBG: begin
            addr_write_cld = 5'hC;
         end
         Store_Comma_DBG: begin
            addr_write_cld = 5'h0;
         end
         store_WB0_rst: begin
            addr_write_cld <=addr_write_cld ;
         end
         store_SOP_rst: begin
            addr_write_cld = 5'h1 ;
         end
         store_Eop_rst: begin
            addr_write_cld = 5'hC;
         end
         WB0_rst: begin
            addr_write_cld = addr_write_cld +1;
         end
         W_SOP_rst: begin
            addr_write_cld = 5'h1 ;
         end
         W_Eop_rst: begin
            addr_write_cld = 5'hC;
         end
         W_Comma_DBG: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst1: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst2: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst2: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst3: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst1: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst4: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst5: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst3: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst4: begin
            addr_write_cld = 5'h0;
         end
         store_Comma_rst5: begin
            addr_write_cld = 5'h0;
         end
         W_Comma_rst6: begin
            addr_write_cld = 5'h0;
         end
      endcase
   end
end // Clocked Block

// State-As-Output assignment
always @(current_state)
begin
   statedeb = 8'b0;
   statedeb[5:0] = current_state;
end

// Concurrent Statements
// Clocked output assignments
always @(
   addr_write_cld
)
begin : clocked_output_proc
   addr_write = addr_write_cld;
end
endmodule // elink_interface_tra_sm
