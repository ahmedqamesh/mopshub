//
// Module mopshub_lib.debug_uart_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:11:07 07/13/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module debug_uart_sm( 
   // Port Declarations
   input   wire      axi_uart_test, 
   input   wire      clk, 
   input   wire      fifo_dbg_out_rdy, 
   input   wire      out_rx_dv, 
   input   wire      rst, 
   input   wire      timeoutrst_uart,    // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   input   wire      w_tx_done, 
   output  reg       entimeout_uart, 
   output  reg       fifo_dbg_out_read, 
   output  reg       in_tx_dv, 
   output  reg       select_dbg_sm, 
   output  reg       write_dbg_fifo
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_Reset      = 3'd0,
          ST_SEL_SM     = 3'd1,
          ST_write_fifo = 3'd2,
          ST_read_fifo  = 3'd3,
          ST_write_uart = 3'd4,
          ST_write_done = 3'd5,
          ST_wait       = 3'd6,
          ST_rst_uart   = 3'd7;

reg [2:0] current_state, next_state;

// Wait State Signals
reg [3:0] csm_timer;
reg [3:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_wait;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   csm_timeout, 
   current_state, 
   fifo_dbg_out_rdy, 
   out_rx_dv, 
   w_tx_done
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_wait = 1'b0;
   case (current_state) 
      ST_Reset: begin
         if (out_rx_dv ==1'b1)
            next_state = ST_SEL_SM;
         else
            next_state = ST_Reset;
      end
      ST_SEL_SM: begin
         next_state = ST_write_fifo;
      end
      ST_write_fifo: begin
         if (fifo_dbg_out_rdy ==1'b1) begin
            next_state = ST_wait;
            csm_to_ST_wait = 1'b1;
         end
         else
            next_state = ST_write_fifo;
      end
      ST_read_fifo: begin
         next_state = ST_write_uart;
      end
      ST_write_uart: begin
         if (w_tx_done ==1'b1)
            next_state = ST_write_done;
         else
            next_state = ST_write_uart;
      end
      ST_write_done: begin
         if (w_tx_done ==1'b0)
            next_state = ST_Reset;
         else
            next_state = ST_write_done;
      end
      ST_wait: begin
         if (csm_timeout)
            next_state = ST_read_fifo;
         else
            next_state = ST_wait;
      end
      ST_rst_uart: begin
         next_state = ST_Reset;
      end
      default: 
         next_state = ST_Reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   entimeout_uart = 1;
   fifo_dbg_out_read = 0;
   in_tx_dv = 0;
   select_dbg_sm = 0;
   write_dbg_fifo = 0;

   // Combined Actions
   case (current_state) 
      ST_Reset: begin
         entimeout_uart = 0;
      end
      ST_SEL_SM: begin
         select_dbg_sm = 1'b1;
      end
      ST_write_fifo: begin
         write_dbg_fifo = 1'b1;
      end
      ST_read_fifo: begin
         fifo_dbg_out_read =1'b1;
      end
      ST_write_uart: begin
         in_tx_dv = 1'b1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_Reset;
      csm_timer <= 4'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_wait
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 4'd0);
   if (csm_to_ST_wait == 1'b1) begin
      csm_next_timer = 4'd7;  //no cycles(8)-1=7
   end
   else begin
      csm_next_timer = (csm_timeout)? 4'd0: (csm_timer - 4'd1);
   end
end // Wait State Block
endmodule // debug_uart_sm
