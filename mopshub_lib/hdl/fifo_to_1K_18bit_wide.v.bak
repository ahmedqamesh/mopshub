//
// Verilog Module mopshub_lib.fifo_to_1K_18bit_wide
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 15:44:49 02/25/21
//
// using Mentor Graphics HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
// Asynchronous FIFO (w/ 2 asynchronous clocks).
// 18 bit wide, 2K deep[it will take at least 1000 clock cycles to read the entire thing out.]
module fifo_to_2K_18bit_wide 
#(parameter DATA_WIDTH = 18,
            ADDRESS_WIDTH = 11,
            Almost_Full_limit = 14,
            FIFO_DEPTH = (1 << ADDRESS_WIDTH))// the FIFO width is  2K (2^11)
(  
   //Reading Ports
   output  wire    [DATA_WIDTH-1:0]  dout,                     //18 bit output signal
   output  wire            empty,
   input   wire            rd_en,
   input   wire            rd_clk,
   
   //Writing ports
   input   wire    [DATA_WIDTH-1:0]  din, 
   output  wire            full,
   input   wire            wr_en, 
   input   wire            wr_clk, 
   input   wire            rst,
    
   output  wire            almost_full, //When asserted, this signal indicates that only one more write can be performed before the FIFO is full
   input   wire    [9:0]   prog_full_thresh_assert, 
   input   wire    [9:0]   prog_full_thresh_negate, 
   output  wire            prog_full   //This signal is "asserted" when the number of words in the FIFO>= the assert threshold
                                       //It is "deasserted" when the number of words in the FIFO < the negate threshold. 
);


// Internal Declarations
reg   [DATA_WIDTH-1:0]              Mem [FIFO_DEPTH-1:0];
reg   [DATA_WIDTH-1:0]              WR_diff;
wire  [ADDRESS_WIDTH-1:0]           pNextWordToWrite, pNextWordToRead;
wire                                EqualAddresses;
wire                                NextWriteAddressEn, NextReadAddressEn;
wire                                Set_Status, Rst_Status;
reg                                 Status;
wire                                PresetFull, PresetEmpty;

assign almost_full=(WR_diff==Almost_Full_limit);
  
//-------------------------------------------------------------------------------------------
//-- write pipeline
//-------------------------------------------------------------------------------------------
 //'Data_out' logic:
    always @ (posedge rd_clk)
        if (rd_en & !empty)
            dout <= Mem[pNextWordToRead];
            
    //'Data_in' logic:
    always @ (posedge wr_clk)
        if (wr_en & !full)
            Mem[pNextWordToWrite] <= din;

    //Fifo addresses support logic: 
    //'Next Addresses' enable logic:
    assign NextWriteAddressEn = wr_en & ~full;
    assign NextReadAddressEn  = rd_en  & ~empty;
           
    //Addreses (Gray counters) logic:
    GrayCounter GrayCounter_pWr
       (.GrayCount_out(pNextWordToWrite),
       
        .Enable_in(NextWriteAddressEn),
        .Clear_in(rst),
        
        .Clk(wr_clk)
       );
       
    GrayCounter GrayCounter_pRd
       (.GrayCount_out(pNextWordToRead),
        .Enable_in(NextReadAddressEn),
        .Clear_in(rst),
        .Clk(rd_clk)
       );
     

    //'EqualAddresses' logic:
    assign EqualAddresses = (pNextWordToWrite == pNextWordToRead);

    //'Quadrant selectors' logic:
    assign Set_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ~^ pNextWordToRead[ADDRESS_WIDTH-1]) &
                         (pNextWordToWrite[ADDRESS_WIDTH-1] ^  pNextWordToRead[ADDRESS_WIDTH-2]);
                            
    assign Rst_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ^  pNextWordToRead[ADDRESS_WIDTH-1]) &
                         (pNextWordToWrite[ADDRESS_WIDTH-1] ~^ pNextWordToRead[ADDRESS_WIDTH-2]);
                         
    //'Status' latch logic:
    always @ (Set_Status, Rst_Status, rst) //D Latch w/ Asynchronous Clear & Preset.
        if (Rst_Status | rst)
            Status = 0;  //Going 'Empty'.
        else if (Set_Status)
            Status = 1;  //Going 'Full'.
            
    //'Full_out' logic for the writing port:
    assign PresetFull = Status & EqualAddresses;  //'Full' Fifo.
    
    always @ (posedge wr_clk, posedge PresetFull) //D Flip-Flop w/ Asynchronous Preset.
        if (PresetFull)
            full <= 1;
        else
            full <= 0;
            
    //'Empty_out' logic for the reading port:
    assign PresetEmpty = ~Status & EqualAddresses;  //'Empty' Fifo.
    
    always @ (posedge rd_clk, posedge PresetEmpty)  //D Flip-Flop w/ Asynchronous Preset.
        if (PresetEmpty)
            empty <= 1;
        else
            empty <= 0;
 
    always @(*) //ptr_diff changes as read or write clock change
      begin
      if(pNextWordToWrite>pNextWordToRead)
          WR_diff<=pNextWordToWrite-pNextWordToRead;
      
      else if(pNextWordToWrite <pNextWordToRead)
        begin
          WR_diff<=((FIFO_DEPTH-pNextWordToRead)+pNextWordToWrite);
        end
      
      else WR_diff<=0;
     
     end 
                
endmodule

module GrayCounter
   #(parameter   COUNTER_WIDTH = 11)
   
    (output reg  [COUNTER_WIDTH-1:0]    GrayCount_out,  //'Gray' code count output.
    
     input wire                         Enable_in,  //Count enable.
     input wire                         Clear_in,   //Count reset.
    
     input wire                         Clk);

    /////////Internal connections & variables///////
    reg    [COUNTER_WIDTH-1:0]         BinaryCount;

    /////////Code///////////////////////
    
    always @ (posedge Clk)
        if (Clear_in) begin
            BinaryCount   <= {COUNTER_WIDTH{1'b 0}} + 1;  //Gray count begins @ '1' with
            GrayCount_out <= {COUNTER_WIDTH{1'b 0}};      // first 'Enable_in'.
        end
        else if (Enable_in) begin
            BinaryCount   <= BinaryCount + 1;
            GrayCount_out <= {BinaryCount[COUNTER_WIDTH-1],
                              BinaryCount[COUNTER_WIDTH-2:0] ^ BinaryCount[COUNTER_WIDTH-1:1]};
        end
    
endmodule

