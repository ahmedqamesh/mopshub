//
// Module mopshub_lib.elink_interface_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:17:30 08/11/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_interface_SM #(
   // synopsys template
   parameter Kchar_eop = 8'b11011100,  // K28.6
   parameter Kchar_sop = 8'b00111100   // K28.1
)
( 
   // Port Declarations
   input   wire           abort,             // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,               // posedge
   input   wire    [9:0]  data_elink, 
   input   wire           end_cnt, 
   input   wire           end_cnt_dbg, 
   input   wire           rst,               // synchronous low active
   input   wire           send_mes,          // request from bridge FSM
   input   wire           start_read_elink, 
   input   wire           start_write,       // request from bridge FSM
   input   wire           timeoutrst,        // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [4:0]  addr,              // request to caninterface block
   output  reg            cs_can, 
   output  reg            cs_elink, 
   output  reg            en_rec_reg,        // enable receive buffer (rec_mes_buf)
   output  reg            end_read,          // request to bridge FSM 
   output  reg            end_write,         // request to bridge FSM
   output  reg            read,              // request to caninterface block(this actually connects to CAN node(canakari))
   output  reg            reset_sig_can, 
   output  reg            rst_cnt, 
   output  reg            set_bus_id, 
   output  reg            start_cnt, 
   output  reg     [5:0]  statedeb,          // State debug signal 
   output  reg            write              // request to caninterface block
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact       = 5'd0,
          reset           = 5'd1,
          RB1             = 5'd2,
          store_RB1       = 5'd3,
          store_idr1      = 5'd4,
          ST_start_Packet = 5'd5,
          RB2             = 5'd6,
          store_RB2       = 5'd7,
          RB3             = 5'd8,
          RB4             = 5'd9,
          store_RB3       = 5'd10,
          end_readst      = 5'd11,
          store_RB4       = 5'd12,
          id1             = 5'd13,
          d2              = 5'd14,
          d3              = 5'd15,
          d1              = 5'd16,
          d4              = 5'd17,
          tc              = 5'd18,
          general1        = 5'd19,
          Set_bus_Id      = 5'd20,
          bus_confirm     = 5'd21;

reg [4:0] current_state, next_state;

// Wait State Signals
reg [2:0] csm_timer;
reg [2:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_end_readst;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   data_elink, 
   rst, 
   send_mes, 
   start_read_elink, 
   start_write
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_end_readst = 1'b0;
   case (current_state) 
      waittoact: begin
         if (start_read_elink == 1)
            next_state = ST_start_Packet;
         else if (start_write == 1)
            next_state = Set_bus_Id;
         else
            next_state = waittoact;
      end
      reset: begin
         if (rst == 1)
            next_state = waittoact;
         else
            next_state = reset;
      end
      RB1: begin
         next_state = store_RB1;
      end
      store_RB1: begin
         next_state = RB2;
      end
      store_idr1: begin
         next_state = RB1;
      end
      ST_start_Packet: begin
         if (data_elink == {2'b10,Kchar_sop})
            next_state = store_idr1;
         else begin
            next_state = end_readst;
            csm_to_end_readst = 1'b1;
         end
      end
      RB2: begin
         next_state = store_RB2;
      end
      store_RB2: begin
         next_state = RB3;
      end
      RB3: begin
         next_state = store_RB3;
      end
      RB4: begin
         next_state = store_RB4;
      end
      store_RB3: begin
         next_state = RB4;
      end
      end_readst: begin
         next_state = waittoact;
      end
      store_RB4: begin
         next_state = end_readst;
         csm_to_end_readst = 1'b1;
      end
      id1: begin
         next_state = d1;
      end
      d2: begin
         next_state = d3;
      end
      d3: begin
         next_state = d4;
      end
      d1: begin
         next_state = d2;
      end
      d4: begin
         if (send_mes == 1)
            next_state = tc;
         else
            next_state = d4;
      end
      tc: begin
         next_state = bus_confirm;
      end
      general1: begin
         next_state = id1;
      end
      Set_bus_Id: begin
         next_state = general1;
      end
      bus_confirm: begin
         next_state = waittoact;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   addr = 5'b11111;
   cs_can = 0;
   cs_elink = 0;
   en_rec_reg = 0;
   end_read = 0;
   end_write = 0;
   read = 1;
   reset_sig_can = 0;
   rst_cnt = 0;
   set_bus_id = 0;
   start_cnt = 0;
   write = 1;

   // Combined Actions
   case (current_state) 
      RB1: begin
         read = 0;
         addr = 5'b00011 ;
         cs_can = 1 ;
      end
      store_RB1: begin
         read = 0;
         addr = 5'b00011 ;
         cs_can = 1 ;
         en_rec_reg = 1;
      end
      store_idr1: begin
         addr = 5'b00010;
         cs_elink = 1 ;
      end
      ST_start_Packet: begin
         addr = 5'b00001;
         cs_elink = 1 ;
      end
      RB2: begin
         read = 0;
         addr = 5'b00010 ;
         cs_can = 1 ;
      end
      store_RB2: begin
         read = 0;
         addr = 5'b00010 ;
         cs_can = 1 ;
         en_rec_reg = 1;
      end
      RB3: begin
         read = 0;
         addr = 5'b00001 ;
         cs_can = 1 ;
      end
      RB4: begin
         read = 0;
         addr = 5'b00000 ;
         cs_can = 1 ;
      end
      store_RB3: begin
         read = 0;
         addr = 5'b00001 ;
         cs_can = 1 ;
         en_rec_reg = 1;
      end
      end_readst: begin
         end_read = 1 ;
         addr = 5'b11111;
      end
      store_RB4: begin
         read = 0;
         addr = 5'b00000 ;
         cs_can = 1 ;
         en_rec_reg = 1;
      end
      id1: begin
         write = 0 ;
         addr = 5'b01100 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      d2: begin
         write = 0 ;
         addr = 5'b01001 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      d3: begin
         write = 0 ;
         addr = 5'b01000 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      d1: begin
         write = 0 ;
         addr = 5'b01010 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      d4: begin
         write = 0 ;
         addr = 5'b00111 ;
         end_write = 1 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      tc: begin
         write = 0 ;
         addr = 5'b01101 ;
         cs_can = 1 ;
         set_bus_id =1;
      end
      general1: begin
         write = 0 ;
         addr = 5'b01110;
         cs_can = 1;
         set_bus_id =1;
      end
      Set_bus_Id: begin
         set_bus_id =1;
      end
      bus_confirm: begin
         write = 0 ;
         addr = 5'b01111 ;
         set_bus_id =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
      csm_timer <= 3'd0;
   end
   else 
   begin
      if (timeoutrst) begin
         current_state <= reset;
         csm_timer <= 3'd0;
      end
      else if (abort) begin
         current_state <= reset;
         csm_timer <= 3'd0;
      end
      else 
      begin
         current_state <= next_state;
         csm_timer <= csm_next_timer;
      end
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_end_readst
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 3'd0);
   if (csm_to_end_readst == 1'b1) begin
      csm_next_timer = 3'd3;  //no cycles(4)-1=3
   end
   else begin
      csm_next_timer = (csm_timeout)? 3'd0: (csm_timer - 3'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
begin
   statedeb = 6'b0;
   statedeb[4:0] = current_state;
end

endmodule // elink_interface_SM
