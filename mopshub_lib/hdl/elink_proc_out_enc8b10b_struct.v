//
// Module mopshub_lib.elink_proc_out_enc8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 13:02:42 10/11/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
// 8b10b encoder for EPROC_OUT module
module elink_proc_out_enc8b10b( 
   // Port Declarations
   // Port Declarations
   input   wire           clk, 
   input   wire    [9:0]  data_10bit_in,  //Data stored in the FIFO
   input   wire           data_in_rdy, 
   input   wire           rst,            // reset all the counters and data
   output  wire           get_data_trig, 
   output  wire    [1:0]  data_2bit_out, 
   input   wire    [7:0]  Kchar_comma, 
   input   wire    [7:0]  Kchar_eop, 
   input   wire    [7:0]  Kchar_sop, 
   input   wire    [9:0]  COMMAn, 
   input   wire    [9:0]  COMMAp
);

// Local declarations
  
  // Internal signal declarations
  // Internal Declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0] enc10bit;
reg   [9:0] enc10bit_r;
reg   [1:0] zeros2bit;
reg   [2:0] send_count;
wire  [1:0] data_code;            // 00"data, 01"eop, 10"sop, 11"comma
wire  [7:0] byte;
reg   [9:0] enc_10b_data_out_r;
wire  [9:0] data_out;
reg         bit_cnt;
reg         KI_reg;               // -- Control (K) input(active high)
wire  [7:0] data_input;


// Instances 
enc_8b10b_mopshub enc_8b10b_mopshub0( 
   .rst     (rst), 
   .clk     (clk), 
   .ena     (data_in_rdy), 
   .ki      (KI_reg), 
   .datain  (byte), 
   .dataout (data_out)
); 

//  -------------------------------------------------------------------------------------------
//  -- data code cases
//  -- 00"data, 01"eop, 10"sop, 11"comma
//  -------------------------------------------------------------------------------------------
// 
// 
mux4_Nbit mux4_Nbit0( 
   .clk       (clk), 
   .rst       (rst), 
   .data0     (data_input), 
   .data1     (Kchar_eop), 
   .data2     (Kchar_sop), 
   .data3     (Kchar_comma), 
   .sel       (data_code), 
   .data_out  (byte), 
   .def_value (Kchar_comma)
); 

mux8_Nbit bitMUX( 
   .clk      (clk), 
   .rst      (rst), 
   .data0    (enc10bit_r[1:0]), 
   .data1    (enc10bit_r[3:2]), 
   .data2    (enc10bit_r[5:4]), 
   .data3    (enc10bit_r[7:6]), 
   .data4    (enc10bit_r[9:8]), 
   .data5    (zeros2bit), 
   .data6    (zeros2bit), 
   .data7    (zeros2bit), 
   .sel      (send_count), 
   .data_out (data_2bit_out)
); 

triger_counter triger_counter1( 
   .rst          (rst), 
   .clk          (clk), 
   .request_trig (get_data_trig)
); 

// HDL Embedded Text Block 3 eb3
initial zeros2bit   = 2'b0;
initial send_count  = 1'b0;
    
//Fill the register enc10bit_r with data 
always @(posedge clk)
begin
  if (!rst)
  enc10bit_r <= COMMAp;
  else if (get_data_trig  == 1) //Trigger after cycle 5 CLKs
  begin
    enc10bit_r <= enc10bit;
  end
end

//-------------------------------------------------------------------------------------------
//-- sending out 2 bits @ bitCLK using a MUX
//-------------------------------------------------------------------------------------------
// Counter over the select signal
always @(posedge clk)
begin
  if (!rst)
  send_count <= 3'b0;
  else
  begin
    if (get_data_trig == 1)
    send_count <= 3'b0;
    else  
    send_count <= send_count + 1;
  end
end                                   




































































// HDL Embedded Text Block 6 eb6
initial KI_reg = 1'b1;
assign data_code = data_10bit_in[9:8];
assign data_input = data_10bit_in[7:0];
always @ (posedge clk)
if (!rst) KI_reg <= 1'b1;
else KI_reg <=  data_code[1] | data_code[0]; //Control signal for the KI of the encoder (goes low if there is data i.e. code = 00, 01, 10)















// HDL Embedded Text Block 7 eb7
//define
initial
  begin 
   bit_cnt  = 1'b0;
  end
always @(posedge clk)
  if (!rst) bit_cnt <= 1'b0;
  else  bit_cnt <= ! bit_cnt;
    
assign enc10bit = enc_10b_data_out_r;

always @ (posedge clk)
  if (!rst) enc_10b_data_out_r <=COMMAp;
  else 
  begin
    if (data_10bit_in[7:0] == Kchar_comma && KI_reg ==1) 
      begin
        if (bit_cnt ==1) enc_10b_data_out_r <=COMMAp;
          else enc_10b_data_out_r <=COMMAn;
      end
    else enc_10b_data_out_r <= data_out; 
  end





















endmodule // elink_proc_out_enc8b10b
// EPROC_OUT_ENC8b10b
// EPROC_OUT_ENC8b10b
