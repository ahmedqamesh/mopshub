//
// Module mopshub_lib.elink_proc_out_enc8b10b.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 21:37:54 08/30/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
// 8b10b encoder for EPROC_OUT module
module elink_proc_out_enc8b10b( 
   // Port Declarations
   // Port Declarations
   input   wire           clk, 
   // Port Declarations
   // Port Declarations
   input   wire           bitCLK,              //bitCLK to send the 2bits EdataOUT [clk_40 MB/s]
   input   wire    [9:0]  EDATA_IN,            //Data stored in the FIFO
   input   wire           EDATA_RDY, 
   input   wire           reverse_stream_10b, 
   input   wire           swap_outbits, 
   input   wire           rst,                 // reset all the counters and data
   output  wire           get_data_trig, 
   output  wire    [1:0]  EDATA_OUT, 
   input   wire           fifo_data_rdy
);

// Local declarations
  
  // Internal signal declarations
  // Internal Declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
// Internal Declarations


// Local declarations

// Internal signal declarations
wire        reset;                   // reset all the counters and data
reg   [2:0] send_count     = 3'b0;
wire        send_out_trig;
wire  [9:0] enc10bit;
reg   [9:0] enc10bit_r;
wire  [1:0] zeros2bit      = 2'b0;
reg   [1:0] edata_out_r    = 2'b0;
wire  [1:0] edata_out_s;
wire        encDataOutrdy;
wire  [2:0] addr_bit;
wire        cs_bit_ewrite;
wire        rd_fifo_en;
wire        rd_en;
wire        pulseout;


// Instances 
elink_interface_rec_SM elink_interface_rec_SM_enc( 
   .abort             (), 
   .clk               (clk), 
   .enc_data_rdy      (encDataOutrdy), 
   .fifo_data_rdy     (fifo_data_rdy), 
   .rst               (reset), 
   .start_write_elink (), 
   .timeoutrst        (), 
   .addr_bit          (addr_bit), 
   .addr_write        (), 
   .buffer_rec_en     (), 
   .cs_bit_ewrite     (cs_bit_ewrite), 
   .cs_ewrite         (), 
   .end_write_bits    (), 
   .end_write_elink   (), 
   .irq_elink_rec     (), 
   .rd_fifo_en        (rd_fifo_en), 
   .start_write_bits  (), 
   .statedeb          ()
); 

//  Instances
//     -------------------------------------------------------------------------------------------
//     -- 8b10b encoding
//     -------------------------------------------------------------------------------------------
// 
// 
// 
// 
// 
enc8b10b_wrap enc8b10b_wrap10( 
   .clk           (clk), 
   .rst           (rst), 
   .dataCode      (EDATA_IN[9:8]), 
   .dataIN        (EDATA_IN[7:0]), 
   .dataINrdy     (EDATA_RDY), 
   .encDataOutrdy (encDataOutrdy), 
   .encDataOut    (enc10bit)
); 

mux8_Nbit #(2) bitMUX( 
   .data0    (enc10bit_r[1:0]), 
   .data1    (enc10bit_r[3:2]), 
   .data2    (enc10bit_r[5:4]), 
   .data3    (enc10bit_r[7:6]), 
   .data4    (enc10bit_r[9:8]), 
   .data5    (zeros2bit), 
   .data6    (zeros2bit), 
   .data7    (zeros2bit), 
   .sel      (send_count), 
   .data_out (edata_out_s)
); 

//     output Trig signal will enable reading from fifo (rd_en=1)
// 
//     generates a one clk-pulse pd clkss after trigger rising edge
// 
// 
// 
pulse_pdxx_pwxx #(0,1) pulse_pdxx_pwxx0( 
   .clk      (clk), 
   .trigger  (rd_en), 
   .pulseout (pulseout)
); 

//     output Trig signal will enable reading from fifo (rd_en=1)
// 
//     generates a one clk-pulse pd clkss after trigger rising edge
// 
// 
// 
pulse_pdxx_pwxx #(0,1) pulse_pdxx_pwxx1( 
   .clk      (clk), 
   .trigger  (send_out_trig), 
   .pulseout (get_data_trig)
); 

triger_counter #(3'b100,3'b011) triger_counter0( 
   .rst          (rst), 
   .bitCLK       (bitCLK), 
   .request_trig (send_out_trig)
); 

// HDL Embedded Text Block 3 eb3
// HDL Embedded Text Block 5 eb5
// HDL Embedded Text Block 4 data_reg
  //Fill the register enc10bit_r with data 
  always @(posedge clk)
  begin
    if (rst ==1)
    enc10bit_r <= 10'b0;
    else if (cs_bit_ewrite  ==1)//send_out_trig  == 1) //Trigger after cycle 5 CLKs
    begin
      if (reverse_stream_10b  == 0)//LSB send first 
      enc10bit_r <= {enc10bit[0],enc10bit[1],enc10bit[2],enc10bit[3],enc10bit[4],enc10bit[5],enc10bit[6],enc10bit[7],enc10bit[8],enc10bit[9]};
      else //MSB send first 
      enc10bit_r <= enc10bit;
    end
  end




















// HDL Embedded Text Block 4 eb4
// HDL Embedded Text Block 6 eb6
// HDL Embedded Text Block 5 Counter
  
  //-------------------------------------------------------------------------------------------
  //-- sending out 2 bits @ bitCLK using a MUX
  //-------------------------------------------------------------------------------------------
  // Counter over the select signal
  always @(posedge bitCLK)
  begin
    if (rst ==1)
    send_count <= 3'b0;
    else
    begin
      if (send_out_trig   == 1)
      send_count <= 3'b0;
      else  
      send_count <= send_count + 1;
    end
  end





















// HDL Embedded Text Block 5 eb5
// HDL Embedded Text Block 7 eb7
// buffer the output data
assign EDATA_OUT =edata_out_r;
always @ (swap_outbits, edata_out_s)
begin
  if (swap_outbits)
  edata_out_r = {edata_out_s[0],edata_out_s[1]};
  else     
  edata_out_r = edata_out_s;
end

// HDL Embedded Text Block 6 eb6
////-------------------------------------------------------------------------------------------
  ////-- re pulse [Reading Data]
  ////-------------------------------------------------------------------------------------------
assign reset =!rst;
assign rd_en = rd_fifo_en &(!cs_bit_ewrite);

















endmodule // elink_proc_out_enc8b10b
// EPROC_OUT_ENC8b10b
// EPROC_OUT_ENC8b10b
