//
// Module mopshub_lib.elink_side_core.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 19:12:47 03/05/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module elink_side_core( 
   // Port Declarations
   input   wire            clk_160,                    // - 160Mhz e-link clock
   input   wire            clk_40,                     // -- 40Mhz e-link clock
   input   wire            clk_80,                     // - 80Mhz e-link clock
   input   wire            clk_usr,                    // -- User clock rd/wr fifo domain 
   input   wire            rst,                        // reset the modules (not needed for initialization)
   input   wire            rx_elink,                   // 1-bit elink rx, must be connected to the input differential pin pair of FPGA
   input   wire            rx_fifo_read_enable,        // rx fifo read enable
   input   wire            tx_fifo_data_in,            // tx fifo write enable
   input   wire    [17:0]  tx_fifo_write_enable,       // tx fifo data in
   output  wire    [9:0]   rx_fifo_data_out,           // rx fifo 8b10b decoded data
   output  wire            rx_fifo_empty,              // rx fifo empty
   output  wire            rx_fifo_full,               // rx fifo full
   output  wire            tx_elink,                   //  1-bit elink tx, must be connected to the output differential pin pair of FPGA
   output  wire            tx_fifo_programmable_full   // tx fifo prog full
);


// Internal Declarations


// Local declarations
// Non hierarchical state machine declarations
// State encoding
parameter 
          state_flow     = 2'd0,
          ST_INIT_STAGE1 = 2'd1,
          ST_INIT_STAGE2 = 2'd2,
          ST_IDLE        = 2'd3;
reg [1:0] csm1_current_state, csm1_next_state;


// Internal signal declarations
reg   [6:0] cnt_data              = 0;
reg   [5:0] cnt_init              = 0;
wire  [2:0] din2bit;
wire  [2:0] dout2bit;                    // 2 bits is the data rate selected at clk80, can interface 2-bit of GBT frame
reg         fifo_flush_i          = 1;
reg         fifo_flush_s          = 1;
wire        reset_elink_i         = 0;
wire        reset_external_elink  = 0;
reg         reset_init_elink      = 0;
reg         rst_i                 = 1;
reg         rst_s                 = 1;   // X-elink Wrapper signals


// Instances 
Elink_to_FIFO U_1( 
   .clk_40     (clk_40), 
   .clk_80     (clk_80), 
   .clk_160    (clk_160), 
   .rst        (rst_s), 
   .DATA1bitIN (rx_elink), 
   .efifoRclk  (clk_usr), 
   .efifoRe    (rx_fifo_read_enable), 
   .fifo_flush (fifo_flush_s), 
   .efifoFull  (rx_fifo_full), 
   .efifoEmpty (rx_fifo_empty), 
   .efifoDout  (rx_fifo_data_out), 
   .elink2bit  (din2bit)
); 

FIFO_to_Elink U_0( 
   .efifoWclk   (clk_usr), 
   .clk_40      (clk_40), 
   .clk_80      (clk_80), 
   .clk_160     (clk_160), 
   .rst         (rst_s), 
   .efifoDin    (tx_fifo_data_in), 
   .efifoWe     (tx_fifo_write_enable), 
   .efifoPfull  (tx_fifo_programmable_full), 
   .DATA1bitOUT (tx_elink), 
   .elink2bit   (dout2bit), 
   .fifo_flush  (fifo_flush_s)
); 

// HDL Embedded Text Block 1 initRst_proc
// creates an internal reset pulse for initialization/reset                                       
always @(rst)//serialized output
begin 
  if(rst == 1)
    begin
      cnt_init <= 6'b0;
      rst_i <= 1;
      fifo_flush_i<= 1;
    end
end
always @(posedge clk_usr)
    begin 
      if(cnt_init < 6'b010000)
        begin
          cnt_init <= cnt_init+1;
          rst_i <= 1;
          fifo_flush_i<= 1;
        end
      else if((cnt_init < 6'b010000) & cnt_init < 6'b111111) //first release the flush signal
        begin
          cnt_init <= cnt_init+1;
          rst_i <= 1;
          fifo_flush_i<= 0;
        end
      else if(cnt_init < 6'b111111)//- remain in this state until reset by top
        begin
          cnt_init <= cnt_init;
          rst_i <= 0;
          fifo_flush_i<= 0;
        end
      else
        begin
          cnt_init <= 6'b0;
          rst_i <= 1;
          fifo_flush_i<= 1;    
        end
    end      


// HDL Embedded Text Block 2 assignning
// assignning 2  
assign reset_external_elink = rst;                                      
assign reset_elink_i = reset_external_elink | reset_init_elink;
// HDL Embedded Block 3 eb1
// Non hierarchical state machine
//-----------------------------------------------------------------
// Next State Block for machine csm1
//-----------------------------------------------------------------
always @(
   cnt_data, 
   csm1_current_state
)
begin : csm1_next_state_block_proc
   case (csm1_current_state) 
      state_flow: begin
         csm1_next_state = ST_INIT_STAGE1;
      end
      ST_INIT_STAGE1: begin
         csm1_next_state = ST_INIT_STAGE2;
      end
      ST_INIT_STAGE2: begin
         if (//Needs 2.025us to intialize all modules
             cnt_data == 81)
            csm1_next_state = ST_IDLE;
         else
            csm1_next_state = ST_INIT_STAGE2;
      end
      ST_IDLE: begin
         csm1_next_state = state_flow;
      end
      default: 
         csm1_next_state = ST_IDLE;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm1
//-----------------------------------------------------------------
always @(
   cnt_data, 
   csm1_current_state
)
begin : csm1_output_block_proc

   // Combined Actions
   case (csm1_current_state) 
      ST_INIT_STAGE1: begin
         reset_init_elink=1;
         cnt_data=0;
      end
      ST_INIT_STAGE2: begin
         reset_init_elink =0;
         cnt_data=cnt_data+1;
      end
      ST_IDLE: begin
         reset_init_elink =0;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm1
//-----------------------------------------------------------------
always @(
   posedge clk_40, 
   negedge reset_external_elink
) 
begin : csm1_clocked_block_proc
   if (!reset_external_elink) begin
      csm1_current_state <= state_flow;
   end
   else 
   begin
      csm1_current_state <= csm1_next_state;
   end
end // Clocked Block



endmodule // elink_side_core

