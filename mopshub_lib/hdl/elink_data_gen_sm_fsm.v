//
// Module mopshub_lib.elink_data_gen_sm.fsm
//
// Created:
//          by - Ahmed Qamesh (University of Wuppertal)
//          at - 13:00:19 03/15/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_data_gen_sm #(
   // synopsys template
   parameter Kchar_eop   = 8'b11011100,  // K28.6
   parameter Kchar_sop   = 8'b00111100,  // K28.1
   parameter Kchar_comma = 8'b10111100
)
( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire            clk,                // write FIFO clk
   input   wire            rst,                // should be used through VIO
   output  reg             irq_elink_tra,      //  ena signal
   output  reg     [3:0]   state_o, 
   input   wire            start_read_elink, 
   output  reg             end_read_elink, 
   input   wire            cnt_done, 
   output  reg             buffer_en, 
   output  reg     [75:0]  data_tra_in, 
   output  reg             rst_cnt, 
   output  reg             counter_gen_en, 
   input   wire            test_can_core, 
   output  reg     [9:0]   data_10bit_in_dbg, 
   output  reg             rdy_dbg, 
   output  reg             irq_elink_dbg, 
   input   wire            test_elink_core
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_Reset         = 6'd0,
          ST_WAIT          = 6'd1,
          ST_Done_Wait     = 6'd2,
          ST_Loop_cnt      = 6'd3,
          ST_Rst_Cnt2      = 6'd4,
          ST_counter_Wait1 = 6'd5,
          ST_En_Buffer1    = 6'd6,
          ST_End_Read1     = 6'd7,
          ST_Bus_cnt2      = 6'd8,
          ST_start_test    = 6'd9,
          ST_End_Read2     = 6'd10,
          choose_test      = 6'd11,
          ST_Done_Wait1    = 6'd12,
          s1               = 6'd13,
          ST_SOP           = 6'd14,
          ST_EOP1          = 6'd15,
          ST_Set_DATA1     = 6'd16,
          ST_DATA1         = 6'd17,
          ST_DATA3         = 6'd18,
          ST_Set_DATA3     = 6'd19,
          ST_Set_DATA2     = 6'd20,
          ST_DATA2         = 6'd21,
          ST_Set_DATA4     = 6'd22,
          ST_Set_DATA5     = 6'd23,
          ST_irq_sig       = 6'd24,
          ST_DATA4         = 6'd25,
          ST_DATA5         = 6'd26,
          ST_EOP           = 6'd27,
          ST_Set_DATA6     = 6'd28,
          ST_SET_EOP       = 6'd29,
          ST_DATA8         = 6'd30,
          ST_DATA6         = 6'd31,
          ST_Set_DATA7     = 6'd32,
          ST_DATA7         = 6'd33,
          ST_Set_DATA8     = 6'd34;

reg [5:0] current_state, next_state;

// Wait State Signals
reg [23:0] csm_timer;
reg [23:0] csm_next_timer;
reg        csm_timeout;
reg        csm_to_ST_WAIT;
reg        csm_to_ST_Done_Wait;
reg        csm_to_ST_counter_Wait1;
reg        csm_to_ST_End_Read2;
reg        csm_to_ST_Done_Wait1;
reg        csm_to_ST_EOP1;
reg        csm_to_ST_DATA1;
reg        csm_to_ST_DATA3;
reg        csm_to_ST_DATA2;
reg        csm_to_ST_DATA4;
reg        csm_to_ST_DATA5;
reg        csm_to_ST_EOP;
reg        csm_to_ST_DATA8;
reg        csm_to_ST_DATA6;
reg        csm_to_ST_DATA7;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   cnt_done, 
   csm_timeout, 
   current_state, 
   start_read_elink, 
   test_can_core, 
   test_elink_core
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_WAIT = 1'b0;
   csm_to_ST_Done_Wait = 1'b0;
   csm_to_ST_counter_Wait1 = 1'b0;
   csm_to_ST_End_Read2 = 1'b0;
   csm_to_ST_Done_Wait1 = 1'b0;
   csm_to_ST_EOP1 = 1'b0;
   csm_to_ST_DATA1 = 1'b0;
   csm_to_ST_DATA3 = 1'b0;
   csm_to_ST_DATA2 = 1'b0;
   csm_to_ST_DATA4 = 1'b0;
   csm_to_ST_DATA5 = 1'b0;
   csm_to_ST_EOP = 1'b0;
   csm_to_ST_DATA8 = 1'b0;
   csm_to_ST_DATA6 = 1'b0;
   csm_to_ST_DATA7 = 1'b0;
   case (current_state) 
      ST_Reset: begin
         next_state = ST_WAIT;
         csm_to_ST_WAIT = 1'b1;
      end
      ST_WAIT: begin
         if (csm_timeout)
            next_state = choose_test;
         else
            next_state = ST_WAIT;
      end
      ST_Done_Wait: begin
         if (csm_timeout)
            next_state = s1;
         else
            next_state = ST_Done_Wait;
      end
      ST_Loop_cnt: begin
         next_state = ST_counter_Wait1;
         csm_to_ST_counter_Wait1 = 1'b1;
      end
      ST_Rst_Cnt2: begin
         next_state = ST_Reset;
      end
      ST_counter_Wait1: begin
         if (csm_timeout)
            next_state = ST_start_test;
         else
            next_state = ST_counter_Wait1;
      end
      ST_En_Buffer1: begin
         next_state = ST_End_Read1;
      end
      ST_End_Read1: begin
         next_state = ST_End_Read2;
         csm_to_ST_End_Read2 = 1'b1;
      end
      ST_Bus_cnt2: begin
         next_state = ST_En_Buffer1;
      end
      ST_start_test: begin
         if (start_read_elink ==1)
            next_state = ST_Bus_cnt2;
         else
            next_state = ST_start_test;
      end
      ST_End_Read2: begin
         next_state = ST_Done_Wait;
         csm_to_ST_Done_Wait = 1'b1;
      end
      choose_test: begin
         if (test_can_core ==1)
            next_state = ST_start_test;
         else if (test_elink_core ==1)
            next_state = ST_SOP;
         else
            next_state = choose_test;
      end
      ST_Done_Wait1: begin
         if (csm_timeout)
            next_state = ST_Reset;
         else
            next_state = ST_Done_Wait1;
      end
      s1: begin
         if (cnt_done ==1)
            next_state = ST_Rst_Cnt2;
         else
            next_state = ST_Loop_cnt;
      end
      ST_SOP: begin
         next_state = ST_EOP1;
         csm_to_ST_EOP1 = 1'b1;
      end
      ST_EOP1: begin
         if (csm_timeout)
            next_state = ST_Set_DATA1;
         else
            next_state = ST_EOP1;
      end
      ST_Set_DATA1: begin
         next_state = ST_DATA1;
         csm_to_ST_DATA1 = 1'b1;
      end
      ST_DATA1: begin
         if (csm_timeout)
            next_state = ST_Set_DATA2;
         else
            next_state = ST_DATA1;
      end
      ST_DATA3: begin
         if (csm_timeout)
            next_state = ST_Set_DATA4;
         else
            next_state = ST_DATA3;
      end
      ST_Set_DATA3: begin
         next_state = ST_DATA3;
         csm_to_ST_DATA3 = 1'b1;
      end
      ST_Set_DATA2: begin
         next_state = ST_DATA2;
         csm_to_ST_DATA2 = 1'b1;
      end
      ST_DATA2: begin
         if (csm_timeout)
            next_state = ST_Set_DATA3;
         else
            next_state = ST_DATA2;
      end
      ST_Set_DATA4: begin
         next_state = ST_DATA4;
         csm_to_ST_DATA4 = 1'b1;
      end
      ST_Set_DATA5: begin
         next_state = ST_DATA5;
         csm_to_ST_DATA5 = 1'b1;
      end
      ST_irq_sig: begin
         next_state = ST_Done_Wait1;
         csm_to_ST_Done_Wait1 = 1'b1;
      end
      ST_DATA4: begin
         if (csm_timeout)
            next_state = ST_Set_DATA5;
         else
            next_state = ST_DATA4;
      end
      ST_DATA5: begin
         if (csm_timeout)
            next_state = ST_Set_DATA6;
         else
            next_state = ST_DATA5;
      end
      ST_EOP: begin
         if (csm_timeout)
            next_state = ST_irq_sig;
         else
            next_state = ST_EOP;
      end
      ST_Set_DATA6: begin
         next_state = ST_DATA6;
         csm_to_ST_DATA6 = 1'b1;
      end
      ST_SET_EOP: begin
         next_state = ST_EOP;
         csm_to_ST_EOP = 1'b1;
      end
      ST_DATA8: begin
         if (csm_timeout)
            next_state = ST_SET_EOP;
         else
            next_state = ST_DATA8;
      end
      ST_DATA6: begin
         if (csm_timeout)
            next_state = ST_Set_DATA7;
         else
            next_state = ST_DATA6;
      end
      ST_Set_DATA7: begin
         next_state = ST_DATA7;
         csm_to_ST_DATA7 = 1'b1;
      end
      ST_DATA7: begin
         if (csm_timeout)
            next_state = ST_Set_DATA8;
         else
            next_state = ST_DATA7;
      end
      ST_Set_DATA8: begin
         next_state = ST_DATA8;
         csm_to_ST_DATA8 = 1'b1;
      end
      default: 
         next_state = ST_Reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   irq_elink_tra = 0;
   state_o = 0;
   end_read_elink = 0;
   buffer_en = 0;
   data_tra_in = 0;
   rst_cnt = 0;
   counter_gen_en = 0;
   data_10bit_in_dbg = {2'b11,Kchar_comma};
   rdy_dbg = 0;
   irq_elink_dbg = 0;

   // Combined Actions
   case (current_state) 
      ST_Reset: begin
         state_o     = 4'b000;
         irq_elink_tra = 0;
         buffer_en = 0;
         end_read_elink = 0;
         rst_cnt =0;
         irq_elink_dbg =1'b0;
         data_10bit_in_dbg ={2'b11,Kchar_comma};
      end
      ST_Loop_cnt: begin
         state_o     = 4'b010;
         counter_gen_en = 1;
      end
      ST_Rst_Cnt2: begin
         rst_cnt = 1 ;
      end
      ST_En_Buffer1: begin
         state_o     = 4'b011;
         buffer_en = 1;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_End_Read1: begin
         state_o     = 4'b100;
         end_read_elink =1;
      end
      ST_Bus_cnt2: begin
         state_o     = 4'b010;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_start_test: begin
         state_o     = 4'b001;
         irq_elink_tra  = 1;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_SOP: begin
         data_10bit_in_dbg ={2'b10,Kchar_sop};
         rdy_dbg    = 1;
      end
      ST_EOP1: begin
         data_10bit_in_dbg ={2'b10,Kchar_sop};
      end
      ST_Set_DATA1: begin
         data_10bit_in_dbg ={2'b00,8'hDE};
         rdy_dbg    = 1;
      end
      ST_DATA1: begin
         data_10bit_in_dbg ={2'b00,8'hDE};
      end
      ST_DATA3: begin
         data_10bit_in_dbg ={2'b00,8'hBE};
      end
      ST_Set_DATA3: begin
         data_10bit_in_dbg ={2'b00,8'hBE};
         rdy_dbg    = 1;
      end
      ST_Set_DATA2: begin
         data_10bit_in_dbg ={2'b00,8'hAD};
         rdy_dbg    = 1;
      end
      ST_DATA2: begin
         data_10bit_in_dbg ={2'b00,8'hAD};
      end
      ST_Set_DATA4: begin
         data_10bit_in_dbg ={2'b00,8'hEF};
         rdy_dbg    = 1;
      end
      ST_Set_DATA5: begin
         data_10bit_in_dbg ={2'b00,8'hDE};
         rdy_dbg    = 1;
      end
      ST_irq_sig: begin
         irq_elink_dbg =1'b1;
      end
      ST_DATA4: begin
         data_10bit_in_dbg ={2'b00,8'hEF};
      end
      ST_DATA5: begin
         data_10bit_in_dbg ={2'b00,8'hDE};
      end
      ST_EOP: begin
         data_10bit_in_dbg ={2'b01,Kchar_eop};
      end
      ST_Set_DATA6: begin
         data_10bit_in_dbg ={2'b00,8'hAD};
         rdy_dbg    = 1;
      end
      ST_SET_EOP: begin
         data_10bit_in_dbg ={2'b01,Kchar_eop};
         rdy_dbg    = 1;
      end
      ST_DATA8: begin
         data_10bit_in_dbg ={2'b00,8'h0};
      end
      ST_DATA6: begin
         data_10bit_in_dbg ={2'b00,8'hAD};
      end
      ST_Set_DATA7: begin
         data_10bit_in_dbg ={2'b00,8'hBE};
         rdy_dbg    = 1;
      end
      ST_DATA7: begin
         data_10bit_in_dbg ={2'b00,8'hBE};
      end
      ST_Set_DATA8: begin
         data_10bit_in_dbg ={2'b00,8'h0};
         rdy_dbg    = 1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_Reset;
      csm_timer <= 24'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_WAIT,
   csm_to_ST_Done_Wait,
   csm_to_ST_counter_Wait1,
   csm_to_ST_End_Read2,
   csm_to_ST_Done_Wait1,
   csm_to_ST_EOP1,
   csm_to_ST_DATA1,
   csm_to_ST_DATA3,
   csm_to_ST_DATA2,
   csm_to_ST_DATA4,
   csm_to_ST_DATA5,
   csm_to_ST_EOP,
   csm_to_ST_DATA8,
   csm_to_ST_DATA6,
   csm_to_ST_DATA7
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 24'd0);
   if (csm_to_ST_WAIT == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_Done_Wait == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_counter_Wait1 == 1'b1) begin
      csm_next_timer = 24'd1999;  //no cycles(2000)-1=1999
   end
   else if (csm_to_ST_End_Read2 == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_Done_Wait1 == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_EOP1 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA1 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA3 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA2 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA4 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA5 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_EOP == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA8 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA6 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else if (csm_to_ST_DATA7 == 1'b1) begin
      csm_next_timer = 24'd4;  //no cycles(5)-1=4
   end
   else begin
      csm_next_timer = (csm_timeout)? 24'd0: (csm_timer - 24'd1);
   end
end // Wait State Block
endmodule // elink_data_gen_sm
