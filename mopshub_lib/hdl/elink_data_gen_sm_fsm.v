//
// Module mopshub_lib.elink_data_gen_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:25:07 12/21/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_data_gen_SM #(
   // synopsys template
   parameter Kchar_eop = 8'b11011100,  // K28.6
   parameter Kchar_sop = 8'b00111100   // K28.1
)
( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire            clk,                // write FIFO clk
   input   wire            reset,              // should be used through VIO
   output  reg             irq_elink_tra,      //  ena signal
   output  reg     [2:0]   state_o, 
   input   wire            start_read_elink, 
   output  reg             end_read_elink, 
   input   wire            cnt_done, 
   output  reg             buffer_en, 
   output  reg     [75:0]  data_tra_in, 
   output  reg             rst_cnt, 
   output  reg             counter_gen_en, 
   output  reg             start_write_elink, 
   input   wire            end_write_elink, 
   input   wire            test_can_core
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_Reset         = 5'd0,
          ST_WAIT          = 5'd1,
          ST_Done_Wait     = 5'd2,
          ST_Loop_cnt      = 5'd3,
          ST_Rst_Cnt2      = 5'd4,
          ST_counter_Wait1 = 5'd5,
          ST_En_Buffer1    = 5'd6,
          ST_End_Read1     = 5'd7,
          ST_Bus_cnt2      = 5'd8,
          ST_start_test    = 5'd9,
          ST_End_Read2     = 5'd10,
          choose_test      = 5'd11,
          ST_Done_Wait1    = 5'd12,
          ST_Enable_Data9  = 5'd13,
          s0               = 5'd14,
          ST_End_Read3     = 5'd15,
          s1               = 5'd16;

reg [4:0] current_state, next_state;

// Wait State Signals
reg [23:0] csm_timer;
reg [23:0] csm_next_timer;
reg        csm_timeout;
reg        csm_to_ST_WAIT;
reg        csm_to_ST_Done_Wait;
reg        csm_to_ST_counter_Wait1;
reg        csm_to_ST_End_Read2;
reg        csm_to_ST_Done_Wait1;
reg        csm_to_ST_End_Read3;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   cnt_done, 
   csm_timeout, 
   current_state, 
   end_write_elink, 
   start_read_elink, 
   test_can_core
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_WAIT = 1'b0;
   csm_to_ST_Done_Wait = 1'b0;
   csm_to_ST_counter_Wait1 = 1'b0;
   csm_to_ST_End_Read2 = 1'b0;
   csm_to_ST_Done_Wait1 = 1'b0;
   csm_to_ST_End_Read3 = 1'b0;
   case (current_state) 
      ST_Reset: begin
         next_state = ST_WAIT;
         csm_to_ST_WAIT = 1'b1;
      end
      ST_WAIT: begin
         if (csm_timeout)
            next_state = choose_test;
         else
            next_state = ST_WAIT;
      end
      ST_Done_Wait: begin
         if (csm_timeout)
            next_state = s1;
         else
            next_state = ST_Done_Wait;
      end
      ST_Loop_cnt: begin
         next_state = ST_counter_Wait1;
         csm_to_ST_counter_Wait1 = 1'b1;
      end
      ST_Rst_Cnt2: begin
         next_state = ST_Reset;
      end
      ST_counter_Wait1: begin
         if (csm_timeout)
            next_state = ST_start_test;
         else
            next_state = ST_counter_Wait1;
      end
      ST_En_Buffer1: begin
         next_state = ST_End_Read1;
      end
      ST_End_Read1: begin
         next_state = ST_End_Read2;
         csm_to_ST_End_Read2 = 1'b1;
      end
      ST_Bus_cnt2: begin
         next_state = ST_En_Buffer1;
      end
      ST_start_test: begin
         if (start_read_elink ==1)
            next_state = ST_Bus_cnt2;
         else
            next_state = ST_start_test;
      end
      ST_End_Read2: begin
         next_state = ST_Done_Wait;
         csm_to_ST_Done_Wait = 1'b1;
      end
      choose_test: begin
         if (test_can_core ==1)
            next_state = ST_start_test;
         else
            next_state = ST_Enable_Data9;
      end
      ST_Done_Wait1: begin
         if (csm_timeout)
            next_state = s0;
         else
            next_state = ST_Done_Wait1;
      end
      ST_Enable_Data9: begin
         if (end_write_elink ==1) begin
            next_state = ST_End_Read3;
            csm_to_ST_End_Read3 = 1'b1;
         end
         else
            next_state = ST_Enable_Data9;
      end
      s0: begin
         next_state = ST_Reset;
      end
      ST_End_Read3: begin
         if (csm_timeout) begin
            next_state = ST_Done_Wait1;
            csm_to_ST_Done_Wait1 = 1'b1;
         end
         else
            next_state = ST_End_Read3;
      end
      s1: begin
         if (cnt_done ==1)
            next_state = ST_Rst_Cnt2;
         else
            next_state = ST_Loop_cnt;
      end
      default: 
         next_state = ST_Reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   irq_elink_tra = 0;
   state_o = 0;
   end_read_elink = 0;
   buffer_en = 0;
   data_tra_in = 0;
   rst_cnt = 0;
   counter_gen_en = 0;
   start_write_elink = 0;

   // Combined Actions
   case (current_state) 
      ST_Reset: begin
         state_o     = 3'b000;
         irq_elink_tra = 0;
         buffer_en = 0;
         end_read_elink = 0;
         rst_cnt =0;
      end
      ST_Done_Wait: begin
         state_o     = 3'b101;
      end
      ST_Loop_cnt: begin
         state_o     = 3'b010;
         counter_gen_en = 1;
      end
      ST_Rst_Cnt2: begin
         rst_cnt = 1 ;
      end
      ST_counter_Wait1: begin
         state_o     = 3'b101;
      end
      ST_En_Buffer1: begin
         state_o     = 3'b011;
         buffer_en = 1;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_End_Read1: begin
         state_o     = 3'b100;
         end_read_elink =1;
      end
      ST_Bus_cnt2: begin
         state_o     = 3'b010;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_start_test: begin
         state_o     = 3'b001;
         irq_elink_tra  = 1;
         data_tra_in ={5'h0C,7'h1,16'h4010, 16'h2301,8'h0,8'h0,16'h0};
      end
      ST_Done_Wait1: begin
         state_o     = 3'b101;
      end
      ST_Enable_Data9: begin
         start_write_elink    = 1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (reset) begin
      current_state <= ST_Reset;
      csm_timer <= 24'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_WAIT,
   csm_to_ST_Done_Wait,
   csm_to_ST_counter_Wait1,
   csm_to_ST_End_Read2,
   csm_to_ST_Done_Wait1,
   csm_to_ST_End_Read3
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 24'd0);
   if (csm_to_ST_WAIT == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_Done_Wait == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_counter_Wait1 == 1'b1) begin
      csm_next_timer = 24'd1999;  //no cycles(2000)-1=1999
   end
   else if (csm_to_ST_End_Read2 == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_Done_Wait1 == 1'b1) begin
      csm_next_timer = 24'd9999999;  //no cycles(10000000)-1=9999999
   end
   else if (csm_to_ST_End_Read3 == 1'b1) begin
      csm_next_timer = 24'd999;  //no cycles(1000)-1=999
   end
   else begin
      csm_next_timer = (csm_timeout)? 24'd0: (csm_timer - 24'd1);
   end
end // Wait State Block
endmodule // elink_data_gen_SM
