//
// Module mopshub_lib.can_elink_bridge_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 15:51:07 01/28/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module can_elink_bridge_SM( 
   // Port Declarations
   input   wire           clk,                    // posedge
   input   wire           end_bus_trim_all, 
   input   wire           end_cnt_dbg, 
   input   wire           end_init,               // Signal from CAN interface block to indicate that initialization process is finished 
   input   wire           end_read_can,           // signal from CANopen block to indicate that it has read receive message buffer 
   input   wire           end_read_elink,         // this signal goes high when CANopen block has finshed writing transmit message buffer register 
   input   wire           end_read_miso, 
   input   wire           end_trim_osc, 
   input   wire           end_write_can,          // goes high when can interface block had finished writing canakari transmit registers
   input   wire           end_write_elink,        // Goes high when CANopen block finished reading the received message buffer register 
   input   wire           end_write_elink_spi, 
   input   wire           endwait,                // This signal indicates when message can't be decoded in one of the CANopen objects to go back to known state to receive message
   input   wire           irq_can_rec,            // interrupt signal from canakari to indicate successful read of a new message by one of the 32 buses 
   input   wire           irq_can_tra,            // successful transmission interrupt signal from cankari 
   input   wire           irq_elink_tra,          // interrupt from elink to indicate it has a msg
   input   wire           irq_spi_tra, 
   input   wire           reset_all_done, 
   input   wire           reset_irq_rec_done, 
   input   wire           reset_irq_tra_done, 
   input   wire           rst,                    // lowactive
   input   wire           timeoutrst,             // timeout reset in case bridge controller does not respond in a specied amount of time 
   output  reg            abort_mes,              // Signals other state machines to come to a known statte 
   output  reg            end_can_proc, 
   output  reg            end_spi_proc, 
   output  reg            entimeout,              // enable for timeout reset counter 
   output  reg            irq_trim_osc, 
   output  reg            read_can_mode, 
   output  reg            read_spi_mode, 
   output  reg            reset_irq_can,          // reset canakri interrupt 
   output  reg            reset_irq_can_all,      // reset all canakri interrupt 
   output  reg            reset_irq_rec_can, 
   output  reg            reset_irq_tra_can, 
   output  reg            send_mes_can, 
   output  reg            sign_on_sig,            // Signal to send one time NMT message after bootup
   output  reg            spi_cs, 
   output  reg            start_init_can,         // to initialize the CAN node (cankari)
   output  reg            start_read_can,         // to read canakari receive registers
   output  reg            start_read_elink,       // signal to read transmit message buffer register 
   output  reg            start_read_miso, 
   output  reg            start_write_can,        // to write transmit registers of canakari 
   output  reg            start_write_elink, 
   output  reg            start_write_elink_spi, 
   output  reg     [5:0]  statedeb
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          reset             = 5'd0,
          initialize        = 5'd1,
          waittoact         = 5'd2,
          endwaitst         = 5'd3,
          Start             = 5'd4,
          signon            = 5'd5,
          rst_all_irq_can   = 5'd6,
          Wait_for_OSC      = 5'd7,
          read_elink_mes    = 5'd8,
          Start_write_can   = 5'd9,
          pass_mes_to_can   = 5'd10,
          send_ack          = 5'd11,
          check_rec2        = 5'd12,
          rst_tra_irq_can   = 5'd13,
          finish_proc       = 5'd14,
          rst_rec_irq_can   = 5'd15,
          pass_mes_to_elink = 5'd16,
          assign_bus_id     = 5'd17,
          buffer_rec__ack   = 5'd18,
          Start_read_elink  = 5'd19,
          Abort_current     = 5'd20,
          Write_Mosi        = 5'd21,
          read_elink_mes1   = 5'd22,
          CS_low            = 5'd23,
          Read_Miso         = 5'd24,
          write_elink       = 5'd25,
          Done              = 5'd26;

reg [4:0] current_state, next_state;
// pragma synthesis_off
reg hds_animation_indicator;
// pragma synthesis_on

// Wait State Signals
reg [4:0] csm_timer;
reg [4:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_assign_bus_id;
reg       csm_to_CS_low;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   csm_timeout, 
   current_state, 
   end_bus_trim_all, 
   end_init, 
   end_read_can, 
   end_read_elink, 
   end_read_miso, 
   end_write_can, 
   end_write_elink, 
   end_write_elink_spi, 
   irq_can_rec, 
   irq_can_tra, 
   irq_elink_tra, 
   irq_spi_tra, 
   reset_all_done, 
   reset_irq_rec_done, 
   reset_irq_tra_done, 
   rst
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_assign_bus_id = 1'b0;
   csm_to_CS_low = 1'b0;
   case (current_state) 
      reset: begin
         if (rst == 1) begin
            next_state = Start;
            // pragma synthesis_off
            $hdsNextPath(0,1);
            // pragma synthesis_on
         end
         else begin
            next_state = reset;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      initialize: begin
         if (end_init == 1) begin
            next_state = Wait_for_OSC;
            // pragma synthesis_off
            $hdsNextPath(0,2);
            // pragma synthesis_on
         end
         else begin
            next_state = initialize;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      waittoact: begin
         if (irq_can_rec == 1) begin
            next_state = assign_bus_id;
            csm_to_assign_bus_id = 1'b1;
            // pragma synthesis_off
            $hdsNextPath(0,3);
            // pragma synthesis_on
         end
         else if (irq_elink_tra == 1) begin
            next_state = check_rec2;
            // pragma synthesis_off
            $hdsNextPath(0,4);
            // pragma synthesis_on
         end
         else if (irq_spi_tra ==1) begin
            next_state = read_elink_mes1;
            // pragma synthesis_off
            $hdsNextPath(0,5);
            // pragma synthesis_on
         end
         else begin
            next_state = waittoact;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      endwaitst: begin
         next_state = rst_all_irq_can;
         // pragma synthesis_off
         $hdsNextPath(0,6);
         // pragma synthesis_on
      end
      Start: begin
         next_state = initialize;
         // pragma synthesis_off
         $hdsNextPath(0,7);
         // pragma synthesis_on
      end
      signon: begin
         next_state = waittoact;
         // pragma synthesis_off
         $hdsNextPath(0,8);
         // pragma synthesis_on
      end
      rst_all_irq_can: begin
         if (reset_all_done ==1) begin
            next_state = waittoact;
            // pragma synthesis_off
            $hdsNextPath(0,9);
            // pragma synthesis_on
         end
         else begin
            next_state = rst_all_irq_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      Wait_for_OSC: begin
         if (end_bus_trim_all ==1) begin
            next_state = signon;
            // pragma synthesis_off
            $hdsNextPath(0,10);
            // pragma synthesis_on
         end
         else begin
            next_state = Wait_for_OSC;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      read_elink_mes: begin
         if (end_read_elink == 1) begin
            next_state = Start_write_can;
            // pragma synthesis_off
            $hdsNextPath(0,11);
            // pragma synthesis_on
         end
         else begin
            next_state = read_elink_mes;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      Start_write_can: begin
         if (end_write_can == 1) begin
            next_state = pass_mes_to_can;
            // pragma synthesis_off
            $hdsNextPath(0,12);
            // pragma synthesis_on
         end
         else begin
            next_state = Start_write_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      pass_mes_to_can: begin
         if (irq_can_tra == 1) begin
            next_state = send_ack;
            // pragma synthesis_off
            $hdsNextPath(0,13);
            // pragma synthesis_on
         end
         else begin
            next_state = pass_mes_to_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      send_ack: begin
         next_state = rst_tra_irq_can;
         // pragma synthesis_off
         $hdsNextPath(0,14);
         // pragma synthesis_on
      end
      check_rec2: begin
         next_state = read_elink_mes;
         // pragma synthesis_off
         $hdsNextPath(0,15);
         // pragma synthesis_on
      end
      rst_tra_irq_can: begin
         if (reset_irq_tra_done ==1) begin
            next_state = waittoact;
            // pragma synthesis_off
            $hdsNextPath(0,16);
            // pragma synthesis_on
         end
         else begin
            next_state = rst_tra_irq_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      finish_proc: begin
         next_state = waittoact;
         // pragma synthesis_off
         $hdsNextPath(0,17);
         // pragma synthesis_on
      end
      rst_rec_irq_can: begin
         if (reset_irq_rec_done ==1) begin
            next_state = finish_proc;
            // pragma synthesis_off
            $hdsNextPath(0,18);
            // pragma synthesis_on
         end
         else begin
            next_state = rst_rec_irq_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      pass_mes_to_elink: begin
         if (end_write_elink == 1) begin
            next_state = rst_rec_irq_can;
            // pragma synthesis_off
            $hdsNextPath(0,19);
            // pragma synthesis_on
         end
         else begin
            next_state = pass_mes_to_elink;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      assign_bus_id: begin
         if (csm_timeout) begin
            next_state = Start_read_elink;
            // pragma synthesis_off
            $hdsNextPath(0,20);
            // pragma synthesis_on
         end
         else begin
            next_state = assign_bus_id;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      buffer_rec__ack: begin
         next_state = pass_mes_to_elink;
         // pragma synthesis_off
         $hdsNextPath(0,21);
         // pragma synthesis_on
      end
      Start_read_elink: begin
         if (end_read_can == 1) begin
            next_state = buffer_rec__ack;
            // pragma synthesis_off
            $hdsNextPath(0,22);
            // pragma synthesis_on
         end
         else begin
            next_state = Start_read_elink;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      Abort_current: begin
         next_state = assign_bus_id;
         csm_to_assign_bus_id = 1'b1;
         // pragma synthesis_off
         $hdsNextPath(0,23);
         // pragma synthesis_on
      end
      Write_Mosi: begin
         next_state = CS_low;
         csm_to_CS_low = 1'b1;
         // pragma synthesis_off
         $hdsNextPath(0,24);
         // pragma synthesis_on
      end
      read_elink_mes1: begin
         if (end_read_elink == 1) begin
            next_state = Write_Mosi;
            // pragma synthesis_off
            $hdsNextPath(0,25);
            // pragma synthesis_on
         end
         else begin
            next_state = read_elink_mes1;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      CS_low: begin
         if (csm_timeout) begin
            next_state = Read_Miso;
            // pragma synthesis_off
            $hdsNextPath(0,26);
            // pragma synthesis_on
         end
         else begin
            next_state = CS_low;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      Read_Miso: begin
         if (end_read_miso == 1) begin
            next_state = write_elink;
            // pragma synthesis_off
            $hdsNextPath(0,27);
            // pragma synthesis_on
         end
         else begin
            next_state = Read_Miso;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      write_elink: begin
         if (end_write_elink_spi ==1) begin
            next_state = Done;
            // pragma synthesis_off
            $hdsNextPath(0,28);
            // pragma synthesis_on
         end
         else begin
            next_state = write_elink;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      Done: begin
         next_state = waittoact;
         // pragma synthesis_off
         $hdsNextPath(0,29);
         // pragma synthesis_on
      end
      default: begin
         next_state = reset;
         // pragma synthesis_off
         $hdsNextPath(0,0);
         // pragma synthesis_on
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   abort_mes = 0;
   end_can_proc = 0;
   end_spi_proc = 0;
   entimeout = 1;
   irq_trim_osc = 0;
   read_can_mode = 0;
   read_spi_mode = 0;
   reset_irq_can = 0;
   reset_irq_can_all = 0;
   reset_irq_rec_can = 0;
   reset_irq_tra_can = 0;
   send_mes_can = 0;
   sign_on_sig = 0;
   spi_cs = 1;
   start_init_can = 0;
   start_read_can = 0;
   start_read_elink = 0;
   start_write_can = 0;
   start_write_elink = 0;
   start_write_elink_spi = 0;

   // Combined Actions
   case (current_state) 
      reset: begin
         abort_mes = 1 ;
         reset_irq_can = 0 ;
         reset_irq_can_all = 0 ;
         send_mes_can = 0 ;  
         start_read_can = 0 ;
         start_read_elink = 0 ;
         start_write_can = 0 ;
         start_write_elink = 0 ;
         start_init_can = 0 ;
         sign_on_sig = 0;
         entimeout = 0 ;
         read_can_mode =0;
         read_spi_mode =0;
      end
      initialize: begin
         start_init_can = 1 ;
         entimeout = 0 ;
      end
      waittoact: begin
         entimeout = 0 ;
      end
      signon: begin
         sign_on_sig = 1 ;
      end
      rst_all_irq_can: begin
         reset_irq_can_all = 1 ;
      end
      Wait_for_OSC: begin
         irq_trim_osc =1;
      end
      read_elink_mes: begin
         start_read_elink = 1 ;
      end
      Start_write_can: begin
         start_write_can = 1 ;
      end
      pass_mes_to_can: begin
         send_mes_can =1;
      end
      rst_tra_irq_can: begin
         reset_irq_can = 1 ;
         reset_irq_tra_can = 1 ;
      end
      finish_proc: begin
         end_can_proc = 1;
         read_can_mode =1;
      end
      rst_rec_irq_can: begin
         reset_irq_can = 1 ;
         reset_irq_rec_can = 1 ;
         read_can_mode =1;
      end
      pass_mes_to_elink: begin
         start_write_elink = 1;
         read_can_mode =1;
      end
      assign_bus_id: begin
         read_can_mode =1;
      end
      buffer_rec__ack: begin
         read_can_mode =1;
      end
      Start_read_elink: begin
         start_read_can = 1 ;
         read_can_mode =1;
      end
      Abort_current: begin
         abort_mes = 1 ;
      end
      Write_Mosi: begin
         spi_cs =0;
         read_spi_mode =1;
      end
      read_elink_mes1: begin
         start_read_elink = 1 ;
         read_spi_mode =1;
      end
      CS_low: begin
         spi_cs = 0;
         read_spi_mode =1;
      end
      Read_Miso: begin
         start_read_miso =1;
         spi_cs = 0;
         read_spi_mode =1;
      end
      write_elink: begin
         start_write_elink_spi =1;
         read_spi_mode =1;
      end
      Done: begin
         end_spi_proc =1;
         read_spi_mode =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
      csm_timer <= 5'd0;
   end
   else if (endwait) begin
      current_state <= endwaitst;
      csm_timer <= 5'd0;
   end
   else if (timeoutrst) begin
      current_state <= endwaitst;
      csm_timer <= 5'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
      // pragma synthesis_off
      $hdsClock(0);
      // pragma synthesis_on
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_assign_bus_id,
   csm_to_CS_low
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 5'd0);
   if (csm_to_assign_bus_id == 1'b1) begin
      csm_next_timer = 5'd19;  //no cycles(20)-1=19
   end
   else if (csm_to_CS_low == 1'b1) begin
      csm_next_timer = 5'd9;  //no cycles(10)-1=9
   end
   else begin
      csm_next_timer = (csm_timeout)? 5'd0: (csm_timer - 5'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
begin
   statedeb = 6'b0;
   statedeb[4:0] = current_state;
end

endmodule // can_elink_bridge_SM
