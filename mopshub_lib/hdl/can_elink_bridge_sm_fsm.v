//
// Module mopshub_lib.can_elink_bridge_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 11:44:24 02/21/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module can_elink_bridge_sm( 
   // Port Declarations
   input   wire           clk,                 // clock (40MHz)
   input   wire           end_init,            // Flag successful CAN initialization
   input   wire           end_mon_init,        // Flag end the ADC Monitoring initialization
   input   wire           end_power_init,      // Flag end bus powering
   input   wire           end_read_can,        // Flag successful read CAN
   input   wire           end_read_elink,      // Flag successful read eLink
   input   wire           end_write_can,       // Flag successful write CAN
   input   wire           end_write_elink,     // Flag successful write eLink
   input   wire           endwait,             // Signal Interrupt from Other SM
   input   wire           irq_can_rec,         // Interrupt successful Receive CAN signal
   input   wire           irq_can_tra,         // Interrupt successful Transmission CAN signal
   input   wire           irq_elink_tra,       // Interrupt successful Transmission eLink signal
   input   wire           reset_all_done,      // Flag successful reset all CAN buses 
   input   wire           reset_irq_can_done,  // Flag successful reset CAN bus
   input   wire           rst,                 // reset (low active)
   input   wire           timeoutrst,          //  Interrupt reset timeout signal
   output  reg            abort_mes,           //  Interrupt abort message
   output  reg            end_can_proc,        // Flag successful CAN message processing
   output  reg            end_elink_proc,      // Flag successful eLink message processing
   output  reg            entimeout,           //  Watchdong timeout reset counter 
   output  reg            read_can_mode,       // Debug CAN signal
   output  reg            reset_irq_can,       //  Reset CAN controller  
   output  reg            reset_irq_can_all,   // reset all interrupt signals
   output  reg            reset_irq_rec_can,   //  Reset Receive interrupt signal  
   output  reg            reset_irq_tra_can,   //  Reset transmit  interrupt signal
   output  reg            send_mes_can,        // Debug CAN signal
   output  reg            set_power_init,      // Initialize the bus Powering initialization
   output  reg            sign_on_sig,         // Sign-In signal
   output  reg            start_init_can,      // Initialize the CAN controllers.
   output  reg            start_mon_init,      // Initialize the ADC Monitoring
   output  reg            start_read_can,      // Read CAN message signal
   output  reg            start_read_elink,    // Read eLink message signal
   output  reg            start_write_can,     // Write CAN message signal
   output  reg            start_write_elink,   // Write eLink message signal
   output  reg     [7:0]  statedeb             // debug state machine status
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_reset            = 5'd0,
          ST_Init_CAN         = 5'd1,
          ST_IDLE             = 5'd2,
          ST_Endwait          = 5'd3,
          ST_SignIn           = 5'd4,
          ST_Rst_all_CAN      = 5'd5,
          ST_Init_Trim        = 5'd6,
          ST_start_read_elink = 5'd7,
          ST_write_can        = 5'd8,
          ST_send_can         = 5'd9,
          ST_rst_can_tra      = 5'd10,
          ST_end_read_can     = 5'd11,
          ST_rst_can_rec      = 5'd12,
          ST_write_elink      = 5'd13,
          ST_start_read_can   = 5'd14,
          ST_read_can         = 5'd15,
          ST_Init_Mon         = 5'd16,
          ST_Wait_can_sm      = 5'd17,
          ST_end_read_elink   = 5'd18,
          ST_end_write_elink  = 5'd19;

reg [4:0] current_state, next_state;
// pragma synthesis_off
reg hds_animation_indicator;
// pragma synthesis_on

// Wait State Signals
reg [8:0] csm_timer;
reg [8:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_Wait_can_sm;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   csm_timeout, 
   current_state, 
   end_init, 
   end_mon_init, 
   end_power_init, 
   end_read_can, 
   end_read_elink, 
   end_write_can, 
   end_write_elink, 
   irq_can_rec, 
   irq_can_tra, 
   irq_elink_tra, 
   reset_all_done, 
   reset_irq_can_done, 
   rst
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_Wait_can_sm = 1'b0;
   case (current_state) 
      ST_reset: begin
         if (rst == 1) begin
            next_state = ST_Init_CAN;
            // pragma synthesis_off
            $hdsNextPath(0,1);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_reset;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_Init_CAN: begin
         if (end_init == 1) begin
            next_state = ST_Init_Mon;
            // pragma synthesis_off
            $hdsNextPath(0,2);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_Init_CAN;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_IDLE: begin
         if (irq_can_rec == 1) begin
            next_state = ST_start_read_can;
            // pragma synthesis_off
            $hdsNextPath(0,3);
            // pragma synthesis_on
         end
         else if (irq_elink_tra == 1) begin
            next_state = ST_start_read_elink;
            // pragma synthesis_off
            $hdsNextPath(0,4);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_IDLE;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_Endwait: begin
         next_state = ST_Rst_all_CAN;
         // pragma synthesis_off
         $hdsNextPath(0,5);
         // pragma synthesis_on
      end
      ST_SignIn: begin
         next_state = ST_IDLE;
         // pragma synthesis_off
         $hdsNextPath(0,6);
         // pragma synthesis_on
      end
      ST_Rst_all_CAN: begin
         if (reset_all_done ==1) begin
            next_state = ST_IDLE;
            // pragma synthesis_off
            $hdsNextPath(0,7);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_Rst_all_CAN;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_Init_Trim: begin
         if (end_power_init ==1) begin
            next_state = ST_SignIn;
            // pragma synthesis_off
            $hdsNextPath(0,8);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_Init_Trim;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_start_read_elink: begin
         if (end_read_elink == 1) begin
            next_state = ST_write_can;
            // pragma synthesis_off
            $hdsNextPath(0,9);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_start_read_elink;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_write_can: begin
         if (end_write_can == 1) begin
            next_state = ST_send_can;
            // pragma synthesis_off
            $hdsNextPath(0,10);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_write_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_send_can: begin
         if (irq_can_tra == 1) begin
            next_state = ST_rst_can_tra;
            // pragma synthesis_off
            $hdsNextPath(0,11);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_send_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_rst_can_tra: begin
         if (reset_irq_can_done ==1) begin
            next_state = ST_end_read_elink;
            // pragma synthesis_off
            $hdsNextPath(0,12);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_rst_can_tra;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_end_read_can: begin
         next_state = ST_write_elink;
         // pragma synthesis_off
         $hdsNextPath(0,13);
         // pragma synthesis_on
      end
      ST_rst_can_rec: begin
         if (reset_irq_can_done ==1) begin
            next_state = ST_end_read_can;
            // pragma synthesis_off
            $hdsNextPath(0,14);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_rst_can_rec;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_write_elink: begin
         if (end_write_elink == 1) begin
            next_state = ST_end_write_elink;
            // pragma synthesis_off
            $hdsNextPath(0,15);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_write_elink;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_start_read_can: begin
         next_state = ST_read_can;
         // pragma synthesis_off
         $hdsNextPath(0,16);
         // pragma synthesis_on
      end
      ST_read_can: begin
         if (end_read_can == 1) begin
            next_state = ST_Wait_can_sm;
            csm_to_ST_Wait_can_sm = 1'b1;
            // pragma synthesis_off
            $hdsNextPath(0,17);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_read_can;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_Init_Mon: begin
         if (end_mon_init ==1) begin
            next_state = ST_Init_Trim;
            // pragma synthesis_off
            $hdsNextPath(0,18);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_Init_Mon;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_Wait_can_sm: begin
         if (csm_timeout) begin
            next_state = ST_rst_can_rec;
            // pragma synthesis_off
            $hdsNextPath(0,19);
            // pragma synthesis_on
         end
         else begin
            next_state = ST_Wait_can_sm;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      end
      ST_end_read_elink: begin
         next_state = ST_IDLE;
         // pragma synthesis_off
         $hdsNextPath(0,20);
         // pragma synthesis_on
      end
      ST_end_write_elink: begin
         next_state = ST_IDLE;
         // pragma synthesis_off
         $hdsNextPath(0,21);
         // pragma synthesis_on
      end
      default: begin
         next_state = ST_reset;
         // pragma synthesis_off
         $hdsNextPath(0,0);
         // pragma synthesis_on
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   abort_mes = 0;
   end_can_proc = 0;
   end_elink_proc = 0;
   entimeout = 1;
   read_can_mode = 0;
   reset_irq_can = 0;
   reset_irq_can_all = 0;
   reset_irq_rec_can = 0;
   reset_irq_tra_can = 0;
   send_mes_can = 0;
   set_power_init = 0;
   sign_on_sig = 0;
   start_init_can = 0;
   start_mon_init = 0;
   start_read_can = 0;
   start_read_elink = 0;
   start_write_can = 0;
   start_write_elink = 0;

   // Combined Actions
   case (current_state) 
      ST_reset: begin
         abort_mes = 0 ;
         reset_irq_can = 0 ;
         reset_irq_can_all = 0 ;
         send_mes_can = 0 ;  
         start_read_can = 0 ;
         start_read_elink = 0 ;
         start_write_can = 0 ;
         start_write_elink = 0 ;
         start_init_can = 0 ;
         sign_on_sig = 0;
         entimeout = 0 ;
         read_can_mode =0;
      end
      ST_Init_CAN: begin
         start_init_can = 1 ;
         entimeout = 0 ;
      end
      ST_IDLE: begin
         entimeout = 0 ;
      end
      ST_Endwait: begin
         abort_mes = 1 ;
         end_can_proc = 1;
         end_elink_proc =1'b1;
      end
      ST_SignIn: begin
         sign_on_sig = 1 ;
      end
      ST_Rst_all_CAN: begin
         reset_irq_can_all = 1 ;
      end
      ST_Init_Trim: begin
         set_power_init =1;
         entimeout = 0 ;
      end
      ST_start_read_elink: begin
         start_read_elink = 1 ;
      end
      ST_write_can: begin
         start_write_can = 1 ;
      end
      ST_send_can: begin
         send_mes_can =1;
      end
      ST_rst_can_tra: begin
         reset_irq_can = 1 ;
         reset_irq_tra_can = 1 ;
      end
      ST_end_read_can: begin
         end_can_proc = 1;
         read_can_mode =1;
      end
      ST_rst_can_rec: begin
         reset_irq_can = 1 ;
         reset_irq_rec_can = 1 ;
         read_can_mode =1;
      end
      ST_write_elink: begin
         start_write_elink = 1;
         read_can_mode =1;
      end
      ST_start_read_can: begin
         read_can_mode =1;
      end
      ST_read_can: begin
         start_read_can = 1 ;
         read_can_mode =1;
      end
      ST_Init_Mon: begin
         start_mon_init =1;
      end
      ST_Wait_can_sm: begin
         read_can_mode =1;
      end
      ST_end_read_elink: begin
         end_elink_proc =1'b1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   posedge endwait
) 
begin : clocked_block_proc
   if (endwait) begin
      current_state <= ST_Endwait;
      csm_timer <= 9'd0;
   end
   else 
   begin
      if (!rst) begin
         current_state <= ST_reset;
         csm_timer <= 9'd0;
      end
      else if (timeoutrst) begin
         current_state <= ST_Endwait;
         csm_timer <= 9'd0;
      end
      else 
      begin
         current_state <= next_state;
         csm_timer <= csm_next_timer;
         // pragma synthesis_off
         $hdsClock(0);
         // pragma synthesis_on
      end
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_Wait_can_sm
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 9'd0);
   if (csm_to_ST_Wait_can_sm == 1'b1) begin
      csm_next_timer = 9'd299;  //no cycles(300)-1=299
   end
   else begin
      csm_next_timer = (csm_timeout)? 9'd0: (csm_timer - 9'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
begin
   statedeb = 8'b0;
   statedeb[4:0] = current_state;
end

endmodule // can_elink_bridge_sm
