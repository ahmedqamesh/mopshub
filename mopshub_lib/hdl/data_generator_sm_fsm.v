//
// Module mopshub_lib.data_generator_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 17:40:12 06/30/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module data_generator_SM( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire           clk,               // write FIFO clk
   input   wire           rst,               // should be used through VIO
   output  reg            done,              // dbg
   input   wire           end_send_msg, 
   output  reg            irq_elink,         //  ena signal
   output  reg            counter_en, 
   output  reg            buffer_en, 
   output  reg     [2:0]  state_o, 
   input   wire           loop_en, 
   output  reg            end_read_elink, 
   input   wire           cnt_done, 
   input   wire           sign_on_sig, 
   input   wire           start_read_elink
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_Done_Wait  = 4'd0,
          ST_Done       = 4'd1,
          ST_Reset      = 4'd2,
          ST_Irq        = 4'd3,
          ST_Select_Sig = 4'd4,
          ST_En_Buffer  = 4'd5,
          ST_IDLE       = 4'd6,
          ST_End_Read   = 4'd7,
          ST_Last_Buff  = 4'd8,
          ST_End_Read1  = 4'd9;

reg [3:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   cnt_done, 
   current_state, 
   end_send_msg, 
   loop_en, 
   sign_on_sig, 
   start_read_elink
)
begin : next_state_block_proc
   case (current_state) 
      ST_Done_Wait: begin
         if (cnt_done ==1)
            next_state = ST_Last_Buff;
         else
            next_state = ST_Irq;
      end
      ST_Done: begin
         next_state = ST_IDLE;
      end
      ST_Reset: begin
         if (sign_on_sig == 1)
            next_state = ST_Irq;
         else
            next_state = ST_Reset;
      end
      ST_Irq: begin
         if (start_read_elink ==1)
            next_state = ST_Select_Sig;
         else
            next_state = ST_Irq;
      end
      ST_Select_Sig: begin
         next_state = ST_En_Buffer;
      end
      ST_En_Buffer: begin
         next_state = ST_End_Read;
      end
      ST_IDLE: begin
         if (loop_en == 1)
            next_state = ST_Reset;
         else
            next_state = ST_IDLE;
      end
      ST_End_Read: begin
         if (end_send_msg == 1)
            next_state = ST_Done_Wait;
         else
            next_state = ST_End_Read;
      end
      ST_Last_Buff: begin
         next_state = ST_End_Read1;
      end
      ST_End_Read1: begin
         if (end_send_msg == 1)
            next_state = ST_Done;
         else
            next_state = ST_End_Read1;
      end
      default: 
         next_state = ST_Reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   done = 0;
   irq_elink = 0;
   counter_en = 0;
   buffer_en = 0;
   state_o = 0;
   end_read_elink = 0;

   // Combined Actions
   case (current_state) 
      ST_Done_Wait: begin
         state_o     = 3'b101;
      end
      ST_Done: begin
         state_o = 3'b110;
         done =1;
      end
      ST_Reset: begin
         state_o     = 3'b000;
         done = 0;
         irq_elink = 0;
         counter_en = 0;
         buffer_en = 0;
         end_read_elink = 0;
      end
      ST_Irq: begin
         state_o     = 3'b001;
         irq_elink      = 1;
      end
      ST_Select_Sig: begin
         state_o     = 3'b010;
         counter_en = 1;
      end
      ST_En_Buffer: begin
         state_o     = 3'b011;
         counter_en = 0;
         buffer_en = 1;
      end
      ST_IDLE: begin
         state_o = 3'b111;
      end
      ST_End_Read: begin
         state_o     = 3'b100;
         end_read_elink =1;
      end
      ST_Last_Buff: begin
         irq_elink =1;
         buffer_en =1;
      end
      ST_End_Read1: begin
         state_o     = 3'b100;
         end_read_elink =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_Reset;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

endmodule // data_generator_SM
