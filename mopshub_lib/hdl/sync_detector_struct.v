//
// Module mopshub_lib.sync_detector.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 09:54:35 01/13/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module sync_detector( 
   // Port Declarations
   input   wire    [11:0]  bitstream_in, 
   input   wire            clk, 
   input   wire            rst, 
   output  wire    [9:0]   word10b, 
   output  wire            word10b_rdy
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0]  bitstream_align0;                        //2 words of 10bit
wire  [1:0]  comma_valid_bits;
wire  [9:0]  bitstream_align1;
reg   [11:0] EDATAbitstreamSREG   = 12'b0;            //12 bit (2 x 5 = 10, plus 2 more)
wire  [9:0]  MOPS_COMMAn          = 10'b0011111001;
wire  [9:0]  MOPS_COMMAp          = 10'b1100000110;
reg   [4:0]  alignment_sreg       = 5'b0;
wire         comma_valid_bits_or;
reg          align_select         = 0;
reg   [9:0]  word10b_reg          = 10'b0;


// Instances 
// HDL Embedded Text Block 8 align_select1
// eb1 1
//check if there are valid bits
assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);


always@(posedge clk)
if (!rst)
begin
  align_select <=0;
  alignment_sreg <=5'b0; //alignment selector state
end
else 
begin
  if(comma_valid_bits_or ==1) 
  begin
    align_select <= (!comma_valid_bits[0]) & comma_valid_bits[1];
    alignment_sreg <= 5'b10000; 
  end 
  else
  begin
    alignment_sreg <= {alignment_sreg[0],alignment_sreg[4:1]};//
  end 
end


























// HDL Embedded Text Block 9 alignment_word10b1
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------
assign word10b_rdy = alignment_sreg[4];
assign word10b = word10b_reg;
always@(posedge clk)
if (!rst)
  begin
    word10b_reg <=10'b0;
  end
else
    case (align_select)
        1'b0 :begin //when bit0 word got comma => align to bitstream_align_array0
          word10b_reg <= bitstream_align0;
          end
        1'b1 :begin //when bit1 word got comma => align to bitstream_align_array1
          word10b_reg <= bitstream_align1;
          end     
    endcase

































// HDL Embedded Text Block 12 eb5
always@(posedge clk)
if (!rst)
    EDATAbitstreamSREG <=0;
else
    EDATAbitstreamSREG <= bitstream_in;














// HDL Embedded Text Block 13 encoded_data
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 
//1 10bit-word per alignment, 2 possible alignments
//  10 bit word, alligned to bit 0 , 1
assign  bitstream_align0 = EDATAbitstreamSREG [9:0];                                 
assign  bitstream_align1 = EDATAbitstreamSREG [1+9:1+0];
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma [Two consecutive commas received]
assign comma_valid_bits[0] = (bitstream_align0 == MOPS_COMMAp | bitstream_align0== MOPS_COMMAn) ? 1:0;
assign comma_valid_bits[1] = (bitstream_align1 == MOPS_COMMAp | bitstream_align1== MOPS_COMMAn) ? 1:0;








































endmodule // sync_detector

