//
// Module mopshub_lib.sync_detector.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 09:44:12 02/24/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module sync_detector( 
   // Port Declarations
   input   wire    [10:0]  bitstream_in, 
   input   wire            clk, 
   input   wire            rst, 
   output  wire    [9:0]   word10b, 
   output  wire            word10b_rdy, 
   input   wire    [9:0]   COMMAp,        //-K.28.5//comma / idle character
   input   wire    [9:0]   COMMAn         //+K.28.5
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0] bitstream_align0;      //2 words of 10bit
wire  [1:0] comma_valid_bits;
wire  [9:0] bitstream_align1;
reg   [4:0] alignment_reg;
wire        comma_valid_bits_or;
reg         align_select;
reg   [9:0] word10b_reg;


// Instances 
// HDL Embedded Text Block 1 init_reg
// eb1 1                                        
initial word10b_reg          = 10'b0;
initial align_select         = 0;
initial alignment_reg        = 5'b0;

// HDL Embedded Text Block 8 align_select1
// eb1 1
//check if there are valid commas 
assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);
always@(posedge clk)
if (!rst)
begin
  align_select   <= 2'b0;
  alignment_reg <= 5'b0; //alignment selector state
end
else 
begin
  if(comma_valid_bits_or ==1) 
  begin
  alignment_reg <= 5'b10000; 
    case (comma_valid_bits)
        2'b01 : align_select <=  1'b0;//when bit0 word got comma => align to bitstream_align0
        2'b10 : align_select <=  1'b1;//when bit1 word got comma => align to bitstream_align1
        default: align_select <=  1'b0;    
    endcase
  end 
  else
  begin
    alignment_reg <= {alignment_reg[0],alignment_reg[4:1]};// shift reg to the right 10000 --> 01000 --> 00100 -->00010 etc
    align_select  <= align_select;
  end 
end



































































// HDL Embedded Text Block 9 alignment_word10b1
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------
assign word10b_rdy = alignment_reg[4]; // The data is ready once alignment_sreg == 10000
assign word10b = word10b_reg;
always@(posedge clk)
if (!rst) word10b_reg <= COMMAp;
else
begin
  if(alignment_reg[0] ==1)
    case (align_select)
        1'b0 : word10b_reg   <= bitstream_align0;//when bit0 word got comma => align to bitstream_align_array0
        1'b1 : word10b_reg   <= bitstream_align1;//when bit1 word got comma => align to bitstream_align_array1    
        default: word10b_reg <= COMMAp;
    endcase
 else
  word10b_reg <= word10b_reg;
end



































































// HDL Embedded Text Block 13 encoded_data
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 
//1 10bit-word per alignment, 2 possible alignments
//  10 bit word, alligned to bit 0 , 1
//if two bits are shifted in at the same time, the upper or lower 10 bits of the output may contain the symbol.
assign  bitstream_align0 = bitstream_in [9:0];                                 
assign  bitstream_align1 = bitstream_in [1+9:1+0];
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma [Two consecutive commas received]
assign comma_valid_bits[0] = (bitstream_align0 == COMMAp || bitstream_align0== COMMAn) ? 1:0;
assign comma_valid_bits[1] = (bitstream_align1 == COMMAp || bitstream_align1== COMMAn) ? 1:0;



























































endmodule // sync_detector

