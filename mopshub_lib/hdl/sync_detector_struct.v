//
// Module mopshub_lib.sync_detector.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 12:56:09 09/13/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module sync_detector( 
   // Port Declarations
   input   wire    [11:0]  bitstream_in, 
   input   wire            clk, 
   input   wire            rst, 
   output  wire    [9:0]   word10b, 
   output  wire            word10b_rdy, 
   input   wire    [9:0]   COMMAp,        //-K.28.5//comma / idle character
   input   wire    [9:0]   COMMAn         //+K.28.5
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0] bitstream_align0;      //2 words of 10bit
wire  [1:0] comma_valid_bits;
wire  [9:0] bitstream_align1;
reg   [4:0] alignment_reg;
wire        comma_valid_bits_or;
reg         align_select;
reg   [9:0] word10b_reg;
wire        word10b_align_rdy;


// Instances 
// HDL Embedded Text Block 1 init_reg
// eb1 1                                        
initial word10b_reg          = 10'b0;
initial align_select         = 1'b0;
initial alignment_reg        = 5'b0;


// HDL Embedded Text Block 8 align_select1

//check if there are valid commas 
assign comma_valid_bits_or =  (comma_valid_bits[0] | comma_valid_bits[1]);
always@(posedge clk)
if (!rst) alignment_reg  <= 5'b0; //alignment selector state
else 
begin
  if(comma_valid_bits_or ==1) alignment_reg <= 5'b10000; 
  else alignment_reg <= {alignment_reg[0],alignment_reg[4:1]};// shift reg to the right 10000 --> 01000 --> 00100 -->00010 etc
end



always@(posedge clk)
if (!rst) align_select   <= 1'b0;
else 
  begin
    if(comma_valid_bits_or ==1) 
    begin
      align_select =  (!comma_valid_bits[0] & comma_valid_bits[1]);
  //    case (comma_valid_bits)
  //        2'b01  : align_select <=  1'b0;//when bit0 word got comma => align to bitstream_align0
  //        2'b10  : align_select <=  1'b1;//when bit1 word got comma => align to bitstream_align1
  //        default: align_select <=  1'b0;    
  //    endcase
    end 
    else align_select  <= align_select;
  end


































































// HDL Embedded Text Block 9 alignment_word10b1
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------
initial word10b_reg = COMMAp;
assign word10b_align_rdy = alignment_reg[4]; // The data is ready once alignment_sreg == 10000
assign word10b_rdy     = word10b_align_rdy;
assign word10b         = word10b_reg;

always@(posedge clk)
//Start with a positive parity after rest 
//The encoder on the other side starts with COMMAn after reset
//This will avoid any disparity error at thje beginning
if (!rst) word10b_reg <= COMMAp; 
else 
begin
  if(alignment_reg[0] ==1)
        case (align_select)
            1'b0   : word10b_reg   <= bitstream_align0;//when bit0 word got comma => align to bitstream_align_array0
            1'b1   : word10b_reg   <= bitstream_align1;//when bit1 word got comma => align to bitstream_align_array1    
            default: word10b_reg   <= COMMAn;
        endcase
  else word10b_reg <= word10b_reg;
end




























































































































// HDL Embedded Text Block 10 alignment_word10b2
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------
initial word10b_reg = COMMAp;
assign word10b_align_rdy = alignment_reg[4]; // The data is ready once alignment_sreg == 10000
assign word10b_rdy     = word10b_align_rdy;
assign word10b         = word10b_reg;
always@(posedge clk)
if (!rst) word10b_reg <= COMMAn;
else if(alignment_reg[0] ==1)
      case (align_select)
          1'b0   : word10b_reg   <= bitstream_align0;//when bit0 word got comma => align to bitstream_align_array0
          1'b1   : word10b_reg   <= bitstream_align1;//when bit1 word got comma => align to bitstream_align_array1    
          default: word10b_reg   <= COMMAn;
      endcase
else word10b_reg <= word10b_reg;


















































































































// HDL Embedded Text Block 13 encoded_data
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 
//1 10bit-word per alignment, 2 possible alignments
//  10 bit word, alligned to bit 0 , 1
//if two bits are shifted in at the same time, the upper or lower 10 bits of the output may contain the symbol.
assign  bitstream_align0 = bitstream_in [9:0];                                 
assign  bitstream_align1 = bitstream_in [1+9:1+0];
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma [Two consecutive commas received]
assign comma_valid_bits[0] = (bitstream_align0 == COMMAp || bitstream_align0== COMMAn) ? 1:0;
assign comma_valid_bits[1] = (bitstream_align1 == COMMAp || bitstream_align1== COMMAn) ? 1:0;



























































endmodule // sync_detector

