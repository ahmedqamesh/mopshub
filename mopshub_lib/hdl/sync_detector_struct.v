//
// Module mopshub_lib.sync_detector.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 14:26:12 08/10/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module sync_detector #(
   // synopsys template
   parameter GENERATE_FEI4B = 0,
   parameter FEI4B_COMMAp   = 10'b1100000110,
   parameter FEI4B_COMMAn   = 10'b0011111001,
   parameter COMMAn         = 10'b1100000101,  //+K.28.5
   parameter COMMAp         = 10'b0011111010   //-K.28.5//comma / idle character
)
( 
   // Port Declarations
   output  wire    [9:0]   bitstream_align0, 
   output  wire    [1:0]   comma_valid_bits, 
   input   wire    [11:0]  bitstream_in, 
   input   wire            bitCLK, 
   input   wire            reverse_stream_10b, 
   input   wire            rst, 
   output  wire    [9:0]   bitstream_align1
);


// Internal Declarations


// Local declarations

// Internal signal declarations
reg  [11:0] EDATAbitstreamSREG  = 12'b0;   //12 bit (2 x 5 = 10, plus 2 more)


// Instances 
// HDL Embedded Text Block 12 eb5
always@(posedge bitCLK)
if (rst)
    EDATAbitstreamSREG <=0;
else
    EDATAbitstreamSREG <= bitstream_in;









// HDL Embedded Text Block 13 eb11
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 
//1 10bit-word per alignment, 2 possible alignments
//  10 bit word, alligned to bit 0 , 1
assign  bitstream_align0 = (reverse_stream_10b == 0)       ?  EDATAbitstreamSREG [9:0] ://LSB send first
                                                         {  EDATAbitstreamSREG [0],
                                                            EDATAbitstreamSREG [1],
                                                            EDATAbitstreamSREG [2],
                                                            EDATAbitstreamSREG [3],
                                                            EDATAbitstreamSREG [4],
                                                            EDATAbitstreamSREG [5],
                                                            EDATAbitstreamSREG [6],
                                                            EDATAbitstreamSREG [7],
                                                            EDATAbitstreamSREG [8],
                                                            EDATAbitstreamSREG [9]};//MSB send first
                                 
   
assign  bitstream_align1 = (reverse_stream_10b == 0)     ?    EDATAbitstreamSREG [1+9:1+0]://LSB send first
                                                         {  EDATAbitstreamSREG [1+0],
                                                            EDATAbitstreamSREG [1+1],
                                                            EDATAbitstreamSREG [1+2],
                                                            EDATAbitstreamSREG [1+3],
                                                            EDATAbitstreamSREG [1+4],
                                                            EDATAbitstreamSREG [1+5],
                                                            EDATAbitstreamSREG [1+6],
                                                            EDATAbitstreamSREG [1+7],
                                                            EDATAbitstreamSREG [1+8],
                                                            EDATAbitstreamSREG [1+9]};//MSB send first
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma...
if (GENERATE_FEI4B == 0) 
  begin:GBT_mode
    assign comma_valid_bits[0] = (bitstream_align0 == COMMAp | bitstream_align0== COMMAn) ? 1:0;
    assign comma_valid_bits[1] = (bitstream_align1 == COMMAp | bitstream_align1== COMMAn) ? 1:0;
  end
else
  begin:MOPS
    assign comma_valid_bits[0] = (bitstream_align0 == FEI4B_COMMAp | bitstream_align0== FEI4B_COMMAn) ? 1:0;
    assign comma_valid_bits[1] = (bitstream_align1 == FEI4B_COMMAp | bitstream_align1== FEI4B_COMMAn) ? 1:0;
  end
































endmodule // sync_detector

