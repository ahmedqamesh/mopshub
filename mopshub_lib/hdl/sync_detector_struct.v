//
// Module mopshub_lib.sync_detector.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 17:13:51 03/01/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module sync_detector( 
   // Port Declarations
   input   wire    [11:0]  bitstream_in, 
   input   wire            clk, 
   input   wire            rst, 
   output  wire    [9:0]   word10b, 
   output  wire            word10b_rdy
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire  [9:0]  bitstream_align0;                        //2 words of 10bit
wire  [1:0]  comma_valid_bits;
wire  [9:0]  bitstream_align1;
wire  [9:0]  bitstream_align2;
reg   [11:0] EDATAbitstreamSREG   = 12'b0;            //12 bit (2 x 5 = 10, plus 2 more)
wire  [9:0]  MOPS_COMMAn          = 10'b0011111001;
wire  [9:0]  MOPS_COMMAp          = 10'b1100000110;
reg   [4:0]  alignment_sreg       = 5'b0;
wire         comma_valid_bits_or;
reg          align_select         = 0;
reg   [9:0]  word10b_reg          = 10'b0;
wire         comma_valid_bits_2;


// Instances 
// HDL Embedded Text Block 8 align_select1
// eb1 1
//check if there are valid commas 
assign comma_valid_bits_or =  (comma_valid_bits[1] | comma_valid_bits[0]);

always@(posedge clk)
if (!rst)
begin
  align_select   <= 2'b0;
  alignment_sreg <= 5'b0; //alignment selector state
end
else 
begin
  if(comma_valid_bits_or ==1) 
  begin
    alignment_sreg <= 5'b10000; 
   // align_select   <=  !comma_valid_bits[0] || comma_valid_bits[1];
    case (comma_valid_bits)
        2'b01 : align_select <=  1'b0;//when bit0 word got comma => align to bitstream_align0
        2'b10 : align_select <=  1'b1;//when bit1 word got comma => align to bitstream_align1    
    endcase
  end 
  else
  begin
    alignment_sreg <= {alignment_sreg[0],alignment_sreg[4:1]};// shift reg to the right 10000 --> 01000 --> 00100 -->00010 etc
    align_select   <= align_select;
  end 
end



















































// HDL Embedded Text Block 9 alignment_word10b1
// Prepare_8b10b_data                                     
//-------------------------------------------------------------------------------------------
//--clock2
//-- alignment selected
//-------------------------------------------------------------------------------------------
assign word10b_rdy = alignment_sreg[4]; // The data is ready once alignment_sreg == 10000
assign word10b = word10b_reg;
always@(posedge clk)
if (!rst) word10b_reg <=10'b0;
else
    case (align_select)
        1'b0 : word10b_reg <= bitstream_align0;//when bit0 word got comma => align to bitstream_align_array0
        1'b1 : word10b_reg <= bitstream_align1;//when bit1 word got comma => align to bitstream_align_array1    
        default: word10b_reg <= 10'b0;
    endcase
        












































// HDL Embedded Text Block 13 encoded_data
//-------------------------------------------------------------------------------------------
//--Assign the bitstream to a register
//-------------------------------------------------------------------------------------------
always@(posedge clk)
if (!rst)
    EDATAbitstreamSREG =0;
else
    EDATAbitstreamSREG = bitstream_in;
//-------------------------------------------------------------------------------------------
//--clock0 //create a Word Aligner 
//-- input shift register mapping into 10 bit registers
//------------------------------------------------------------------------------------------- 
//1 10bit-word per alignment, 2 possible alignments
//  10 bit word, alligned to bit 0 , 1
//if two bits are shifted in at the same time, the upper or lower 10 bits of the output may contain the symbol.
assign  bitstream_align0 = EDATAbitstreamSREG [9:0];                                 
assign  bitstream_align1 = EDATAbitstreamSREG [1+9:1+0];
assign  bitstream_align2 = EDATAbitstreamSREG [2+9:2+0];
//-------------------------------------------------------------------------------------------
//--clock0
//-- K28.5 comma test
//------------------------------------------------------------------------------------------- 
//The receiver requires that the K28.5 idle character be periodically transmitted to enable byte and word
//synchronization                                     
// attempting to align on two ksel characters, BC(K.28.5 is a comma symbol) and 3C(K.28.1)  they arrive as BC in the lower byte and 3C in the upper byte. 
//1 10bit-word per alignment, comma is valid if two first words have comma [Two consecutive commas received]
assign comma_valid_bits[0] = (bitstream_align0 == MOPS_COMMAp | bitstream_align0== MOPS_COMMAn) ? 1:0;
assign comma_valid_bits[1] = (bitstream_align1 == MOPS_COMMAp | bitstream_align1== MOPS_COMMAn) ? 1:0;
assign comma_valid_bits_2  = (bitstream_align2 == MOPS_COMMAp | bitstream_align2== MOPS_COMMAn) ? 1:0;

















































endmodule // sync_detector

