//
// Module mopshub_lib.elink_interface_rec_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 11:12:01 02/15/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_interface_rec_SM( 
   // Port Declarations
   input   wire           abort,                  // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,                    // posedge
   input   wire           rst,                    // synchronous low active
   input   wire           start_write_elink,      // request from bridge FSM
   input   wire           start_write_elink_spi, 
   input   wire           timeoutrst,             // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [4:0]  addr_write,             // request to caninterface block
   output  reg            buffer_rec_en, 
   output  reg            buffer_spi_rec_en, 
   output  reg            cs_ewrite, 
   output  reg            end_write_elink,        // request to bridge FSM
   output  reg            end_write_elink_spi, 
   output  reg            entimeout,              // enable for timeout reset counter 
   output  reg            irq_elink_rec, 
   output  reg            spi_mode, 
   output  reg     [5:0]  statedeb
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_waittoact     = 6'd0,
          st_reset         = 6'd1,
          ST_end_write_en  = 6'd2,
          store_WB0        = 6'd3,
          store_WB1        = 6'd4,
          ST_wait_eop1     = 6'd5,
          store_WB8        = 6'd6,
          store_WB2        = 6'd7,
          store_WB7        = 6'd8,
          store_WB3        = 6'd9,
          store_WB6        = 6'd10,
          store_WB4        = 6'd11,
          store_WB5        = 6'd12,
          st_write_data    = 6'd13,
          store_SOP        = 6'd14,
          store_WB9        = 6'd15,
          store_Eop        = 6'd16,
          WB0              = 6'd17,
          WB1              = 6'd18,
          WB2              = 6'd19,
          WB3              = 6'd20,
          WB4              = 6'd21,
          WB5              = 6'd22,
          WB6              = 6'd23,
          WB7              = 6'd24,
          WB8              = 6'd25,
          WB9              = 6'd26,
          W_SOP            = 6'd27,
          W_Eop            = 6'd28,
          ST_end_write_en1 = 6'd29,
          store_SPI0       = 6'd30,
          store_SPI1       = 6'd31,
          ST_wait_eop2     = 6'd32,
          store_SPI2       = 6'd33,
          store_SPI3       = 6'd34,
          st_write_data1   = 6'd35,
          store_SOP1       = 6'd36,
          store_Eop1       = 6'd37,
          SPI0             = 6'd38,
          SPI1             = 6'd39,
          SPI2             = 6'd40,
          SPI3             = 6'd41,
          W_SOP1           = 6'd42,
          W_Eop1           = 6'd43;

reg [5:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   rst, 
   start_write_elink, 
   start_write_elink_spi
)
begin : next_state_block_proc
   case (current_state) 
      ST_waittoact: begin
         if (start_write_elink == 1)
            next_state = st_write_data;
         else if (start_write_elink_spi ==1)
            next_state = st_write_data1;
         else
            next_state = ST_waittoact;
      end
      st_reset: begin
         if (rst == 1)
            next_state = ST_waittoact;
         else
            next_state = st_reset;
      end
      ST_end_write_en: begin
         next_state = ST_waittoact;
      end
      store_WB0: begin
         next_state = WB1;
      end
      store_WB1: begin
         next_state = WB2;
      end
      ST_wait_eop1: begin
         next_state = ST_end_write_en;
      end
      store_WB8: begin
         next_state = WB9;
      end
      store_WB2: begin
         next_state = WB3;
      end
      store_WB7: begin
         next_state = WB8;
      end
      store_WB3: begin
         next_state = WB4;
      end
      store_WB6: begin
         next_state = WB7;
      end
      store_WB4: begin
         next_state = WB5;
      end
      store_WB5: begin
         next_state = WB6;
      end
      st_write_data: begin
         next_state = W_SOP;
      end
      store_SOP: begin
         next_state = WB0;
      end
      store_WB9: begin
         next_state = W_Eop;
      end
      store_Eop: begin
         next_state = ST_wait_eop1;
      end
      WB0: begin
         next_state = store_WB0;
      end
      WB1: begin
         next_state = store_WB1;
      end
      WB2: begin
         next_state = store_WB2;
      end
      WB3: begin
         next_state = store_WB3;
      end
      WB4: begin
         next_state = store_WB4;
      end
      WB5: begin
         next_state = store_WB5;
      end
      WB6: begin
         next_state = store_WB6;
      end
      WB7: begin
         next_state = store_WB7;
      end
      WB8: begin
         next_state = store_WB8;
      end
      WB9: begin
         next_state = store_WB9;
      end
      W_SOP: begin
         next_state = store_SOP;
      end
      W_Eop: begin
         next_state = store_Eop;
      end
      ST_end_write_en1: begin
         next_state = ST_waittoact;
      end
      store_SPI0: begin
         next_state = SPI1;
      end
      store_SPI1: begin
         next_state = SPI2;
      end
      ST_wait_eop2: begin
         next_state = ST_end_write_en1;
      end
      store_SPI2: begin
         next_state = SPI3;
      end
      store_SPI3: begin
         next_state = W_Eop1;
      end
      st_write_data1: begin
         next_state = W_SOP1;
      end
      store_SOP1: begin
         next_state = SPI0;
      end
      store_Eop1: begin
         next_state = ST_wait_eop2;
      end
      SPI0: begin
         next_state = store_SPI0;
      end
      SPI1: begin
         next_state = store_SPI1;
      end
      SPI2: begin
         next_state = store_SPI2;
      end
      SPI3: begin
         next_state = store_SPI3;
      end
      W_SOP1: begin
         next_state = store_SOP1;
      end
      W_Eop1: begin
         next_state = store_Eop1;
      end
      default: 
         next_state = st_reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always
begin : output_block_proc
   // Default Assignment
   addr_write = 5'b0;
   buffer_rec_en = 0;
   buffer_spi_rec_en = 0;
   cs_ewrite = 0;
   end_write_elink = 0;
   end_write_elink_spi = 0;
   entimeout = 1;
   irq_elink_rec = 0;
   spi_mode = 0;
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= st_reset;
   end
   else if (timeoutrst) begin
      current_state <= ST_waittoact;
   end
   else if (abort) begin
      current_state <= ST_waittoact;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

// State-As-Output assignment
always @(current_state)
statedeb = current_state;

endmodule // elink_interface_rec_SM
