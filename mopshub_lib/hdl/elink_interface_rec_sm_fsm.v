//
// Module mopshub_lib.elink_interface_rec_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 21:18:27 08/30/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_interface_rec_SM #(
   // synopsys template
   parameter Kchar_eop = 8'b11011100,  // K28.6
   parameter Kchar_sop = 8'b00111100   // K28.1
)
( 
   // Port Declarations
   input   wire           abort,              // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           clk,                // posedge
   input   wire           enc_data_rdy, 
   input   wire           fifo_data_rdy, 
   input   wire           rst,                // synchronous low active
   input   wire           start_write_elink,  // request from bridge FSM
   input   wire           timeoutrst,         // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [2:0]  addr_bit, 
   output  reg     [4:0]  addr_write,         // request to caninterface block
   output  reg            buffer_rec_en, 
   output  reg            cs_bit_ewrite, 
   output  reg            cs_ewrite, 
   output  reg            end_write_bits, 
   output  reg            end_write_elink,    // request to bridge FSM
   output  reg            irq_elink_rec, 
   output  reg            rd_fifo_en, 
   output  reg            start_write_bits, 
   output  reg     [6:0]  statedeb
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          waittoact         = 6'd0,
          reset             = 6'd1,
          ST_end_write_en   = 6'd2,
          store_WB0         = 6'd3,
          store_WB1         = 6'd4,
          ST_wait_eop1      = 6'd5,
          store_WB8         = 6'd6,
          store_WB2         = 6'd7,
          store_WB7         = 6'd8,
          store_WB3         = 6'd9,
          store_WB6         = 6'd10,
          store_WB4         = 6'd11,
          store_WB5         = 6'd12,
          st_write_data     = 6'd13,
          store_SOP         = 6'd14,
          store_WB9         = 6'd15,
          store_Eop         = 6'd16,
          ST_wait_buffer1   = 6'd17,
          WB0               = 6'd18,
          WB1               = 6'd19,
          WB2               = 6'd20,
          WB3               = 6'd21,
          WB4               = 6'd22,
          WB5               = 6'd23,
          WB6               = 6'd24,
          WB7               = 6'd25,
          WB8               = 6'd26,
          WB9               = 6'd27,
          W_SOP             = 6'd28,
          W_Eop             = 6'd29,
          ST_end_write_bits = 6'd30,
          st_write_bits     = 6'd31,
          data0             = 6'd32,
          data1             = 6'd33,
          data2             = 6'd34,
          data3             = 6'd35,
          data4             = 6'd36,
          st_write_bits1    = 6'd37;

reg [5:0] current_state, next_state;

// Wait State Signals
reg [2:0] csm_timer;
reg [2:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_wait_buffer1;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state, 
   enc_data_rdy, 
   fifo_data_rdy, 
   rst, 
   start_write_elink
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_wait_buffer1 = 1'b0;
   case (current_state) 
      waittoact: begin
         if (start_write_elink == 1)
            next_state = st_write_data;
         else if (fifo_data_rdy ==1)
            next_state = st_write_bits;
         else
            next_state = waittoact;
      end
      reset: begin
         if (rst == 1)
            next_state = waittoact;
         else
            next_state = reset;
      end
      ST_end_write_en: begin
         next_state = waittoact;
      end
      store_WB0: begin
         next_state = WB1;
      end
      store_WB1: begin
         next_state = WB2;
      end
      ST_wait_eop1: begin
         next_state = ST_wait_buffer1;
         csm_to_ST_wait_buffer1 = 1'b1;
      end
      store_WB8: begin
         next_state = WB9;
      end
      store_WB2: begin
         next_state = WB3;
      end
      store_WB7: begin
         next_state = WB8;
      end
      store_WB3: begin
         next_state = WB4;
      end
      store_WB6: begin
         next_state = WB7;
      end
      store_WB4: begin
         next_state = WB5;
      end
      store_WB5: begin
         next_state = WB6;
      end
      st_write_data: begin
         next_state = W_SOP;
      end
      store_SOP: begin
         next_state = WB0;
      end
      store_WB9: begin
         next_state = W_Eop;
      end
      store_Eop: begin
         next_state = ST_wait_eop1;
      end
      ST_wait_buffer1: begin
         next_state = ST_end_write_en;
      end
      WB0: begin
         next_state = store_WB0;
      end
      WB1: begin
         next_state = store_WB1;
      end
      WB2: begin
         next_state = store_WB2;
      end
      WB3: begin
         next_state = store_WB3;
      end
      WB4: begin
         next_state = store_WB4;
      end
      WB5: begin
         next_state = store_WB5;
      end
      WB6: begin
         next_state = store_WB6;
      end
      WB7: begin
         next_state = store_WB7;
      end
      WB8: begin
         next_state = store_WB8;
      end
      WB9: begin
         next_state = store_WB9;
      end
      W_SOP: begin
         next_state = store_SOP;
      end
      W_Eop: begin
         next_state = store_Eop;
      end
      ST_end_write_bits: begin
         next_state = waittoact;
      end
      st_write_bits: begin
         next_state = st_write_bits1;
      end
      data0: begin
         next_state = data1;
      end
      data1: begin
         next_state = data2;
      end
      data2: begin
         next_state = data3;
      end
      data3: begin
         next_state = data4;
      end
      data4: begin
         next_state = ST_end_write_bits;
      end
      st_write_bits1: begin
         if (enc_data_rdy ==1)
            next_state = data0;
         else
            next_state = st_write_bits1;
      end
      default: 
         next_state = reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   addr_bit = 2'b0;
   addr_write = 5'b0;
   buffer_rec_en = 0;
   cs_bit_ewrite = 0;
   cs_ewrite = 0;
   end_write_bits = 0;
   end_write_elink = 0;
   irq_elink_rec = 0;
   rd_fifo_en = 0;
   start_write_bits = 0;

   // Combined Actions
   case (current_state) 
      ST_end_write_en: begin
         end_write_elink =1;
      end
      store_WB0: begin
         addr_write = 5'b00010 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB1: begin
         addr_write = 5'b00011 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      ST_wait_eop1: begin
         addr_write = 5'b00000;
         irq_elink_rec =1;
      end
      store_WB8: begin
         addr_write = 5'b01010 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB2: begin
         addr_write = 5'b00100 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB7: begin
         addr_write = 5'b01001 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB3: begin
         addr_write = 5'b00101 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB6: begin
         addr_write = 5'b01000 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB4: begin
         addr_write = 5'b00110 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_WB5: begin
         addr_write = 5'b00111 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_SOP: begin
         addr_write = 5'b00001 ;
         cs_ewrite =1;
      end
      store_WB9: begin
         addr_write = 5'b01011 ;
         cs_ewrite = 1 ;
         buffer_rec_en =1;
      end
      store_Eop: begin
         addr_write = 5'b01100 ;
         cs_ewrite =1;
      end
      WB0: begin
         addr_write = 5'b00010 ;
      end
      WB1: begin
         addr_write = 5'b00011 ;
      end
      WB2: begin
         addr_write = 5'b00100 ;
      end
      WB3: begin
         addr_write = 5'b00101 ;
      end
      WB4: begin
         addr_write = 5'b00110 ;
      end
      WB5: begin
         addr_write = 5'b00111 ;
      end
      WB6: begin
         addr_write = 5'b01000 ;
      end
      WB7: begin
         addr_write = 5'b01001 ;
      end
      WB8: begin
         addr_write = 5'b01010 ;
      end
      WB9: begin
         addr_write = 5'b01011 ;
      end
      W_SOP: begin
         addr_write = 5'b00001 ;
      end
      W_Eop: begin
         addr_write = 5'b01100 ;
      end
      ST_end_write_bits: begin
         end_write_elink =1;
      end
      st_write_bits: begin
         rd_fifo_en=1;
      end
      data0: begin
         addr_bit = 3'b00 ;
         cs_bit_ewrite = 1;
      end
      data1: begin
         addr_bit  = 3'b001 ;
         cs_bit_ewrite = 1;
      end
      data2: begin
         addr_bit = 3'b10 ;
         cs_bit_ewrite = 1;
      end
      data3: begin
         addr_bit  = 3'b11 ;
         cs_bit_ewrite = 1;
      end
      data4: begin
         addr_bit  = 3'b100 ;
         cs_bit_ewrite = 1;
      end
      st_write_bits1: begin
         start_write_bits =1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= reset;
      csm_timer <= 3'd0;
   end
   else 
   begin
      if (timeoutrst) begin
         current_state <= reset;
         csm_timer <= 3'd0;
      end
      else if (abort) begin
         current_state <= reset;
         csm_timer <= 3'd0;
      end
      else 
      begin
         current_state <= next_state;
         csm_timer <= csm_next_timer;
      end
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_wait_buffer1
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 3'd0);
   if (csm_to_ST_wait_buffer1 == 1'b1) begin
      csm_next_timer = 3'd3;  //no cycles(4)-1=3
   end
   else begin
      csm_next_timer = (csm_timeout)? 3'd0: (csm_timer - 3'd1);
   end
end // Wait State Block
// State-As-Output assignment
always @(current_state)
begin
   statedeb = 7'b0;
   statedeb[5:0] = current_state;
end

endmodule // elink_interface_rec_SM
