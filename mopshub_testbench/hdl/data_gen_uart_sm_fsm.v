//
// Module mopshub_testbench.data_gen_uart_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 15:40:59 08/08/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module data_gen_uart_sm #(
   // synopsys template
   parameter BAUD_RATE  = 115200,
   parameter BAUD_TICKS = $ceil((1 / BAUD_RATE) * 1e9)
)
( 
   // Port Declarations
   input   wire           clk, 
   input   wire    [7:0]  data_byte, 
   input   wire           rst, 
   output  reg            out_rx_serial, 
   output  reg     [7:0]  statedb
);


// Internal Declarations


// Declare any pre-registered internal signals
reg       out_rx_serial_cld;

// Module Declarations
reg [3:0] bit_counter;  

// State encoding
parameter 
          IDLE      = 3'd0,
          START_BIT = 3'd1,
          DATA_BITS = 3'd2,
          STOP_BIT  = 3'd3,
          RST       = 3'd4;

reg [2:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   bit_counter, 
   current_state, 
   data_byte
)
begin : next_state_block_proc
   case (current_state) 
      IDLE: begin
         if (data_byte !=8'b0)
            next_state = START_BIT;
         else
            next_state = IDLE;
      end
      START_BIT: begin
         if (bit_counter == 4'd7)
            next_state = DATA_BITS;
         else
            next_state = START_BIT;
      end
      DATA_BITS: begin
         if (bit_counter == 4'd7)
            next_state = STOP_BIT;
         else
            next_state = DATA_BITS;
      end
      STOP_BIT: begin
         if (bit_counter == 4'd7)
            next_state = IDLE;
         else
            next_state = STOP_BIT;
      end
      RST: begin
         next_state = IDLE;
      end
      default: 
         next_state = RST;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   bit_counter, 
   current_state, 
   data_byte
)
begin : output_block_proc
   // Default Assignment
   statedb = 0;

   // Combined Actions
   case (current_state) 
      START_BIT: begin
         out_rx_serial <= 1'b0; //start_bit
      end
      DATA_BITS: begin
         out_rx_serial <= data_byte[bit_counter];
      end
      STOP_BIT: begin
         out_rx_serial <= 1'b1; // Stop bit
      end
      RST: begin
         out_rx_serial <= 1'b1; // Default stop bit value
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= RST;
   end
   else 
   begin
      current_state <= next_state;

      // Combined Actions
      case (current_state) 
         IDLE: begin
            bit_counter <= 4'd0;
         end
         START_BIT: begin
            bit_counter <= bit_counter + 1;
            if (bit_counter == 4'd7)
               bit_counter <= 4'd0;
         end
         DATA_BITS: begin
            bit_counter <= bit_counter + 1;
            if (bit_counter == 4'd7)
               bit_counter <= 4'd0;
         end
         STOP_BIT: begin
            bit_counter <= bit_counter + 1;
            if (bit_counter == 4'd7)
               bit_counter <= 4'd0;
         end
         RST: begin
            bit_counter <= 4'd0;
         end
      endcase
   end
end // Clocked Block

// State-As-Output assignment
always @(current_state)
begin
   statedb = 8'b0;
   statedb[2:0] = current_state;
end

// Concurrent Statements
// Clocked output assignments
always @(
   out_rx_serial_cld
)
begin : clocked_output_proc
   out_rx_serial = out_rx_serial_cld;
end
endmodule // data_gen_uart_sm
