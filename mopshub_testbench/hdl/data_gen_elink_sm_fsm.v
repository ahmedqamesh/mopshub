//
// Module mopshub_testbench.data_gen_elink_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 12:48:14 02/20/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module data_gen_elink_sm( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire           clk,                   // write FIFO clk
   input   wire    [9:0]  counter10bit_limit, 
   input   wire           efifo_empty, 
   input   wire           end_write_emulator, 
   input   wire           loop_en, 
   input   wire           rst,                   // should be used through VIO
   input   wire           tx_efifo_full, 
   output  reg     [9:0]  data10bout, 
   output  reg            done,                  // dbg
   output  reg            start_write_emulator, 
   output  reg     [2:0]  state_o, 
   output  reg            wr_en, 
   output  reg            wr_en_comma
);


// Internal Declarations


// Module Declarations
reg [9:0] counter10bit_reg;  
reg [15:0] msg_count;  

// State encoding
parameter 
          ST_WR_SOF     = 4'd0,
          ST_RESET      = 4'd1,
          ST_WAIT_0     = 4'd2,
          ST_DONE       = 4'd3,
          ST_WR_EOF     = 4'd4,
          ST_Select_Sig = 4'd5,
          s1            = 4'd6,
          ST_WR_EOF1    = 4'd7,
          ST_WR_EOF2    = 4'd8,
          ST_WR_EOF3    = 4'd9,
          s3            = 4'd10,
          ST_En_Comma   = 4'd11,
          ST_Loop       = 4'd12,
          s0            = 4'd13,
          ST_WAIT_2     = 4'd14;

reg [3:0] current_state, next_state;

// Wait State Signals
reg [4:0] csm_timer;
reg [4:0] csm_next_timer;
reg       csm_timeout;
reg       csm_to_ST_DONE;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   counter10bit_limit, 
   counter10bit_reg, 
   csm_timeout, 
   current_state, 
   efifo_empty, 
   end_write_emulator, 
   loop_en, 
   tx_efifo_full
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_DONE = 1'b0;
   case (current_state) 
      ST_WR_SOF: begin
         if (!tx_efifo_full)
            next_state = ST_WAIT_0;
         else
            next_state = ST_WR_SOF;
      end
      ST_RESET: begin
         next_state = ST_En_Comma;
      end
      ST_WAIT_0: begin
         next_state = s3;
      end
      ST_DONE: begin
         if (csm_timeout && (loop_en == 1))
            next_state = ST_Loop;
         else
            next_state = ST_DONE;
      end
      ST_WR_EOF: begin
         if (!tx_efifo_full)
            next_state = ST_WR_EOF1;
         else
            next_state = ST_WR_EOF;
      end
      ST_Select_Sig: begin
         if (end_write_emulator ==1)
            next_state = s1;
         else
            next_state = ST_Select_Sig;
      end
      s1: begin
         if (counter10bit_reg >= counter10bit_limit && !tx_efifo_full)
            next_state = ST_WR_EOF;
         else if (!tx_efifo_full)
            next_state = ST_Select_Sig;
         else
            next_state = s1;
      end
      ST_WR_EOF1: begin
         next_state = ST_WR_EOF3;
      end
      ST_WR_EOF2: begin
         next_state = ST_DONE;
         csm_to_ST_DONE = 1'b1;
      end
      ST_WR_EOF3: begin
         if (!tx_efifo_full)
            next_state = ST_WR_EOF2;
         else
            next_state = ST_WR_EOF3;
      end
      s3: begin
         if (!tx_efifo_full)
            next_state = ST_Select_Sig;
         else
            next_state = s3;
      end
      ST_En_Comma: begin
         if (!efifo_empty)
            next_state = ST_Loop;
         else
            next_state = s0;
      end
      ST_Loop: begin
         if (!tx_efifo_full)
            next_state = ST_WAIT_2;
         else
            next_state = ST_Loop;
      end
      s0: begin
         if (!tx_efifo_full)
            next_state = ST_En_Comma;
         else
            next_state = s0;
      end
      ST_WAIT_2: begin
         next_state = ST_WR_SOF;
      end
      default: 
         next_state = ST_RESET;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   counter10bit_reg, 
   current_state
)
begin : output_block_proc
   // Default Assignment
   data10bout = 10'h3BC;
   done = 0;
   start_write_emulator = 0;
   state_o = 3'b0;
   wr_en = 0;
   wr_en_comma = 0;

   // Combined Actions
   case (current_state) 
      ST_WR_SOF: begin
         data10bout =10'h23C;
      end
      ST_RESET: begin
         done =0;
         start_write_emulator = 0;
         data10bout =10'h3BC;
         wr_en_comma =0;
      end
      ST_WAIT_0: begin
         data10bout =10'h23C;
         wr_en      = 1;
      end
      ST_DONE: begin
         done =1;
      end
      ST_WR_EOF: begin
         data10bout =10'h1DC;
      end
      ST_Select_Sig: begin
         data10bout =counter10bit_reg;
         wr_en = 1;
         start_write_emulator =1;
      end
      s1: begin
         data10bout =counter10bit_reg;
      end
      ST_WR_EOF1: begin
         data10bout =10'h1DC;
         wr_en      = 1;
      end
      ST_WR_EOF2: begin
         data10bout =10'h3BC;
         wr_en      = 1;
      end
      ST_WR_EOF3: begin
         data10bout =10'h3BC;
      end
      s3: begin
         data10bout =counter10bit_reg;
      end
      ST_En_Comma: begin
         wr_en_comma <= 1'b1;
         wr_en      = 1;
      end
      s0: begin
         wr_en_comma <= 1'b1;
      end
      ST_WAIT_2: begin
         data10bout =10'h3BC;
         wr_en      = 1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_RESET;
      csm_timer <= 5'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;

      // Combined Actions
      case (current_state) 
         ST_WR_SOF: begin
            msg_count <= 16'b0;
         end
         ST_RESET: begin
            msg_count <= 16'b0;
            counter10bit_reg <=1'b0;
         end
         s1: begin
            counter10bit_reg <= counter10bit_reg+1;
            if (counter10bit_reg >= counter10bit_limit && !tx_efifo_full)
               counter10bit_reg <= 1'b0;
         end
         ST_Loop: begin
            msg_count <= 16'b0;
         end
         s0: begin
            msg_count <= msg_count+1;
         end
      endcase
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_DONE
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 5'd0);
   if (csm_to_ST_DONE == 1'b1) begin
      csm_next_timer = 5'd19;  //no cycles(20)-1=19
   end
   else begin
      csm_next_timer = (csm_timeout)? 5'd0: (csm_timer - 5'd1);
   end
end // Wait State Block
endmodule // data_gen_elink_sm
