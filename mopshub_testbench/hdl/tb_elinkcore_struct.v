//
// Module mopshub_testbench.tb_elinkcore.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:21:47 01/05/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module tb_elinkcore #(
   // synopsys template
   parameter max_cnt              = 11,
   parameter seialize_data_stream = 1'b0,
   parameter Kchar_eop            = 8'b11011100,  // K28.6
   parameter Kchar_sop            = 8'b00111100   // K28.1
)
( 
   // Port Declarations
   output  wire    [75:0]  data_tra_out
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         abort                 = 1'b0;                      // Upon receiving a reset message on the CANbus. FSM goes into a known state
wire  [4:0]  addr;                                              // request to caninterface block
wire  [4:0]  addr_read;                                         // request to caninterface block
wire  [4:0]  addr_write;                                        // request to caninterface block
wire         buffer_elink_en;
wire         buffer_tra_en;
wire         clk_40;
wire         clock_out;
wire         counter_en;
wire         cs_eread;
wire         cs_ewrite;
wire  [4:0]  data_out;
wire  [9:0]  data_rec_10bitout;
wire  [75:0] data_rec_76bit_reg;
wire  [7:0]  data_rec_8bitout;
wire  [1:0]  data_rec_delimiter;
wire  [9:0]  data_tra_10bitin;
wire  [75:0] data_tra_76bit_reg;
wire  [75:0] data_tra_out_buff;
wire  [75:0] data_tra_out_buff2;
wire  [4:0]  data_tra_select;
reg   [1:0]  delimeter_r           = 0;
wire         done;                                              // dbg
reg   [7:0]  dout_r                = 0;
wire  [9:0]  dout_r_10b;
wire         enable                = 1'b1;
wire         enc_stream            = 1'b1;
wire         end_read_elink;
wire         end_write;                                         // request to bridge FSM
wire         end_write_emulator;
reg          fifo_data_eop         = 1'b0;
reg          fifo_data_packet;
reg          fifo_data_sop         = 1'b0;
wire         fifo_empty;
wire  [75:0] gen_edata_76bit       = 76'hdeadbeefdeadbeefdea;
wire         initi                 = 0;                         // Initialization command
wire         irq_elink_tra;
wire         loop_en               = 1'b0;
wire         request_trig;
wire         reset;                                             // should be used through VIO
reg          rst;                                               // should be used through VIO
wire         rst_cnt;
wire         rx_edata_rdy;
wire         rx_elink1bit_gen;
wire  [1:0]  rx_elink2bit_gen;
wire  [4:0]  sel_cnt;
wire         send_mes              = 1'b1;                      // request from bridge FSM
wire         set_bus_id;
wire         start_read_elink      = 1'b1;
wire         start_write_elink;
wire         start_write_emulator;
wire  [2:0]  state_o;
wire  [6:0]  statedeb_tra;
wire         test_can_core         = 1'b0;
wire         timeoutrst            = 1'b0;                      // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
wire         tx_elink1bit_gen;
wire  [1:0]  tx_elink2bit_gen;
wire         tx_fifo_pfull_gen     = 1'b0;                      // pfull from Tx FIFO
wire         wr_en;
wire         write;
wire  [15:0] write_can;                                         // Data written to Cankari
// output  wire    [4:0]   can_tra_select


// Instances 
bit_counter U_0( 
   .ext_rst    (rst_cnt), 
   .rst        (rst), 
   .data_out   (sel_cnt), 
   .clk        (clk_40), 
   .cnt_enable (counter_en)
); 

bit_counter U_1( 
   .ext_rst    (end_write), 
   .rst        (rst), 
   .data_out   (data_out), 
   .clk        (clk_40), 
   .cnt_enable (fifo_data_sop)
); 

buffer_rec_elink buffer_rec_elink000( 
   .data_rec_in        (gen_edata_76bit), 
   .addr               (addr_write), 
   .data_rec_8bitout   (data_rec_8bitout), 
   .data_rec_delimiter (data_rec_delimiter)
); 

buffer_tra_data tra_data_buf0( 
   .clk             (clk_40), 
   .data_tra_in     (data_tra_out_buff), 
   .buffer_en       (buffer_tra_en), 
   .rst             (rst), 
   .data_tra_select (data_tra_select), 
   .data_tra_out    (data_tra_out_buff2)
); 

buffer_tra_elink tra_elink_buf0( 
   .clk             (clk_40), 
   .data_tra_8bitin (data_tra_10bitin[7:0]), 
   .buffer_en       (buffer_elink_en), 
   .rst             (rst), 
   .addr            (addr_read), 
   .data_tra_out    (data_tra_out_buff)
); 

can_interface can_interface0( 
   .addr         (addr), 
   .data_init    (), 
   .initi        (initi), 
   .write        (write), 
   .reset_can    (initi), 
   .trim         (initi), 
   .data_tra_mes (data_tra_out_buff2), 
   .cmd          (), 
   .write_can    (write_can)
); 

can_interface_SM interface_SM0( 
   .abort              (), 
   .clk                (clk_40), 
   .end_can_proc       (), 
   .end_cnt            (), 
   .end_cnt_dbg        (), 
   .init               (), 
   .reset_irq_can      (), 
   .reset_irq_can_all  (), 
   .rst                (rst), 
   .send_mes           (send_mes), 
   .start_osc_trim     (), 
   .start_read         (), 
   .start_write        (start_write_elink), 
   .timeoutrst         (), 
   .addr               (addr), 
   .cs_can             (), 
   .en_rec_reg         (), 
   .end_init           (), 
   .end_osc_trim       (), 
   .end_read           (), 
   .end_write          (end_write), 
   .initi              (), 
   .read               (), 
   .reset_irq_rec_done (), 
   .reset_irq_tra_done (), 
   .reset_sig_can      (), 
   .reset_sig_can_all  (), 
   .rst_cnt            (), 
   .set_bus_id         (set_bus_id), 
   .start_cnt          (), 
   .statedeb           (), 
   .trim               (), 
   .write              (write)
); 

elink_interface_rec_SM elink_interface_rec_SM0( 
   .abort             (), 
   .clk               (clk_40), 
   .rst               (rst), 
   .start_write_elink (start_write_emulator), 
   .timeoutrst        (), 
   .addr_write        (addr_write), 
   .buffer_rec_en     (), 
   .cs_ewrite         (cs_ewrite), 
   .end_write_elink   (end_write_emulator), 
   .irq_elink_rec     (), 
   .statedeb          ()
); 

elink_interface_tra_SM elink_interface_tra_SM0( 
   .abort            (abort), 
   .clk              (clk_40), 
   .fifo_data_eop    (fifo_data_eop), 
   .fifo_data_sop    (fifo_data_sop), 
   .fifo_elink_rdy   (rx_edata_rdy), 
   .fifo_packet_rdy  (fifo_data_packet), 
   .rst              (rst), 
   .start_read_elink (start_read_elink), 
   .timeoutrst       (timeoutrst), 
   .addr_read        (addr_read), 
   .buffer_elink_en  (buffer_elink_en), 
   .buffer_tra_en    (buffer_tra_en), 
   .cs_eread         (cs_eread), 
   .end_read_elink   (end_read_elink), 
   .irq_elink_tra    (irq_elink_tra), 
   .statedeb         (statedeb_tra)
); 

fifo_RXelink_wrap fifo_RXelink_wra1( 
   .clk        (clk_40), 
   .din        (data_rec_10bitout), 
   .din_rdy    (cs_ewrite), 
   .flush_fifo (reset), 
   .rd_en_fifo (cs_eread), 
   .dout_fifo  (data_tra_10bitin), 
   .empty_fifo (fifo_empty), 
   .full_fifo  ()
); 

clock_divider clk_div( 
   .clock_in  (clk_40), 
   .clock_out (clock_out)
); 

clock_generator clk40( 
   .enable (enable), 
   .clk    (clk_40)
); 

data_gen_elink_SM DataGen( 
   .clk                  (clk_40), 
   .cnt_done             (request_trig), 
   .end_write_emulator   (end_write_emulator), 
   .loop_en              (loop_en), 
   .rst                  (rst), 
   .tx_fifo_pfull_gen    (tx_fifo_pfull_gen), 
   .counter_en           (counter_en), 
   .done                 (done), 
   .rst_cnt              (rst_cnt), 
   .start_write_emulator (start_write_emulator), 
   .state_o              (state_o), 
   .wr_en                (wr_en)
); 

mopshub_decoder #(1,seialize_data_stream) mopshub_decoder_emulator( 
   .clk                (clk_40), 
   .rx_elink2bit       (tx_elink2bit_gen), 
   .clk_80             (clock_out), 
   .rst                (rst), 
   .data_tra_out       (data_tra_out), 
   .data_tra_76bit_reg (data_tra_76bit_reg), 
   .tx_elink2bit       (rx_elink2bit_gen), 
   .data_rec_76bit_reg (data_rec_76bit_reg), 
   .start_write_elink  (start_write_emulator), 
   .end_write_elink    (), 
   .data_rec_in        (gen_edata_76bit), 
   .tx_elink1bit       (rx_elink1bit_gen), 
   .rx_elink1bit       (tx_elink1bit_gen), 
   .enc_stream         (enc_stream), 
   .start_read_elink   (start_read_elink)
); 

// HDL Embedded Text Block 2 Reset_module1
  initial 
  begin
    rst = 1'b0;
    #10 rst=!rst;
  end
assign reset = !rst;
// HDL Embedded Text Block 7 Data_rdy_signal1
//Save data into a buffer
assign tx_elink2bit_gen = rx_elink2bit_gen; // test the elink_to_fifo 2 bits
assign tx_elink1bit_gen = rx_elink1bit_gen; // test the elink_to_fifo 1 bit












































































































































// HDL Embedded Text Block 8 Data_rdy_signal2
// HDL Embedded Text Block 2 data_loader1
// data_loader 1
//sel din process
assign request_trig = (sel_cnt == max_cnt+1) ? 1:0;
assign dout_r_10b ={delimeter_r,dout_r}; 
always @(posedge clk_40)
begin 
  if(rst == 1)
  case (sel_cnt)
    5'b0 : begin 
      dout_r  <= 8'h00;
      delimeter_r  <= 2'b11;
    end
    5'b00001 : begin 
      dout_r  <= 8'h00;
      delimeter_r  <= 2'b10;
    end
    5'b00010 : begin 
      dout_r  <= 8'hDE;
      delimeter_r  <= 2'b00;
    end
    5'b00011 : begin 
      dout_r  <= 8'hAD;
      delimeter_r <= 2'b00;
    end
    5'b00100 : begin 
      dout_r  <= 8'hBE;
      delimeter_r  <= 2'b00;
    end
    5'b00101 : begin 
      dout_r  <= 8'hEF;
      delimeter_r <= 2'b00;
    end
    5'b00110 : begin 
      dout_r  <=8'hDE;
      delimeter_r  <=2'b00;
    end
    5'b00111 : begin 
      dout_r  <= 8'hAD;
      delimeter_r  <= 2'b00;
    end
    5'b01000 : begin 
      dout_r  <= 8'hBE;
      delimeter_r  <= 2'b00;
    end
    5'b01001 : begin 
      dout_r  <= 8'hEF;
      delimeter_r <= 2'b00;
    end
    5'b01010 : begin 
      dout_r  <= 8'hDE;
      delimeter_r  <= 2'b00;
    end
    5'b01011 : begin 
      dout_r  <= {4'hA,4'h0}; 
      delimeter_r <= 2'b00;
    end
    5'b01100 : begin 
      dout_r  <=8'h00;
      delimeter_r  <=2'b01;
    end
    default : begin 
      dout_r  <=8'h0;
      delimeter_r  <=2'b11;
    end
    
  endcase
  else
  begin
    dout_r <= 8'h0;
    delimeter_r  <=2'b11;
  end
end                        







































































































































// HDL Embedded Text Block 9 FIFO_read3

//Check FIFO output
assign start_write_elink = (data_out == 5'b11) ? 1:0;
assign rx_edata_rdy = !fifo_empty;
always@(*)//data_tra_10bitin or cs_eread)
  begin
  if(data_tra_10bitin == {2'b10,Kchar_sop})// 0x3c = 0011 1100 SOP (if 8b10b)
      begin
        fifo_data_sop = 1'b1;
        fifo_data_eop = 1'b0;
        fifo_data_packet =1'b0;
      end 
    else if(cs_eread && data_tra_10bitin != {2'b10,Kchar_sop}&& data_tra_10bitin != {2'b01,Kchar_eop} && data_tra_10bitin[9:8] == 2'b00)// data
      begin
        fifo_data_sop = 1'b0;
        fifo_data_eop = 1'b0;
        fifo_data_packet = 1'b1;
      end   
    else if(data_tra_10bitin == {2'b01,Kchar_eop})// 0xdc = 1101 1100 (if 8b10b)
      begin
       fifo_data_sop = 1'b0;
       fifo_data_eop = 1'b1;
       fifo_data_packet =1'b0;
      end
    else  
      begin
       fifo_data_sop = 1'b0;
       fifo_data_eop = 1'b0;
       fifo_data_packet =1'b0;
      end    
  end










































































































































// HDL Embedded Text Block 11 FIFO_write2
assign data_rec_10bitout ={data_rec_delimiter,data_rec_8bitout}; 















































































































































endmodule // tb_elinkcore

