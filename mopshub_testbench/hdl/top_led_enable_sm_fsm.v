//
// Module mopshub_testbench.top_led_enable_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 15:37:00 07/13/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module top_led_enable_sm( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire      clk_in,      // write FIFO clk
   input   wire      enable_cnt,  // pfull from Tx FIFO
   input   wire      rst,         // should be used through VIO
   output  reg       led
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_RESET  = 2'd0,
          ST_WAIT_0 = 2'd1,
          ST_WAIT_1 = 2'd2;

reg [1:0] current_state, next_state;

// Wait State Signals
reg [21:0] csm_timer;
reg [21:0] csm_next_timer;
reg        csm_timeout;
reg        csm_to_ST_WAIT_0;
reg        csm_to_ST_WAIT_1;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   csm_timeout, 
   current_state, 
   enable_cnt
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_ST_WAIT_0 = 1'b0;
   csm_to_ST_WAIT_1 = 1'b0;
   case (current_state) 
      ST_RESET: begin
         if (enable_cnt ==1) begin
            next_state = ST_WAIT_0;
            csm_to_ST_WAIT_0 = 1'b1;
         end
         else
            next_state = ST_RESET;
      end
      ST_WAIT_0: begin
         if (csm_timeout) begin
            next_state = ST_WAIT_1;
            csm_to_ST_WAIT_1 = 1'b1;
         end
         else
            next_state = ST_WAIT_0;
      end
      ST_WAIT_1: begin
         if (csm_timeout)
            next_state = ST_RESET;
         else
            next_state = ST_WAIT_1;
      end
      default: 
         next_state = ST_RESET;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   led = 0;

   // Combined Actions
   case (current_state) 
      ST_RESET: begin
         led =0;
      end
      ST_WAIT_0: begin
         led = 1;
      end
      ST_WAIT_1: begin
         led = 0;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk_in
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_RESET;
      csm_timer <= 22'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_ST_WAIT_0,
   csm_to_ST_WAIT_1
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 22'd0);
   if (csm_to_ST_WAIT_0 == 1'b1) begin
      csm_next_timer = 22'd999999;  //no cycles(1000000)-1=999999
   end
   else if (csm_to_ST_WAIT_1 == 1'b1) begin
      csm_next_timer = 22'd2999999;  //no cycles(3000000)-1=2999999
   end
   else begin
      csm_next_timer = (csm_timeout)? 22'd0: (csm_timer - 22'd1);
   end
end // Wait State Block
endmodule // top_led_enable_sm
