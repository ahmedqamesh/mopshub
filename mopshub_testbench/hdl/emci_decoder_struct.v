//
// Module mopshub_testbench.emci_decoder.struct
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 21:07:11 09/29/21
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//

`resetall
`timescale 1ns/10ps
module emci_decoder #(
   // synopsys template
   parameter DATA_WIDTH = 16,
   parameter max_cnt    = 11
)
( 
   // Port Declarations
   input   wire            bitCLKx4, 
   input   wire            clk_40, 
   // Port Declarations
   // Port Declarations
   input   wire            clk_80,                //bitCLK to send the 2bits EdataOUT [clk_40 MB/s]
   input   wire            data_10b_en, 
   input   wire    [9:0]   data_10b_in, 
   input   wire    [75:0]  data_rec_in, 
   input   wire            loop_en, 
   input   wire            reverse_10b_dbg, 
   input   wire            reverse_stream_10b, 
   input   wire            rst, 
   input   wire            swap_tx_bits, 
   input   wire            tx_fifo_pfull_gen, 
   output  wire    [1:0]   ISK, 
   output  wire    [75:0]  data_tra_out, 
   output  wire    [9:0]   enc10bit_out_dbg, 
   output  wire            start_write_emulator, 
   output  wire    [7:0]   tx_elink8bit_dec_dbg
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wire         BUSY;
wire  [1:0]  EDATA_2bit;
wire         clk;
wire         code_err;
wire         counter_en;
wire  [75:0] data_rec_76bit_reg;
wire  [7:0]  data_rec_8bitout;
wire  [1:0]  data_rec_delimiter;
wire  [75:0] data_tra_76bit_reg;
wire         datain_valid           = 1'b1;
reg   [1:0]  delimeter_r            = 0;
wire         disp_err;
wire         done;                                               // dbg
reg   [7:0]  dout_r                 = 0;
wire  [9:0]  dout_r_10b;
wire  [9:0]  enc10bit_out;
reg   [9:0]  enc10bit_r;
wire         enc_stream             = 0;
wire         end_write_emulator;
wire  [75:0] gen_edata_76bit        = 76'hdeadbeefdeadbeefdea;
wire         getDataTrig;                                        //output Trig signal will enable reading from fifo (rd_en=1)
wire         request_trig;
wire         reset;
wire         reverse_stream_10b_rx  = 1'b0;
wire         reverse_stream_10b_tx  = 1'b1;
wire         rst_cnt;
wire         rx_elink1bit_gen;
wire  [1:0]  rx_elink2bit_gen;
wire  [4:0]  sel_cnt;
reg   [2:0]  send_count;
wire         send_out_trig;
wire         start_read_elink       = 1'b0;
wire  [2:0]  state_o;
wire         tx_elink1bit_gen;
wire  [1:0]  tx_elink2bit_gen;
reg   [9:0]  word10b;
wire         wr_en;


// Instances 
bit_counter #(5) bit_counter0( 
   .ext_rst    (rst_cnt), 
   .rst        (rst), 
   .data_out   (sel_cnt), 
   .clk        (clk_40), 
   .cnt_enable (start_write_emulator)
); 

dec_8b10b_wrap dec_8b10b_wrap_emci( 
   .ABCDEIFGHJ_IN (word10b), 
   .clk           (clk_40), 
   .datain_valid  (datain_valid), 
   .rst           (rst), 
   .BUSY          (BUSY), 
   .HGFEDCBA      (tx_elink8bit_dec_dbg), 
   .ISK           (ISK), 
   .code_err      (code_err), 
   .disp_err      (disp_err)
); 

demux8_Nbit U_1( 
   .sel          (send_count), 
   .EDATA_2bit   (EDATA_2bit), 
   .enc10bit_out (enc10bit_out)
); 

elink_proc_out_enc8b10b elink_proc_out_enc8b10b_gen( 
   .clk                (clk_40), 
   .EDATA_IN           (dout_r_10b), 
   .EDATA_RDY          (wr_en), 
   .reverse_stream_10b (reverse_stream_10b), 
   .swap_outbits       (swap_tx_bits), 
   .rst                (rst), 
   .get_data_trig      (getDataTrig), 
   .EDATA_OUT          (EDATA_2bit), 
   .enc_stream         (enc_stream)
); 

triger_counter #(3'b100,3'b011) triger_counter_emci( 
   .rst          (rst), 
   .clk          (clk), 
   .request_trig (send_out_trig)
); 

data_gen_elink_SM DataGen( 
   .clk                  (clk_40), 
   .cnt_done             (request_trig), 
   .end_write_emulator   (end_write_emulator), 
   .loop_en              (loop_en), 
   .rst                  (rst), 
   .tx_fifo_pfull_gen    (tx_fifo_pfull_gen), 
   .counter_en           (counter_en), 
   .done                 (done), 
   .rst_cnt              (rst_cnt), 
   .start_write_emulator (start_write_emulator), 
   .state_o              (state_o), 
   .wr_en                (wr_en)
); 

mopshub_decoder #(1,1,8'b11011100,8'b00111100,1) mopshub_decoder_emulator( 
   .clk_40                (clk_40), 
   .rx_elink2bit          (tx_elink2bit_gen), 
   .clk_80                (clk_80), 
   .swap_tx_bits          (swap_tx_bits), 
   .reverse_stream_10b_tx (reverse_stream_10b_tx), 
   .reverse_stream_10b_rx (reverse_stream_10b_rx), 
   .rst                   (rst), 
   .data_tra_out          (data_tra_out), 
   .data_tra_76bit_reg    (data_tra_76bit_reg), 
   .tx_elink2bit          (rx_elink2bit_gen), 
   .data_rec_76bit_reg    (data_rec_76bit_reg), 
   .start_write_elink     (start_write_emulator), 
   .end_write_elink       (end_write_emulator), 
   .data_rec_in           (data_rec_in), 
   .data_rec_8bitout      (data_rec_8bitout), 
   .data_rec_delimiter    (data_rec_delimiter), 
   .tx_elink1bit          (rx_elink1bit_gen), 
   .rx_elink1bit          (tx_elink1bit_gen), 
   .start_read_elink      (start_read_elink), 
   .clk                   (bitCLKx4)
); 

// HDL Embedded Text Block 4 eb4
// HDL Embedded Text Block 2 eb2
// eb2 2      
assign   enc10bit_out_dbg =  enc10bit_r;
always @(posedge clk_40)
  begin
   if (reset)
      enc10bit_r <= 10'b0;
   else if (send_out_trig  == 1)
      begin
        if (reverse_10b_dbg == 1)
        enc10bit_r <= enc10bit_out;
       else
        enc10bit_r <= {enc10bit_out[0],enc10bit_out[1],enc10bit_out[2],enc10bit_out[3],enc10bit_out[4],enc10bit_out[5],enc10bit_out[6],enc10bit_out[7],enc10bit_out[8],enc10bit_out[9]};                                  
      end
  end

always @(posedge clk_40)
  begin
     if (send_out_trig == 1)
        send_count <= 3'b0; 
     else  
      send_count <= send_count + 1'b1;
  end


always@(posedge clk_40)
if (reset)
word10b <= 0;
else
begin
  if (data_10b_en ==1)
  word10b <= data_10b_in;
  else
  word10b <= enc10bit_out_dbg;     
end






// HDL Embedded Text Block 7 Data_rdy_signal1
//Save data into a buffer
assign tx_elink2bit_gen = rx_elink2bit_gen; // test the elink_to_fifo 2 bits
assign tx_elink1bit_gen = rx_elink1bit_gen; // test the elink_to_fifo 1 bit
assign data_rec_in = gen_edata_76bit;
assign reset = !rst;  












































































































































// HDL Embedded Text Block 8 Data_rdy_signal2
// HDL Embedded Text Block 2 data_loader1
// data_loader 1
//sel din process
assign request_trig = (sel_cnt == max_cnt+1) ? 1:0;
assign dout_r_10b ={delimeter_r,dout_r}; 
always @(posedge clk_40)
begin 
  if(rst == 1)
  case (sel_cnt)
    5'b0 : begin 
      dout_r  <= 8'h00;
      delimeter_r  <= 2'b11;
    end
    5'b00001 : begin 
      dout_r  <= 8'h00;
      delimeter_r  <= 2'b10;
    end
    5'b00010 : begin 
      dout_r  <= 8'hDE;
      delimeter_r  <= 2'b00;
    end
    5'b00011 : begin 
      dout_r  <= 8'hAD;
      delimeter_r <= 2'b00;
    end
    5'b00100 : begin 
      dout_r  <= 8'hBE;
      delimeter_r  <= 2'b00;
    end
    5'b00101 : begin 
      dout_r  <= 8'hEF;
      delimeter_r <= 2'b00;
    end
    5'b00110 : begin 
      dout_r  <=8'hDE;
      delimeter_r  <=2'b00;
    end
    5'b00111 : begin 
      dout_r  <= 8'hAD;
      delimeter_r  <= 2'b00;
    end
    5'b01000 : begin 
      dout_r  <= 8'hBE;
      delimeter_r  <= 2'b00;
    end
    5'b01001 : begin 
      dout_r  <= 8'hEF;
      delimeter_r <= 2'b00;
    end
    5'b01010 : begin 
      dout_r  <= 8'hDE;
      delimeter_r  <= 2'b00;
    end
    5'b01011 : begin 
      dout_r  <= {4'hA,4'h0}; 
      delimeter_r <= 2'b00;
    end
    
    5'b01100 : begin 
      dout_r  <=8'h00;
      delimeter_r  <=2'b01;
    end
    default : begin 
      dout_r  <=8'h0;
      delimeter_r  <=2'b11;
    end
    
  endcase
  else
  begin
    dout_r <= 8'h0;
    delimeter_r  <=2'b11;
  end
end                        







































































































































endmodule // emci_decoder

