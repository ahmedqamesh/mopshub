//
// Module mopshub_testbench.sync_bytes_SM.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 18:11:57 04/25/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module sync_bytes_SM( 
   // Port Declarations
   input   wire           clk_usr, 
   input   wire           fifo_empty, 
   input   wire    [9:0]  fifo_in, 
   input   wire           rst, 
   input   wire           test_elink_rx, 
   input   wire           test_elink_tx, 
   output  reg            done,           // dbg
   output  reg     [9:0]  fifo_out, 
   output  reg            r_en, 
   output  reg     [2:0]  sel_cnt, 
   output  reg            w_en
);


// Internal Declarations


// Declare any pre-registered internal signals
reg [2:0] sel_cnt_cld;

// Module Declarations
reg [7:0] Kchar_comma;  //K28.5
reg [7:0] Kchar_eop;  //K28.6
reg [7:0] Kchar_sop;  //K28.1
reg [2:0] max_byte;  // # of wen to send starting from 000 (011: 4 x wen)
reg [2:0] state_o;  

// State encoding
parameter 
          ST_IDLE   = 5'd0,
          ST_SOF    = 5'd1,
          ST_RESET  = 5'd2,
          ST_BYTE_0 = 5'd3,
          ST_EOF    = 5'd4,
          ST_DONE   = 5'd5,
          ST_BYTE_1 = 5'd6,
          ST_BYTE_2 = 5'd7,
          ST_BYTE_3 = 5'd8,
          ST_SOF1   = 5'd9,
          ST_BYTE_4 = 5'd10,
          ST_BYTE_7 = 5'd11,
          ST_EOF1   = 5'd12,
          ST_SOF2   = 5'd13,
          ST_EOF2   = 5'd14,
          ST_BYTE_5 = 5'd15,
          ST_BYTE_6 = 5'd16,
          READ      = 5'd17;

reg [4:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   Kchar_eop, 
   Kchar_sop, 
   current_state, 
   fifo_empty, 
   fifo_in, 
   max_byte, 
   sel_cnt_cld, 
   test_elink_rx, 
   test_elink_tx
)
begin : next_state_block_proc
   case (current_state) 
      ST_IDLE: begin
         if (test_elink_rx == 1)
            next_state = ST_SOF;
         else if (test_elink_tx == 1)
            next_state = ST_SOF1;
         else
            next_state = ST_IDLE;
      end
      ST_SOF: begin
         if (fifo_in ==Kchar_sop)
            next_state = ST_BYTE_0;
         else
            next_state = ST_SOF;
      end
      ST_RESET: begin
         next_state = ST_IDLE;
      end
      ST_BYTE_0: begin
         next_state = ST_BYTE_1;
      end
      ST_EOF: begin
         next_state = ST_DONE;
      end
      ST_DONE: begin
         next_state = ST_RESET;
      end
      ST_BYTE_1: begin
         next_state = ST_BYTE_2;
      end
      ST_BYTE_2: begin
         next_state = ST_BYTE_3;
      end
      ST_BYTE_3: begin
         if ((fifo_in ==Kchar_eop)&&(sel_cnt_cld == max_byte))
            next_state = ST_EOF;
         else
            next_state = ST_BYTE_3;
      end
      ST_SOF1: begin
         next_state = ST_SOF2;
      end
      ST_BYTE_4: begin
         next_state = ST_BYTE_5;
      end
      ST_BYTE_7: begin
         if (sel_cnt_cld >= max_byte && fifo_empty ==1)
            next_state = ST_EOF1;
         else if (sel_cnt_cld >= max_byte && fifo_empty ==0)
            next_state = READ;
         else
            next_state = ST_BYTE_4;
      end
      ST_EOF1: begin
         next_state = ST_EOF2;
      end
      ST_SOF2: begin
         next_state = ST_BYTE_6;
      end
      ST_EOF2: begin
         next_state = ST_DONE;
      end
      ST_BYTE_5: begin
         next_state = ST_BYTE_7;
      end
      ST_BYTE_6: begin
         next_state = ST_BYTE_4;
      end
      READ: begin
         if (fifo_empty ==1)
            next_state = ST_EOF2;
         else
            next_state = READ;
      end
      default: 
         next_state = ST_IDLE;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   Kchar_comma, 
   Kchar_eop, 
   Kchar_sop, 
   current_state, 
   sel_cnt_cld
)
begin : output_block_proc
   // Default Assignment
   done = 0;
   fifo_out = 8'b10111100;
   r_en = 0;
   w_en = 0;
   // Default Assignment To Internals
   Kchar_comma = 8'b10111100;
   Kchar_eop = 8'b11011100;
   Kchar_sop = 8'b00111100;
   max_byte = 3'b100;

   // Combined Actions
   case (current_state) 
      ST_IDLE: begin
         fifo_out={2'b11,Kchar_comma};
      end
      ST_RESET: begin
         done =0;
         fifo_out={2'b11,Kchar_comma};
         w_en= 1'b1;
      end
      ST_DONE: begin
         done =1;
         fifo_out={2'b11,Kchar_comma};
         w_en= 1'b0;
      end
      ST_SOF1: begin
         fifo_out={2'b10,Kchar_sop};
         w_en= 1'b0;
      end
      ST_BYTE_4: begin
         fifo_out = {6'b0,sel_cnt_cld};
         w_en= 1'b1;
      end
      ST_BYTE_7: begin
         fifo_out = {6'b0,sel_cnt_cld};
      end
      ST_EOF1: begin
         fifo_out={2'b01,Kchar_eop};
         w_en= 1'b0;
      end
      ST_SOF2: begin
         fifo_out={2'b10,Kchar_sop};
         w_en= 1'b1;
      end
      ST_EOF2: begin
         fifo_out={2'b01,Kchar_eop};
         w_en= 1'b1;
      end
      ST_BYTE_5: begin
         fifo_out = {6'b0,sel_cnt_cld};
      end
      ST_BYTE_6: begin
         fifo_out = {6'b0,sel_cnt_cld};
      end
      READ: begin
         fifo_out={2'b01,Kchar_eop};
         w_en= 1'b0;
         r_en= 1'b1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk_usr, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_IDLE;
   end
   else 
   begin
      current_state <= next_state;

      // Combined Actions
      case (current_state) 
         ST_IDLE: begin
            state_o     = 3'b000;
            sel_cnt_cld     = 0;
         end
         ST_SOF: begin
            state_o  = 3'b001;
         end
         ST_RESET: begin
            state_o     = 3'b000;
            state_o     = 3'b111;
         end
         ST_BYTE_0: begin
            state_o     = 3'b010;
            sel_cnt_cld = sel_cnt_cld +1;
         end
         ST_EOF: begin
            state_o = 3'b110;
         end
         ST_DONE: begin
            state_o = 3'b111;
         end
         ST_BYTE_1: begin
            state_o     = 3'b011;
            sel_cnt_cld = sel_cnt_cld +1;
         end
         ST_BYTE_2: begin
            state_o     = 3'b100;
            sel_cnt_cld = sel_cnt_cld +1;
         end
         ST_BYTE_3: begin
            state_o     = 3'b101;
            sel_cnt_cld = sel_cnt_cld +1;
         end
         ST_SOF1: begin
            state_o  = 3'b001;
         end
         ST_BYTE_4: begin
            state_o     = 3'b010;
            sel_cnt_cld = sel_cnt_cld +1;
         end
         ST_BYTE_7: begin
            state_o     = 3'b101;
            sel_cnt_cld = sel_cnt_cld;
         end
         ST_EOF1: begin
            state_o = 3'b110;
         end
         ST_SOF2: begin
            state_o  = 3'b001;
         end
         ST_EOF2: begin
            state_o = 3'b110;
         end
         ST_BYTE_5: begin
            state_o     = 3'b010;
            sel_cnt_cld = sel_cnt_cld;
         end
         ST_BYTE_6: begin
            state_o     = 3'b010;
            sel_cnt_cld = sel_cnt_cld;
         end
         READ: begin
            state_o = 3'b110;
         end
      endcase
   end
end // Clocked Block

// Concurrent Statements
// Clocked output assignments
always @(
   sel_cnt_cld
)
begin : clocked_output_proc
   sel_cnt = sel_cnt_cld;
end
endmodule // sync_bytes_SM
