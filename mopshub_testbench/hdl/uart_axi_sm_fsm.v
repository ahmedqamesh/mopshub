//
// Module mopshub_testbench.uart_axi_sm.fsm
//
// Created:
//          by - dcs.dcs (chipdev2.physik.uni-wuppertal.de)
//          at - 10:07:57 07/05/23
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module uart_axi_sm( 
   // Port Declarations
   input   wire            axi_uart_test, 
   input   wire            clk, 
   input   wire            fifo_dbg_out_rdy, 
   input   wire            out_rx_dv, 
   input   wire            rst, 
   input   wire            rx_uart_addr_ready, 
   input   wire            rx_uart_valid, 
   input   wire            tx_uart_ready, 
   input   wire            w_tx_done, 
   output  reg             fifo_dbg_out_read, 
   output  reg             in_tx_dv, 
   output  reg     [3:0]   rx_uart_addr, 
   output  reg             rx_uart_addr_valid, 
   output  reg             rx_uart_ready, 
   output  reg             select_dbg_sm, 
   output  reg     [3:0]   tx_uart_addr, 
   output  reg     [31:0]  tx_uart_data, 
   output  reg             tx_uart_valid, 
   output  reg             write_dbg_fifo
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_Reset      = 4'd0,
          Send_tx0_0    = 4'd1,
          Send_tx0_1    = 4'd2,
          Send_tx0_2    = 4'd3,
          Send_tx0_3    = 4'd4,
          Enable_rx     = 4'd5,
          Ack_uart_rx   = 4'd6,
          wait_slave    = 4'd7,
          s0            = 4'd8,
          s1            = 4'd9,
          ST_SEL_SM     = 4'd10,
          ST_write_fifo = 4'd11,
          ST_read_fifo  = 4'd12,
          ST_write_uart = 4'd13,
          ST_write_done = 4'd14,
          ST_wait       = 4'd15;

reg [3:0] current_state, next_state;

// Wait State Signals
reg [10:0] csm_timer;
reg [10:0] csm_next_timer;
reg        csm_timeout;
reg        csm_to_s0;
reg        csm_to_s1;
reg        csm_to_ST_wait;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   axi_uart_test, 
   csm_timeout, 
   current_state, 
   fifo_dbg_out_rdy, 
   out_rx_dv, 
   rx_uart_addr_ready, 
   rx_uart_valid, 
   tx_uart_ready, 
   w_tx_done
)
begin : next_state_block_proc
   // Default assignments to Wait State entry flags
   csm_to_s0 = 1'b0;
   csm_to_s1 = 1'b0;
   csm_to_ST_wait = 1'b0;
   case (current_state) 
      ST_Reset: begin
         if (out_rx_dv ==1'b1)
            next_state = ST_SEL_SM;
         else if (axi_uart_test)
            next_state = Enable_rx;
         else
            next_state = ST_Reset;
      end
      Send_tx0_0: begin
         if (tx_uart_ready  ==1)
            next_state = Send_tx0_1;
         else
            next_state = Send_tx0_0;
      end
      Send_tx0_1: begin
         if (tx_uart_ready ==0)
            next_state = Send_tx0_2;
         else
            next_state = Send_tx0_1;
      end
      Send_tx0_2: begin
         if (tx_uart_ready  ==1)
            next_state = Send_tx0_3;
         else
            next_state = Send_tx0_2;
      end
      Send_tx0_3: begin
         if (tx_uart_ready ==0) begin
            next_state = s1;
            csm_to_s1 = 1'b1;
         end
         else
            next_state = Send_tx0_3;
      end
      Enable_rx: begin
         if (rx_uart_addr_ready ==1)
            next_state = wait_slave;
         else
            next_state = Enable_rx;
      end
      Ack_uart_rx: begin
         next_state = s0;
         csm_to_s0 = 1'b1;
      end
      wait_slave: begin
         if (rx_uart_valid ==1)
            next_state = Ack_uart_rx;
         else
            next_state = wait_slave;
      end
      s0: begin
         if (csm_timeout)
            next_state = Send_tx0_0;
         else
            next_state = s0;
      end
      s1: begin
         if (csm_timeout)
            next_state = ST_Reset;
         else
            next_state = s1;
      end
      ST_SEL_SM: begin
         next_state = ST_write_fifo;
      end
      ST_write_fifo: begin
         if (fifo_dbg_out_rdy ==1'b1) begin
            next_state = ST_wait;
            csm_to_ST_wait = 1'b1;
         end
         else
            next_state = ST_write_fifo;
      end
      ST_read_fifo: begin
         next_state = ST_write_uart;
      end
      ST_write_uart: begin
         if (w_tx_done ==1'b1)
            next_state = ST_write_done;
         else
            next_state = ST_write_uart;
      end
      ST_write_done: begin
         if (w_tx_done ==1'b0)
            next_state = ST_Reset;
         else
            next_state = ST_write_done;
      end
      ST_wait: begin
         if (csm_timeout)
            next_state = ST_read_fifo;
         else
            next_state = ST_wait;
      end
      default: 
         next_state = ST_Reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   fifo_dbg_out_read = 0;
   in_tx_dv = 0;
   rx_uart_addr = 0;
   rx_uart_addr_valid = 0;
   rx_uart_ready = 0;
   select_dbg_sm = 0;
   tx_uart_addr = 4'b0;
   tx_uart_data = 8'b0;
   tx_uart_valid = 0;
   write_dbg_fifo = 0;

   // Combined Actions
   case (current_state) 
      Send_tx0_0: begin
         tx_uart_data =32'hDE;
         tx_uart_valid = 1;
         tx_uart_addr = 4'h04;
      end
      Send_tx0_1: begin
         tx_uart_data =32'hDE;
      end
      Send_tx0_2: begin
         tx_uart_data =32'hAD;
         tx_uart_valid = 1;
         tx_uart_addr = 4'h04;
      end
      Send_tx0_3: begin
         tx_uart_data =32'hAD;
      end
      Enable_rx: begin
         rx_uart_addr_valid =1;
         rx_uart_addr = 4'h00;
      end
      Ack_uart_rx: begin
         rx_uart_ready =1;
         rx_uart_addr = 4'h0;
      end
      wait_slave: begin
         rx_uart_ready =1;
         rx_uart_addr = 4'h0;
      end
      s1: begin
         tx_uart_data =32'hAD;
      end
      ST_SEL_SM: begin
         select_dbg_sm = 1'b1;
      end
      ST_write_fifo: begin
         write_dbg_fifo = 1'b1;
      end
      ST_read_fifo: begin
         fifo_dbg_out_read =1'b1;
      end
      ST_write_uart: begin
         in_tx_dv = 1'b1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_Reset;
      csm_timer <= 11'd0;
   end
   else 
   begin
      current_state <= next_state;
      csm_timer <= csm_next_timer;
   end
end // Clocked Block

//-----------------------------------------------------------------
// Wait state logic for machine csm
//-----------------------------------------------------------------
always @(
   csm_timer,
   csm_to_s0,
   csm_to_s1,
   csm_to_ST_wait
)
begin : csm_wait_block_proc
   csm_timeout = (csm_timer == 11'd0);
   if (csm_to_s0 == 1'b1) begin
      csm_next_timer = 11'd1999;  //no cycles(2000)-1=1999
   end
   else if (csm_to_s1 == 1'b1) begin
      csm_next_timer = 11'd1999;  //no cycles(2000)-1=1999
   end
   else if (csm_to_ST_wait == 1'b1) begin
      csm_next_timer = 11'd7;  //no cycles(8)-1=7
   end
   else begin
      csm_next_timer = (csm_timeout)? 11'd0: (csm_timer - 11'd1);
   end
end // Wait State Block
endmodule // uart_axi_sm
