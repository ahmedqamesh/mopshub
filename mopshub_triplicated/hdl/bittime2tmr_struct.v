//
// Module mopshub_triplicated.bittime2TMR.struct
//
// Created:
//          by - dcs.dcs (localhost)
//          at - 09:18:04 05/10/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//


module bittime2TMR #(
   // synopsys template
   parameter normal      = 4'd0,
   parameter hardset     = 4'd1,
   parameter stretchok   = 4'd2,
   parameter stretchnok  = 4'd3,
   parameter slimok      = 4'd4,
   parameter slimnok     = 4'd5,
   parameter sndprescnt  = 4'd6,
   parameter samplepoint = 4'd7,
   parameter resetstate  = 4'd8
)
( 
   // Port Declarations
   input   wire           clockA, 
   input   wire           clockB, 
   input   wire           clockC, 
   input   wire           Prescale_ENA, 
   input   wire           Prescale_ENB, 
   input   wire           Prescale_ENC, 
   input   wire           resetA, 
   input   wire           resetB, 
   input   wire           resetC, 
   input   wire           hardsyncA, 
   input   wire           hardsyncB, 
   input   wire           hardsyncC, 
   input   wire           notnullA, 
   input   wire           notnullB, 
   input   wire           notnullC, 
   input   wire           gtsjwp1A, 
   input   wire           gtsjwp1B, 
   input   wire           gtsjwp1C, 
   input   wire           gttseg1p1A, 
   input   wire           gttseg1p1B, 
   input   wire           gttseg1p1C, 
   input   wire           cpsgetseg1ptseg2p2A, 
   input   wire           cpsgetseg1ptseg2p2B, 
   input   wire           cpsgetseg1ptseg2p2C, 
   input   wire           cetseg1ptseg2p1A, 
   input   wire           cetseg1ptseg2p1B, 
   input   wire           cetseg1ptseg2p1C, 
   input   wire           countesmpltimeA, 
   input   wire           countesmpltimeB, 
   input   wire           countesmpltimeC, 
   input   wire           pufferA, 
   input   wire           pufferB, 
   input   wire           pufferC, 
   input   wire           rxA, 
   input   wire           rxB, 
   input   wire           rxC, 
   output  reg            incrementA, 
   output  reg            incrementB, 
   output  reg            incrementC, 
   output  reg            setctzeroA, 
   output  reg            setctzeroB, 
   output  reg            setctzeroC, 
   output  reg            setctotwoA, 
   output  reg            setctotwoB, 
   output  reg            setctotwoC, 
   output  reg            sendpointA, 
   output  reg            sendpointB, 
   output  reg            sendpointC, 
   output  reg            smplpointA, 
   output  reg            smplpointB, 
   output  reg            smplpointC, 
   output  reg     [1:0]  smpldbit_reg_ctrlA, 
   output  reg     [1:0]  smpldbit_reg_ctrlB, 
   output  reg     [1:0]  smpldbit_reg_ctrlC, 
   output  reg     [1:0]  tseg_reg_ctrlA, 
   output  reg     [1:0]  tseg_reg_ctrlB, 
   output  reg     [1:0]  tseg_reg_ctrlC, 
   output  reg     [3:0]  bitstA, 
   output  reg     [3:0]  bitstB, 
   output  reg     [3:0]  bitstC
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wor         current_stateTmrErrorC;
wire  [3:0] current_stateVotedC;
wor         current_stateTmrErrorB;
wire  [3:0] current_stateVotedB;
wor         current_stateTmrErrorA;
wire  [3:0] current_stateVotedA;
reg   [3:0] current_stateA;
reg   [3:0] current_stateB;
reg   [3:0] next_stateB;
reg   [3:0] current_stateC;
reg   [3:0] next_stateC;


// Instances 
majorityVoter #(4) current_stateVoterA( 
   .inA    (current_stateA), 
   .inB    (current_stateB), 
   .inC    (current_stateC), 
   .out    (current_stateVotedA), 
   .tmrErr (current_stateTmrErrorA)
); 

majorityVoter #(4) current_stateVoterB( 
   .inA    (current_stateA), 
   .inB    (current_stateB), 
   .inC    (current_stateC), 
   .out    (current_stateVotedB), 
   .tmrErr (current_stateTmrErrorB)
); 

majorityVoter #(4) current_stateVoterC( 
   .inA    (current_stateA), 
   .inB    (current_stateB), 
   .inC    (current_stateC), 
   .out    (current_stateVotedC), 
   .tmrErr (current_stateTmrErrorC)
); 

// HDL Embedded Text Block 1 eb1
always @( posedge clockA or negedge resetA )
  begin
    if (resetA==1'b0)
      current_stateA <= resetstate;
    else
      if (Prescale_ENA==1'b1)
        current_stateA <= next_stateA;
      else
        current_stateA <= current_stateVotedA;
  end
// HDL Embedded Text Block 2 eb2
always @( posedge clockB or negedge resetB )
  begin
    if (resetB==1'b0)
      current_stateB <= resetstate;
    else
      if (Prescale_ENB==1'b1)
        current_stateB <= next_stateB;
      else
        current_stateB <= current_stateVotedB;
  end
// HDL Embedded Text Block 3 eb3
always @( posedge clockC or negedge resetC )
  begin
    if (resetC==1'b0)
      current_stateC <= resetstate;
    else
      if (Prescale_ENC==1'b1)
        current_stateC <= next_stateC;
      else
        current_stateC <= current_stateVotedC;
  end
// HDL Embedded Text Block 4 eb4
always @( current_stateVotedA )
  begin
    case (current_stateVotedA)
      normal : bitstA <= 4'h0;
      hardset : bitstA <= 4'h1;
      stretchok : bitstA <= 4'h2;
      stretchnok : bitstA <= 4'h3;
      slimok : bitstA <= 4'h4;
      slimnok : bitstA <= 4'h5;
      sndprescnt : bitstA <= 4'h6;
      samplepoint : bitstA <= 4'h7;
      resetstate : bitstA <= 4'h8;
      default : bitstA <= 4'ha;
    endcase
  end
// HDL Embedded Text Block 5 eb5
always @( current_stateVotedB )
  begin
    case (current_stateVotedB)
      normal : bitstB <= 4'h0;
      hardset : bitstB <= 4'h1;
      stretchok : bitstB <= 4'h2;
      stretchnok : bitstB <= 4'h3;
      slimok : bitstB <= 4'h4;
      slimnok : bitstB <= 4'h5;
      sndprescnt : bitstB <= 4'h6;
      samplepoint : bitstB <= 4'h7;
      resetstate : bitstB <= 4'h8;
      default : bitstB <= 4'ha;
    endcase
  end
// HDL Embedded Text Block 6 eb6
always @( current_stateVotedC )
  begin
    case (current_stateVotedC)
      normal : bitstC <= 4'h0;
      hardset : bitstC <= 4'h1;
      stretchok : bitstC <= 4'h2;
      stretchnok : bitstC <= 4'h3;
      slimok : bitstC <= 4'h4;
      slimnok : bitstC <= 4'h5;
      sndprescnt : bitstC <= 4'h6;
      samplepoint : bitstC <= 4'h7;
      resetstate : bitstC <= 4'h8;
      default : bitstC <= 4'ha;
    endcase
  end
// HDL Embedded Text Block 7 eb7
always @( current_stateVotedA or hardsyncA or rxA or pufferA or notnullA or gtsjwp1A or gttseg1p1A or cpsgetseg1ptseg2p2A or cetseg1ptseg2p1A or countesmpltimeA )
  begin
    case (current_stateVotedA)
      resetstate : 
        begin
          incrementA <= 1'b0;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b01;
          tseg_reg_ctrlA <= 2'b01;
          next_stateA <= hardset;
        end
      normal : 
        begin
          incrementA <= 1'b1;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b00;
          if (rxA==1'b0&&pufferA==1'b1)
            if (hardsyncA==1)
              next_stateA <= hardset;
            else
              if (notnullA==1'b1&&gtsjwp1A==1'b0)
                next_stateA <= stretchok;
              else
                if (gtsjwp1A==1'b1&&gttseg1p1A==1'b0)
                  next_stateA <= stretchnok;
                else
                  if (gttseg1p1A==1'b1&&cpsgetseg1ptseg2p2A==1'b0)
                    next_stateA <= slimnok;
                  else
                    if (cpsgetseg1ptseg2p2A==1'b1)
                      next_stateA <= slimok;
                    else
                      next_stateA <= normal;
          else
            if (cetseg1ptseg2p1A==1'b1)
              next_stateA <= sndprescnt;
            else
              if (countesmpltimeA==1'b1)
                next_stateA <= samplepoint;
              else
                next_stateA <= normal;
        end
      hardset : 
        begin
          incrementA <= 1'b0;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b1;
          sendpointA <= 1'b1;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b01;
          next_stateA <= normal;
        end
      sndprescnt : 
        begin
          incrementA <= 1'b0;
          setctzeroA <= 1'b1;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b1;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b01;
          if (rxA==1'b0&&pufferA==1'b1)
            if (hardsyncA==1)
              next_stateA <= hardset;
            else
              next_stateA <= slimok;
          else
            next_stateA <= normal;
        end
      stretchok : 
        begin
          incrementA <= 1'b1;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b10;
          next_stateA <= normal;
        end
      stretchnok : 
        begin
          incrementA <= 1'b1;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b11;
          next_stateA <= normal;
        end
      slimok : 
        begin
          incrementA <= 1'b0;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b1;
          sendpointA <= 1'b1;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b01;
          next_stateA <= normal;
        end
      slimnok : 
        begin
          incrementA <= 1'b1;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b00;
          if (cpsgetseg1ptseg2p2A==1'b1)
            next_stateA <= slimok;
          else
            next_stateA <= slimnok;
        end
      samplepoint : 
        begin
          incrementA <= 1'b1;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b1;
          smpldbit_reg_ctrlA <= 2'b10;
          tseg_reg_ctrlA <= 2'b00;
          if (rxA==1'b0&&pufferA==1'b1)
            if (hardsyncA==1)
              next_stateA <= hardset;
            else
              if (cpsgetseg1ptseg2p2A==1'b1)
                next_stateA <= slimok;
              else
                next_stateA <= slimnok;
          else
            next_stateA <= normal;
        end
      default : 
        begin
          incrementA <= 1'b0;
          setctzeroA <= 1'b0;
          setctotwoA <= 1'b0;
          sendpointA <= 1'b0;
          smplpointA <= 1'b0;
          smpldbit_reg_ctrlA <= 2'b00;
          tseg_reg_ctrlA <= 2'b00;
          next_stateA <= current_stateVotedA;
        end
    endcase
  end
// HDL Embedded Text Block 8 eb8
always @( current_stateVotedB or hardsyncB or rxB or pufferB or notnullB or gtsjwp1B or gttseg1p1B or cpsgetseg1ptseg2p2B or cetseg1ptseg2p1B or countesmpltimeB )
  begin
    case (current_stateVotedB)
      resetstate : 
        begin
          incrementB <= 1'b0;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b01;
          tseg_reg_ctrlB <= 2'b01;
          next_stateB <= hardset;
        end
      normal : 
        begin
          incrementB <= 1'b1;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b00;
          if (rxB==1'b0&&pufferB==1'b1)
            if (hardsyncB==1)
              next_stateB <= hardset;
            else
              if (notnullB==1'b1&&gtsjwp1B==1'b0)
                next_stateB <= stretchok;
              else
                if (gtsjwp1B==1'b1&&gttseg1p1B==1'b0)
                  next_stateB <= stretchnok;
                else
                  if (gttseg1p1B==1'b1&&cpsgetseg1ptseg2p2B==1'b0)
                    next_stateB <= slimnok;
                  else
                    if (cpsgetseg1ptseg2p2B==1'b1)
                      next_stateB <= slimok;
                    else
                      next_stateB <= normal;
          else
            if (cetseg1ptseg2p1B==1'b1)
              next_stateB <= sndprescnt;
            else
              if (countesmpltimeB==1'b1)
                next_stateB <= samplepoint;
              else
                next_stateB <= normal;
        end
      hardset : 
        begin
          incrementB <= 1'b0;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b1;
          sendpointB <= 1'b1;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b01;
          next_stateB <= normal;
        end
      sndprescnt : 
        begin
          incrementB <= 1'b0;
          setctzeroB <= 1'b1;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b1;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b01;
          if (rxB==1'b0&&pufferB==1'b1)
            if (hardsyncB==1)
              next_stateB <= hardset;
            else
              next_stateB <= slimok;
          else
            next_stateB <= normal;
        end
      stretchok : 
        begin
          incrementB <= 1'b1;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b10;
          next_stateB <= normal;
        end
      stretchnok : 
        begin
          incrementB <= 1'b1;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b11;
          next_stateB <= normal;
        end
      slimok : 
        begin
          incrementB <= 1'b0;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b1;
          sendpointB <= 1'b1;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b01;
          next_stateB <= normal;
        end
      slimnok : 
        begin
          incrementB <= 1'b1;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b00;
          if (cpsgetseg1ptseg2p2B==1'b1)
            next_stateB <= slimok;
          else
            next_stateB <= slimnok;
        end
      samplepoint : 
        begin
          incrementB <= 1'b1;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b1;
          smpldbit_reg_ctrlB <= 2'b10;
          tseg_reg_ctrlB <= 2'b00;
          if (rxB==1'b0&&pufferB==1'b1)
            if (hardsyncB==1)
              next_stateB <= hardset;
            else
              if (cpsgetseg1ptseg2p2B==1'b1)
                next_stateB <= slimok;
              else
                next_stateB <= slimnok;
          else
            next_stateB <= normal;
        end
      default : 
        begin
          incrementB <= 1'b0;
          setctzeroB <= 1'b0;
          setctotwoB <= 1'b0;
          sendpointB <= 1'b0;
          smplpointB <= 1'b0;
          smpldbit_reg_ctrlB <= 2'b00;
          tseg_reg_ctrlB <= 2'b00;
          next_stateB <= current_stateVotedB;
        end
    endcase
  end
// HDL Embedded Text Block 9 eb9
always @( current_stateVotedC or hardsyncC or rxC or pufferC or notnullC or gtsjwp1C or gttseg1p1C or cpsgetseg1ptseg2p2C or cetseg1ptseg2p1C or countesmpltimeC )
  begin
    case (current_stateVotedC)
      resetstate : 
        begin
          incrementC <= 1'b0;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b01;
          tseg_reg_ctrlC <= 2'b01;
          next_stateC <= hardset;
        end
      normal : 
        begin
          incrementC <= 1'b1;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b00;
          if (rxC==1'b0&&pufferC==1'b1)
            if (hardsyncC==1)
              next_stateC <= hardset;
            else
              if (notnullC==1'b1&&gtsjwp1C==1'b0)
                next_stateC <= stretchok;
              else
                if (gtsjwp1C==1'b1&&gttseg1p1C==1'b0)
                  next_stateC <= stretchnok;
                else
                  if (gttseg1p1C==1'b1&&cpsgetseg1ptseg2p2C==1'b0)
                    next_stateC <= slimnok;
                  else
                    if (cpsgetseg1ptseg2p2C==1'b1)
                      next_stateC <= slimok;
                    else
                      next_stateC <= normal;
          else
            if (cetseg1ptseg2p1C==1'b1)
              next_stateC <= sndprescnt;
            else
              if (countesmpltimeC==1'b1)
                next_stateC <= samplepoint;
              else
                next_stateC <= normal;
        end
      hardset : 
        begin
          incrementC <= 1'b0;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b1;
          sendpointC <= 1'b1;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b01;
          next_stateC <= normal;
        end
      sndprescnt : 
        begin
          incrementC <= 1'b0;
          setctzeroC <= 1'b1;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b1;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b01;
          if (rxC==1'b0&&pufferC==1'b1)
            if (hardsyncC==1)
              next_stateC <= hardset;
            else
              next_stateC <= slimok;
          else
            next_stateC <= normal;
        end
      stretchok : 
        begin
          incrementC <= 1'b1;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b10;
          next_stateC <= normal;
        end
      stretchnok : 
        begin
          incrementC <= 1'b1;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b11;
          next_stateC <= normal;
        end
      slimok : 
        begin
          incrementC <= 1'b0;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b1;
          sendpointC <= 1'b1;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b01;
          next_stateC <= normal;
        end
      slimnok : 
        begin
          incrementC <= 1'b1;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b00;
          if (cpsgetseg1ptseg2p2C==1'b1)
            next_stateC <= slimok;
          else
            next_stateC <= slimnok;
        end
      samplepoint : 
        begin
          incrementC <= 1'b1;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b1;
          smpldbit_reg_ctrlC <= 2'b10;
          tseg_reg_ctrlC <= 2'b00;
          if (rxC==1'b0&&pufferC==1'b1)
            if (hardsyncC==1)
              next_stateC <= hardset;
            else
              if (cpsgetseg1ptseg2p2C==1'b1)
                next_stateC <= slimok;
              else
                next_stateC <= slimnok;
          else
            next_stateC <= normal;
        end
      default : 
        begin
          incrementC <= 1'b0;
          setctzeroC <= 1'b0;
          setctotwoC <= 1'b0;
          sendpointC <= 1'b0;
          smplpointC <= 1'b0;
          smpldbit_reg_ctrlC <= 2'b00;
          tseg_reg_ctrlC <= 2'b00;
          next_stateC <= current_stateVotedC;
        end
    endcase
  end

endmodule // bittime2TMR

