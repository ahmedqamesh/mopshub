/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/Control_FSMTMR.v                                                              *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:27:57                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: Control_FSM.v                                                                          *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? Control_FSM.v)        *
 *           Modification time : 2022-12-04 15:41:31.638209                                         *
 *           File Size         : 2221                                                               *
 *           MD5 hash          : 6edf04175f4d6d4d6bc7ebc8eb5f35c9                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module Control_FSMTMR(
  input wire  CLK ,
  input wire  Reset ,
  input wire  Rx ,
  input wire  Puffer ,
  input wire  active ,
  input wire [3:0] E1 ,
  output reg [2:0] ctrl ,
  output reg  Enable 
);
parameter [2:0] Normal =3'd0;
parameter [2:0] ResetZ =3'd1;
parameter [2:0] NegPhasFehler =3'd2;
parameter [2:0] PosPhasFehler =3'd3;
parameter [2:0] Synchronisation =3'd4;
parameter [2:0] Idle =3'd5;
wire [3:0] next_stateC;
wire [3:0] next_stateB;
wire [3:0] next_stateA;
wire ResetC;
wire ResetB;
wire ResetA;
wire CLKC;
wire CLKB;
wire CLKA;
wor current_stateTmrError;
wire [3:0] current_state;
reg  [3:0] current_stateA ;
reg  [3:0] current_stateB ;
reg  [3:0] current_stateC ;
reg  [3:0] next_state ;
wire [3:0] current_stateV =  current_state;

always @( posedge CLKA or negedge ResetA )
  begin
    if (ResetA==1'b0)
      current_stateA <= ResetZ;
    else
      current_stateA <= next_stateA;
  end

always @( posedge CLKB or negedge ResetB )
  begin
    if (ResetB==1'b0)
      current_stateB <= ResetZ;
    else
      current_stateB <= next_stateB;
  end

always @( posedge CLKC or negedge ResetC )
  begin
    if (ResetC==1'b0)
      current_stateC <= ResetZ;
    else
      current_stateC <= next_stateC;
  end

always @( current_stateV or Rx or Puffer or E1 or active )
  begin
    Enable =  0;
    case (current_stateV)
      ResetZ : 
        begin
          ctrl =  3'd0;
          Enable =  0;
          next_state =  Idle;
        end
      Idle : 
        begin
          ctrl =  3'd0;
          Enable =  0;
          if ((~ ( Rx==1'b0&&Puffer==1'b1 ) )&&active==1'b1)
            next_state =  Normal;
          else
            next_state =  Idle;
        end
      Normal : 
        begin
          ctrl =  3'd4;
          Enable =  0;
          if (active==1'b0)
            next_state =  Idle;
          else
            if (Rx==1'b0&&Puffer==1'b1&&E1<=5&&E1>0)
              begin
                next_state =  PosPhasFehler;
              end
            else
              if (Rx==1'b0&&Puffer==1'b1&&E1>5)
                begin
                  next_state =  NegPhasFehler;
                end
              else
                if (Rx==1'b0&&Puffer==1'b1&&E1==0)
                  begin
                    next_state =  Synchronisation;
                  end
                else
                  next_state =  Normal;
        end
      PosPhasFehler : 
        begin
          ctrl =  3'd1;
          Enable =  1;
          next_state =  Idle;
        end
      NegPhasFehler : 
        begin
          ctrl =  3'd2;
          Enable =  1;
          next_state =  Idle;
        end
      Synchronisation : 
        begin
          ctrl =  3'd3;
          Enable =  1;
          next_state =  Idle;
        end
      default : 
        begin
          ctrl =  3'd0;
          Enable =  0;
          next_state =  ResetZ;
        end
    endcase
  end

majorityVoter #(.WIDTH(4)) current_stateVoter (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_state),
    .tmrErr(current_stateTmrError)
    );

fanout CLKFanout (
    .in(CLK),
    .outA(CLKA),
    .outB(CLKB),
    .outC(CLKC)
    );

fanout ResetFanout (
    .in(Reset),
    .outA(ResetA),
    .outB(ResetB),
    .outC(ResetC)
    );

fanout #(.WIDTH(4)) next_stateFanout (
    .in(next_state),
    .outA(next_stateA),
    .outB(next_stateB),
    .outC(next_stateC)
    );
endmodule

