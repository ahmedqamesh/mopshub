//
// Module mopshub_triplicated.rshiftreg2TMR.struct
//
// Created:
//          by - dcs.dcs (localhost)
//          at - 09:18:08 05/10/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//


module rshiftreg2TMR( 
   // Port Declarations
   input   wire            clockA, 
   input   wire            clockB, 
   input   wire            clockC, 
   input   wire            bitinA, 
   input   wire            bitinB, 
   input   wire            bitinC, 
   input   wire            activA, 
   input   wire            activB, 
   input   wire            activC, 
   input   wire            resetA, 
   input   wire            resetB, 
   input   wire            resetC, 
   input   wire            lcrcA, 
   input   wire            lcrcB, 
   input   wire            lcrcC, 
   input   wire            setzeroA, 
   input   wire            setzeroB, 
   input   wire            setzeroC, 
   input   wire            directshiftA, 
   input   wire            directshiftB, 
   input   wire            directshiftC, 
   output  wire    [67:0]  mesout_aA, 
   output  wire    [67:0]  mesout_aB, 
   output  wire    [67:0]  mesout_aC, 
   output  wire    [17:0]  mesout_bA, 
   output  wire    [17:0]  mesout_bB, 
   output  wire    [17:0]  mesout_bC, 
   output  wire    [10:0]  mesout_cA, 
   output  wire    [10:0]  mesout_cB, 
   output  wire    [10:0]  mesout_cC
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wor           enable_iTmrErrorC;
wire          enable_iVotedC;
wor           edgedTmrErrorC;
wire          edgedVotedC;
wor           enable_iTmrErrorB;
wire          enable_iVotedB;
wor           edgedTmrErrorB;
wire          edgedVotedB;
wor           enable_iTmrErrorA;
wire          enable_iVotedA;
wor           edgedTmrErrorA;
wire          edgedVotedA;
reg           edgedA;
reg           edgedB;
reg           edgedC;
wire          activ_iA;
wire          activ_iB;
wire          activ_iC;
wire          bitin_iA;
wire          bitin_iB;
wire          bitin_iC;
reg           enable_iA;
reg           enable_iB;
reg           enable_iC;
wire          reset_iA;
wire          reset_iB;
wire          reset_iC;
wire  [102:0] q_iA;
wire  [102:0] q_iB;
wire  [102:0] q_iC;


genvar i;

// Instances 
majorityVoter edgedVoterA( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedA), 
   .tmrErr (edgedTmrErrorA)
); 

majorityVoter edgedVoterB( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedB), 
   .tmrErr (edgedTmrErrorB)
); 

majorityVoter edgedVoterC( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedC), 
   .tmrErr (edgedTmrErrorC)
); 

majorityVoter enable_iVoterA( 
   .inA    (enable_iA), 
   .inB    (enable_iB), 
   .inC    (enable_iC), 
   .out    (enable_iVotedA), 
   .tmrErr (enable_iTmrErrorA)
); 

majorityVoter enable_iVoterB( 
   .inA    (enable_iA), 
   .inB    (enable_iB), 
   .inC    (enable_iC), 
   .out    (enable_iVotedB), 
   .tmrErr (enable_iTmrErrorB)
); 

majorityVoter enable_iVoterC( 
   .inA    (enable_iA), 
   .inB    (enable_iB), 
   .inC    (enable_iC), 
   .out    (enable_iVotedC), 
   .tmrErr (enable_iTmrErrorC)
); 

rshift_cell2TMR bottom( 
   .enableA (enable_iVotedA), 
   .enableB (enable_iVotedB), 
   .enableC (enable_iVotedC), 
   .clockA  (clockA), 
   .clockB  (clockB), 
   .clockC  (clockC), 
   .resetA  (reset_iA), 
   .resetB  (reset_iB), 
   .resetC  (reset_iC), 
   .InputA  (bitin_iA), 
   .InputB  (bitin_iB), 
   .InputC  (bitin_iC), 
   .qA      (q_iA[0]), 
   .qB      (q_iB[0]), 
   .qC      (q_iC[0])
); 

// HDL Embedded Text Block 1 eb1
assign mesout_aA =  q_iA[67:0] ;
assign mesout_aB =  q_iB[67:0] ;
assign mesout_aC =  q_iC[67:0] ;
assign mesout_bA =  q_iA[88:71] ;
assign mesout_bB =  q_iB[88:71] ;
assign mesout_bC =  q_iC[88:71] ;
assign mesout_cA =  q_iA[101:91] ;
assign mesout_cB =  q_iB[101:91] ;
assign mesout_cC =  q_iC[101:91] ;
assign activ_iA =  (activA&(~ lcrcA ))|directshiftA;
assign activ_iB =  (activB&(~ lcrcB ))|directshiftB;
assign activ_iC =  (activC&(~ lcrcC ))|directshiftC;
assign bitin_iA =  bitinA&setzeroA;
assign bitin_iB =  bitinB&setzeroB;
assign bitin_iC =  bitinC&setzeroC;
assign reset_iA =  resetA;
assign reset_iB =  resetB;
assign reset_iC =  resetC;
// HDL Embedded Text Block 2 eb2
generate
  for(i =  1;i<103;i =  i+1)
    begin 

      rshift_cell2TMR reg_i (
          .enableA(enable_iVotedA),
          .enableB(enable_iVotedB),
          .enableC(enable_iVotedC),
          .clockA(clockA),
          .clockB(clockB),
          .clockC(clockC),
          .resetA(reset_iA),
          .resetB(reset_iB),
          .resetC(reset_iC),
          .InputA(q_iA[i-1] ),
          .InputB(q_iB[i-1] ),
          .InputC(q_iC[i-1] ),
          .qA(q_iA[i] ),
          .qB(q_iB[i] ),
          .qC(q_iC[i] )
          );
    end

endgenerate
// HDL Embedded Text Block 3 eb3
always @( posedge clockA )
  begin
    if (resetA==1'b0)
      begin
        enable_iA <= 1'b0;
        edgedA =  1'b0;
      end
    else
      begin
        edgedA =  edgedVotedA;
        enable_iA <= enable_iVotedA;
        if (activ_iA==1'b1)
          if (edgedVotedA==1'b0)
            begin
              edgedA =  1'b1;
              enable_iA <= 1'b1;
            end
          else
            enable_iA <= 1'b0;
        else
          begin
            edgedA =  1'b0;
            enable_iA <= 1'b0;
          end
      end
  end
// HDL Embedded Text Block 4 eb4
always @( posedge clockB )
  begin
    if (resetB==1'b0)
      begin
        enable_iB <= 1'b0;
        edgedB =  1'b0;
      end
    else
      begin
        edgedB =  edgedVotedB;
        enable_iB <= enable_iVotedB;
        if (activ_iB==1'b1)
          if (edgedVotedB==1'b0)
            begin
              edgedB =  1'b1;
              enable_iB <= 1'b1;
            end
          else
            enable_iB <= 1'b0;
        else
          begin
            edgedB =  1'b0;
            enable_iB <= 1'b0;
          end
      end
  end
// HDL Embedded Text Block 5 eb5
always @( posedge clockC )
  begin
    if (resetC==1'b0)
      begin
        enable_iC <= 1'b0;
        edgedC =  1'b0;
      end
    else
      begin
        edgedC =  edgedVotedC;
        enable_iC <= enable_iVotedC;
        if (activ_iC==1'b1)
          if (edgedVotedC==1'b0)
            begin
              edgedC =  1'b1;
              enable_iC <= 1'b1;
            end
          else
            enable_iC <= 1'b0;
        else
          begin
            edgedC =  1'b0;
            enable_iC <= 1'b0;
          end
      end
  end

endmodule // rshiftreg2TMR

