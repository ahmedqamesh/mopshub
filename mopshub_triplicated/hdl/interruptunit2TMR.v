/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/interruptunit2TMR.v                                                           *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:44                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: interruptunit2.v                                                                       *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-29 13:49:21                                                *
 *           File Size         : 5599                                                               *
 *           MD5 hash          : 23813de77a3a6f878bd758eb847215c1                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module interruptunit2TMR(
  input wire  clockA ,
  input wire  clockB ,
  input wire  clockC ,
  input wire  resetA ,
  input wire  resetB ,
  input wire  resetC ,
  input wire [2:0] ienableA ,
  input wire [2:0] ienableB ,
  input wire [2:0] ienableC ,
  input wire [2:0] irqstdA ,
  input wire [2:0] irqstdB ,
  input wire [2:0] irqstdC ,
  input wire  irqsigA ,
  input wire  irqsigB ,
  input wire  irqsigC ,
  input wire  sucfrecA ,
  input wire  sucfrecB ,
  input wire  sucfrecC ,
  input wire  sucftraA ,
  input wire  sucftraB ,
  input wire  sucftraC ,
  output reg  activintregA ,
  output reg  activintregB ,
  output reg  activintregC ,
  output reg  irqstatusA ,
  output reg  irqstatusB ,
  output reg  irqstatusC ,
  output reg  irqsuctraA ,
  output reg  irqsuctraB ,
  output reg  irqsuctraC ,
  output reg  irqsucrecA ,
  output reg  irqsucrecB ,
  output reg  irqsucrecC ,
  output wire  irqA ,
  output wire  irqB ,
  output wire  irqC 
);
parameter [1:0] waitoact =2'b00;
parameter [1:0] recind =2'b01;
parameter [1:0] traind =2'b10;
parameter [1:0] statind =2'b11;
wor CURRENT_STATETmrErrorC;
wire [1:0] CURRENT_STATEVotedC;
wor CURRENT_STATETmrErrorB;
wire [1:0] CURRENT_STATEVotedB;
wor CURRENT_STATETmrErrorA;
wire [1:0] CURRENT_STATEVotedA;
reg  [1:0] CURRENT_STATEA ;
reg  [1:0] NEXT_STATEA ;
reg  [1:0] CURRENT_STATEB ;
reg  [1:0] NEXT_STATEB ;
reg  [1:0] CURRENT_STATEC ;
reg  [1:0] NEXT_STATEC ;
assign irqA =  (irqstdA[0] |irqstdA[1] |irqstdA[2] );
assign irqB =  (irqstdB[0] |irqstdB[1] |irqstdB[2] );
assign irqC =  (irqstdC[0] |irqstdC[1] |irqstdC[2] );

always @( posedge clockA )
  begin
    if (resetA==1'b0)
      CURRENT_STATEA <= waitoact;
    else
      CURRENT_STATEA <= NEXT_STATEA;
  end

always @( posedge clockB )
  begin
    if (resetB==1'b0)
      CURRENT_STATEB <= waitoact;
    else
      CURRENT_STATEB <= NEXT_STATEB;
  end

always @( posedge clockC )
  begin
    if (resetC==1'b0)
      CURRENT_STATEC <= waitoact;
    else
      CURRENT_STATEC <= NEXT_STATEC;
  end

always @( CURRENT_STATEVotedA or irqsigA or sucfrecA or sucftraA or irqstdA or ienableA )
  begin
    case (CURRENT_STATEVotedA)
      waitoact : 
        begin
          activintregA =  1'b0;
          irqstatusA =  1'b0;
          irqsuctraA =  1'b0;
          irqsucrecA =  1'b0;
          if (sucfrecA==1'b1&irqstdA[0] ==1'b0&ienableA[0] ==1'b1)
            NEXT_STATEA =  recind;
          else
            if (sucftraA==1'b1&irqstdA[1] ==1'b0&ienableA[1] ==1'b1)
              NEXT_STATEA =  traind;
            else
              if (irqsigA==1'b1&irqstdA[2] ==1'b0&ienableA[2] ==1'b1)
                NEXT_STATEA =  statind;
              else
                NEXT_STATEA =  waitoact;
        end
      recind : 
        begin
          activintregA =  1'b1;
          irqstatusA =  1'b0;
          irqsuctraA =  1'b0;
          irqsucrecA =  1'b1;
          if (sucftraA==1'b1&irqstdA[1] ==1'b0&ienableA[1] ==1'b1)
            NEXT_STATEA =  traind;
          else
            if (irqsigA==1'b1&irqstdA[2] ==1'b0&ienableA[2] ==1'b1)
              NEXT_STATEA =  statind;
            else
              NEXT_STATEA =  waitoact;
        end
      traind : 
        begin
          activintregA =  1'b1;
          irqstatusA =  1'b0;
          irqsuctraA =  1'b1;
          irqsucrecA =  1'b0;
          if (sucfrecA==1'b1&irqstdA[0] ==1'b0&ienableA[0] ==1'b1)
            NEXT_STATEA =  recind;
          else
            if (irqsigA==1'b1&irqstdA[2] ==1'b0&ienableA[2] ==1'b1)
              NEXT_STATEA =  statind;
            else
              NEXT_STATEA =  waitoact;
        end
      statind : 
        begin
          activintregA =  1'b1;
          irqstatusA =  1'b1;
          irqsuctraA =  1'b0;
          irqsucrecA =  1'b0;
          if (sucfrecA==1'b1&irqstdA[0] ==1'b0&ienableA[0] ==1'b1)
            NEXT_STATEA =  recind;
          else
            if (sucftraA==1'b1&irqstdA[1] ==1'b0&ienableA[1] ==1'b1)
              NEXT_STATEA =  traind;
            else
              NEXT_STATEA =  waitoact;
        end
      default : 
        begin
          activintregA =  1'b0;
          irqstatusA =  1'b0;
          irqsuctraA =  1'b0;
          irqsucrecA =  1'b0;
          NEXT_STATEA =  CURRENT_STATEVotedA;
        end
    endcase
  end

always @( CURRENT_STATEVotedB or irqsigB or sucfrecB or sucftraB or irqstdB or ienableB )
  begin
    case (CURRENT_STATEVotedB)
      waitoact : 
        begin
          activintregB =  1'b0;
          irqstatusB =  1'b0;
          irqsuctraB =  1'b0;
          irqsucrecB =  1'b0;
          if (sucfrecB==1'b1&irqstdB[0] ==1'b0&ienableB[0] ==1'b1)
            NEXT_STATEB =  recind;
          else
            if (sucftraB==1'b1&irqstdB[1] ==1'b0&ienableB[1] ==1'b1)
              NEXT_STATEB =  traind;
            else
              if (irqsigB==1'b1&irqstdB[2] ==1'b0&ienableB[2] ==1'b1)
                NEXT_STATEB =  statind;
              else
                NEXT_STATEB =  waitoact;
        end
      recind : 
        begin
          activintregB =  1'b1;
          irqstatusB =  1'b0;
          irqsuctraB =  1'b0;
          irqsucrecB =  1'b1;
          if (sucftraB==1'b1&irqstdB[1] ==1'b0&ienableB[1] ==1'b1)
            NEXT_STATEB =  traind;
          else
            if (irqsigB==1'b1&irqstdB[2] ==1'b0&ienableB[2] ==1'b1)
              NEXT_STATEB =  statind;
            else
              NEXT_STATEB =  waitoact;
        end
      traind : 
        begin
          activintregB =  1'b1;
          irqstatusB =  1'b0;
          irqsuctraB =  1'b1;
          irqsucrecB =  1'b0;
          if (sucfrecB==1'b1&irqstdB[0] ==1'b0&ienableB[0] ==1'b1)
            NEXT_STATEB =  recind;
          else
            if (irqsigB==1'b1&irqstdB[2] ==1'b0&ienableB[2] ==1'b1)
              NEXT_STATEB =  statind;
            else
              NEXT_STATEB =  waitoact;
        end
      statind : 
        begin
          activintregB =  1'b1;
          irqstatusB =  1'b1;
          irqsuctraB =  1'b0;
          irqsucrecB =  1'b0;
          if (sucfrecB==1'b1&irqstdB[0] ==1'b0&ienableB[0] ==1'b1)
            NEXT_STATEB =  recind;
          else
            if (sucftraB==1'b1&irqstdB[1] ==1'b0&ienableB[1] ==1'b1)
              NEXT_STATEB =  traind;
            else
              NEXT_STATEB =  waitoact;
        end
      default : 
        begin
          activintregB =  1'b0;
          irqstatusB =  1'b0;
          irqsuctraB =  1'b0;
          irqsucrecB =  1'b0;
          NEXT_STATEB =  CURRENT_STATEVotedB;
        end
    endcase
  end

always @( CURRENT_STATEVotedC or irqsigC or sucfrecC or sucftraC or irqstdC or ienableC )
  begin
    case (CURRENT_STATEVotedC)
      waitoact : 
        begin
          activintregC =  1'b0;
          irqstatusC =  1'b0;
          irqsuctraC =  1'b0;
          irqsucrecC =  1'b0;
          if (sucfrecC==1'b1&irqstdC[0] ==1'b0&ienableC[0] ==1'b1)
            NEXT_STATEC =  recind;
          else
            if (sucftraC==1'b1&irqstdC[1] ==1'b0&ienableC[1] ==1'b1)
              NEXT_STATEC =  traind;
            else
              if (irqsigC==1'b1&irqstdC[2] ==1'b0&ienableC[2] ==1'b1)
                NEXT_STATEC =  statind;
              else
                NEXT_STATEC =  waitoact;
        end
      recind : 
        begin
          activintregC =  1'b1;
          irqstatusC =  1'b0;
          irqsuctraC =  1'b0;
          irqsucrecC =  1'b1;
          if (sucftraC==1'b1&irqstdC[1] ==1'b0&ienableC[1] ==1'b1)
            NEXT_STATEC =  traind;
          else
            if (irqsigC==1'b1&irqstdC[2] ==1'b0&ienableC[2] ==1'b1)
              NEXT_STATEC =  statind;
            else
              NEXT_STATEC =  waitoact;
        end
      traind : 
        begin
          activintregC =  1'b1;
          irqstatusC =  1'b0;
          irqsuctraC =  1'b1;
          irqsucrecC =  1'b0;
          if (sucfrecC==1'b1&irqstdC[0] ==1'b0&ienableC[0] ==1'b1)
            NEXT_STATEC =  recind;
          else
            if (irqsigC==1'b1&irqstdC[2] ==1'b0&ienableC[2] ==1'b1)
              NEXT_STATEC =  statind;
            else
              NEXT_STATEC =  waitoact;
        end
      statind : 
        begin
          activintregC =  1'b1;
          irqstatusC =  1'b1;
          irqsuctraC =  1'b0;
          irqsucrecC =  1'b0;
          if (sucfrecC==1'b1&irqstdC[0] ==1'b0&ienableC[0] ==1'b1)
            NEXT_STATEC =  recind;
          else
            if (sucftraC==1'b1&irqstdC[1] ==1'b0&ienableC[1] ==1'b1)
              NEXT_STATEC =  traind;
            else
              NEXT_STATEC =  waitoact;
        end
      default : 
        begin
          activintregC =  1'b0;
          irqstatusC =  1'b0;
          irqsuctraC =  1'b0;
          irqsucrecC =  1'b0;
          NEXT_STATEC =  CURRENT_STATEVotedC;
        end
    endcase
  end

majorityVoter #(.WIDTH(2)) CURRENT_STATEVoterA (
    .inA(CURRENT_STATEA),
    .inB(CURRENT_STATEB),
    .inC(CURRENT_STATEC),
    .out(CURRENT_STATEVotedA),
    .tmrErr(CURRENT_STATETmrErrorA)
    );

majorityVoter #(.WIDTH(2)) CURRENT_STATEVoterB (
    .inA(CURRENT_STATEA),
    .inB(CURRENT_STATEB),
    .inC(CURRENT_STATEC),
    .out(CURRENT_STATEVotedB),
    .tmrErr(CURRENT_STATETmrErrorB)
    );

majorityVoter #(.WIDTH(2)) CURRENT_STATEVoterC (
    .inA(CURRENT_STATEA),
    .inB(CURRENT_STATEB),
    .inC(CURRENT_STATEC),
    .out(CURRENT_STATEVotedC),
    .tmrErr(CURRENT_STATETmrErrorC)
    );
endmodule

