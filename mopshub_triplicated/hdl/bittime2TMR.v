/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/bittime2TMR.v                                                                 *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:00                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: bittime2.v                                                                             *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? bittime2.v)           *
 *           Modification time : 2022-11-10 21:22:58                                                *
 *           File Size         : 8213                                                               *
 *           MD5 hash          : 6adbe214c4628cc8ef152cebb2b30df9                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module bittime2TMR(
  input wire  clock ,
  input wire  Prescale_EN ,
  input wire  reset ,
  input wire  hardsync ,
  input wire  notnull ,
  input wire  gtsjwp1 ,
  input wire  gttseg1p1 ,
  input wire  cpsgetseg1ptseg2p2 ,
  input wire  cetseg1ptseg2p1 ,
  input wire  countesmpltime ,
  input wire  puffer ,
  input wire  rx ,
  output reg  increment ,
  output reg  setctzero ,
  output reg  setctotwo ,
  output reg  sendpoint ,
  output reg  smplpoint ,
  output reg [1:0] smpldbit_reg_ctrl ,
  output reg [1:0] tseg_reg_ctrl ,
  output reg [3:0] bitst 
);
parameter [3:0] normal =4'd0;
parameter [3:0] hardset =4'd1;
parameter [3:0] stretchok =4'd2;
parameter [3:0] stretchnok =4'd3;
parameter [3:0] slimok =4'd4;
parameter [3:0] slimnok =4'd5;
parameter [3:0] sndprescnt =4'd6;
parameter [3:0] samplepoint =4'd7;
parameter [3:0] resetstate =4'd8;
wire resetC;
wire resetB;
wire resetA;
wire [3:0] next_stateC;
wire [3:0] next_stateB;
wire [3:0] next_stateA;
wire [3:0] current_stateVC;
wire [3:0] current_stateVB;
wire [3:0] current_stateVA;
wire clockC;
wire clockB;
wire clockA;
wire Prescale_ENC;
wire Prescale_ENB;
wire Prescale_ENA;
wor current_stateTmrError;
wire [3:0] current_state;
reg  [3:0] current_stateA ;
reg  [3:0] current_stateB ;
reg  [3:0] current_stateC ;
reg  [3:0] next_state ;
wire [3:0] current_stateV =  current_state;

always @( posedge clockA or negedge resetA )
  begin
    if (resetA==1'b0)
      current_stateA <= resetstate;
    else
      if (Prescale_ENA==1'b1)
        current_stateA <= next_stateA;
      else
        current_stateA <= current_stateVA;
  end

always @( posedge clockB or negedge resetB )
  begin
    if (resetB==1'b0)
      current_stateB <= resetstate;
    else
      if (Prescale_ENB==1'b1)
        current_stateB <= next_stateB;
      else
        current_stateB <= current_stateVB;
  end

always @( posedge clockC or negedge resetC )
  begin
    if (resetC==1'b0)
      current_stateC <= resetstate;
    else
      if (Prescale_ENC==1'b1)
        current_stateC <= next_stateC;
      else
        current_stateC <= current_stateVC;
  end

always @( current_stateV )
  begin
    case (current_stateV)
      normal : bitst <= 4'h0;
      hardset : bitst <= 4'h1;
      stretchok : bitst <= 4'h2;
      stretchnok : bitst <= 4'h3;
      slimok : bitst <= 4'h4;
      slimnok : bitst <= 4'h5;
      sndprescnt : bitst <= 4'h6;
      samplepoint : bitst <= 4'h7;
      resetstate : bitst <= 4'h8;
      default : bitst <= 4'ha;
    endcase
  end

always @( current_stateV or hardsync or rx or puffer or notnull or gtsjwp1 or gttseg1p1 or cpsgetseg1ptseg2p2 or cetseg1ptseg2p1 or countesmpltime )
  begin
    case (current_stateV)
      resetstate : 
        begin
          increment <= 1'b0;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b01;
          tseg_reg_ctrl <= 2'b01;
          next_state <= hardset;
        end
      normal : 
        begin
          increment <= 1'b1;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b00;
          if (rx==1'b0&&puffer==1'b1)
            if (hardsync==1)
              next_state <= hardset;
            else
              if (notnull==1'b1&&gtsjwp1==1'b0)
                next_state <= stretchok;
              else
                if (gtsjwp1==1'b1&&gttseg1p1==1'b0)
                  next_state <= stretchnok;
                else
                  if (gttseg1p1==1'b1&&cpsgetseg1ptseg2p2==1'b0)
                    next_state <= slimnok;
                  else
                    if (cpsgetseg1ptseg2p2==1'b1)
                      next_state <= slimok;
                    else
                      next_state <= normal;
          else
            if (cetseg1ptseg2p1==1'b1)
              next_state <= sndprescnt;
            else
              if (countesmpltime==1'b1)
                next_state <= samplepoint;
              else
                next_state <= normal;
        end
      hardset : 
        begin
          increment <= 1'b0;
          setctzero <= 1'b0;
          setctotwo <= 1'b1;
          sendpoint <= 1'b1;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b01;
          next_state <= normal;
        end
      sndprescnt : 
        begin
          increment <= 1'b0;
          setctzero <= 1'b1;
          setctotwo <= 1'b0;
          sendpoint <= 1'b1;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b01;
          if (rx==1'b0&&puffer==1'b1)
            if (hardsync==1)
              next_state <= hardset;
            else
              next_state <= slimok;
          else
            next_state <= normal;
        end
      stretchok : 
        begin
          increment <= 1'b1;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b10;
          next_state <= normal;
        end
      stretchnok : 
        begin
          increment <= 1'b1;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b11;
          next_state <= normal;
        end
      slimok : 
        begin
          increment <= 1'b0;
          setctzero <= 1'b0;
          setctotwo <= 1'b1;
          sendpoint <= 1'b1;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b01;
          next_state <= normal;
        end
      slimnok : 
        begin
          increment <= 1'b1;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b00;
          if (cpsgetseg1ptseg2p2==1'b1)
            next_state <= slimok;
          else
            next_state <= slimnok;
        end
      samplepoint : 
        begin
          increment <= 1'b1;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b1;
          smpldbit_reg_ctrl <= 2'b10;
          tseg_reg_ctrl <= 2'b00;
          if (rx==1'b0&&puffer==1'b1)
            if (hardsync==1)
              next_state <= hardset;
            else
              if (cpsgetseg1ptseg2p2==1'b1)
                next_state <= slimok;
              else
                next_state <= slimnok;
          else
            next_state <= normal;
        end
      default : 
        begin
          increment <= 1'b0;
          setctzero <= 1'b0;
          setctotwo <= 1'b0;
          sendpoint <= 1'b0;
          smplpoint <= 1'b0;
          smpldbit_reg_ctrl <= 2'b00;
          tseg_reg_ctrl <= 2'b00;
          next_state <= current_stateV;
        end
    endcase
  end

majorityVoter #(.WIDTH(4)) current_stateVoter (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_state),
    .tmrErr(current_stateTmrError)
    );

fanout Prescale_ENFanout (
    .in(Prescale_EN),
    .outA(Prescale_ENA),
    .outB(Prescale_ENB),
    .outC(Prescale_ENC)
    );

fanout clockFanout (
    .in(clock),
    .outA(clockA),
    .outB(clockB),
    .outC(clockC)
    );

fanout #(.WIDTH(4)) current_stateVFanout (
    .in(current_stateV),
    .outA(current_stateVA),
    .outB(current_stateVB),
    .outC(current_stateVC)
    );

fanout #(.WIDTH(4)) next_stateFanout (
    .in(next_state),
    .outA(next_stateA),
    .outB(next_stateB),
    .outC(next_stateC)
    );

fanout resetFanout (
    .in(reset),
    .outA(resetA),
    .outB(resetB),
    .outC(resetC)
    );
endmodule

