/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/llc_fsm2TMR.v                                                                 *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 06/10/2022 13:52:52                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: llc_fsm2.v                                                                             *
 *           Git SHA           : c110441b08b692cc54ebd4a3b84a2599430e8f93                           *
 *           Modification time : 2022-08-30 13:52:41                                                *
 *           File Size         : 14159                                                              *
 *           MD5 hash          : f4bf0b34b1f94ce341274fb5eb892344                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module llc_fsm2TMR(
  input wire  clock ,
  input wire  reset ,
  input wire  initreqr ,
  input wire  traregbit ,
  input wire  sucfrecvc ,
  input wire  sucftranc ,
  input wire  sucfrecvr ,
  input wire  sucftranr ,
  input wire  equal ,
  output reg  activtreg ,
  output wire  activrreg ,
  output reg  activgreg ,
  output wire  ldrecid ,
  output reg  sucftrano ,
  output reg  sucfrecvo ,
  output reg  overflowo ,
  output reg  trans ,
  output reg  load ,
  output reg  actvtsft ,
  output reg  actvtcap ,
  output reg  resettra ,
  output reg  resetall 
);
localparam waitoact =4'b0000;
localparam tradrvdat =4'b0001;
localparam traruncap =4'b0010;
localparam tralodsft =4'b0011;
localparam trawtosuc =4'b0100;
localparam trasetvall =4'b0101;
localparam trareset =4'b0110;
localparam trasetvalh =4'b0111;
localparam recwrtmesll =4'b1000;
localparam recwrtmeslh =4'b1001;
localparam recwrtmeshl =4'b1010;
localparam recwrtmeshh =4'b1011;
localparam resetste =4'b1100;
wire resetC;
wire resetB;
wire resetA;
wire clockC;
wire clockB;
wire clockA;
wire [3:0] NEXT_STATEC;
wire [3:0] NEXT_STATEB;
wire [3:0] NEXT_STATEA;
wor CURRENT_STATETmrError;
wire [3:0] CURRENT_STATE;
reg  [3:0] CURRENT_STATEA ;
reg  [3:0] CURRENT_STATEB ;
reg  [3:0] CURRENT_STATEC ;
reg  [3:0] NEXT_STATE ;
reg  activrreg_i ;
wire [1:0] sctrrcin;
assign sctrrcin =  {sucftranr,sucfrecvr};
assign ldrecid =  activrreg_i;
assign activrreg =  activrreg_i;
wire [3:0] CURRENT_STATEV =  CURRENT_STATE;

always @( posedge clockA )
  begin
    if (resetA==1'b0)
      CURRENT_STATEA <= waitoact;
    else
      CURRENT_STATEA <= NEXT_STATEA;
  end

always @( posedge clockB )
  begin
    if (resetB==1'b0)
      CURRENT_STATEB <= waitoact;
    else
      CURRENT_STATEB <= NEXT_STATEB;
  end

always @( posedge clockC )
  begin
    if (resetC==1'b0)
      CURRENT_STATEC <= waitoact;
    else
      CURRENT_STATEC <= NEXT_STATEC;
  end

always @( CURRENT_STATEV or traregbit or sucfrecvc or sucftranc or sucfrecvr or sctrrcin or initreqr or equal )
  begin
    activtreg =  1'b0;
    activrreg_i =  1'b0;
    activgreg =  1'b0;
    sucftrano =  1'b0;
    sucfrecvo =  1'b0;
    trans =  1'b0;
    load =  1'b0;
    actvtsft =  1'b0;
    actvtcap =  1'b0;
    overflowo =  1'b0;
    resettra =  1'b1;
    resetall =  1'b1;
    case (CURRENT_STATEV)
      waitoact : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (initreqr==1'b0&&traregbit==1'b1&&sucfrecvc==1'b0)
              NEXT_STATE =  tradrvdat;
            else
              if (sctrrcin==2'b00&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                NEXT_STATE =  recwrtmesll;
              else
                if (sctrrcin==2'b01&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                  NEXT_STATE =  recwrtmeslh;
                else
                  if (sctrrcin==2'b10&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                    NEXT_STATE =  recwrtmeshl;
                  else
                    if (sctrrcin==2'b11&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                      NEXT_STATE =  recwrtmeshh;
                    else
                      NEXT_STATE =  waitoact;
        end
      resetste : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b1;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b0;
          NEXT_STATE =  waitoact;
        end
      trareset : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b0;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  tradrvdat;
        end
      tradrvdat : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  traruncap;
        end
      traruncap : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b1;
          actvtsft =  1'b0;
          actvtcap =  1'b1;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  tralodsft;
        end
      tralodsft : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b1;
          actvtsft =  1'b1;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  trawtosuc;
        end
      trawtosuc : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b0;
          activgreg =  1'b0;
          sucftrano =  1'b0;
          sucfrecvo =  1'b0;
          trans =  1'b1;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (initreqr==1'b0&&sucftranc==1'b1&&sucfrecvc==1'b0&&sucfrecvr==1'b0)
              NEXT_STATE =  trasetvall;
            else
              if (initreqr==1'b0&&sucftranc==1'b1&&sucfrecvc==1'b0&&sucfrecvr==1'b1)
                NEXT_STATE =  trasetvalh;
              else
                if (sctrrcin==2'b00&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                  NEXT_STATE =  recwrtmesll;
                else
                  if (sctrrcin==2'b01&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                    NEXT_STATE =  recwrtmeshl;
                  else
                    if (sctrrcin==2'b10&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                      NEXT_STATE =  recwrtmeshl;
                    else
                      if (sctrrcin==2'b11&&sucfrecvc==1'b1&&initreqr==1'b0&&equal==1'b1)
                        NEXT_STATE =  recwrtmeshh;
                      else
                        NEXT_STATE =  trawtosuc;
        end
      trasetvall : 
        begin
          activtreg =  1'b1;
          activrreg_i =  1'b0;
          activgreg =  1'b1;
          sucftrano =  1'b1;
          sucfrecvo =  1'b0;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  waitoact;
        end
      trasetvalh : 
        begin
          activtreg =  1'b1;
          activrreg_i =  1'b0;
          activgreg =  1'b1;
          sucftrano =  1'b1;
          sucfrecvo =  1'b1;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          overflowo =  1'b0;
          resettra =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            NEXT_STATE =  waitoact;
        end
      recwrtmesll : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b1;
          activgreg =  1'b1;
          sucftrano =  1'b0;
          sucfrecvo =  1'b1;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          resettra =  1'b1;
          overflowo =  1'b0;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (sucfrecvc==1'b0)
              NEXT_STATE =  waitoact;
            else
              NEXT_STATE =  recwrtmesll;
        end
      recwrtmeslh : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b1;
          activgreg =  1'b1;
          sucftrano =  1'b0;
          sucfrecvo =  1'b1;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          resettra =  1'b1;
          overflowo =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (sucfrecvc==1'b0)
              NEXT_STATE =  waitoact;
            else
              NEXT_STATE =  recwrtmeslh;
        end
      recwrtmeshl : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b1;
          activgreg =  1'b1;
          sucftrano =  1'b1;
          sucfrecvo =  1'b1;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          resettra =  1'b1;
          overflowo =  1'b0;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (sucfrecvc==1'b0)
              NEXT_STATE =  waitoact;
            else
              NEXT_STATE =  recwrtmeshl;
        end
      recwrtmeshh : 
        begin
          activtreg =  1'b0;
          activrreg_i =  1'b1;
          activgreg =  1'b1;
          sucftrano =  1'b1;
          sucfrecvo =  1'b1;
          trans =  1'b0;
          load =  1'b0;
          actvtsft =  1'b0;
          actvtcap =  1'b0;
          resettra =  1'b1;
          overflowo =  1'b1;
          resetall =  1'b1;
          if (initreqr==1'b1)
            NEXT_STATE =  resetste;
          else
            if (sucfrecvc==1'b0)
              NEXT_STATE =  waitoact;
            else
              NEXT_STATE =  recwrtmeshh;
        end
      default : 
        begin
          NEXT_STATE =  CURRENT_STATEV;
        end
    endcase
  end

majorityVoter #(.WIDTH(4)) CURRENT_STATEVoter (
    .inA(CURRENT_STATEA),
    .inB(CURRENT_STATEB),
    .inC(CURRENT_STATEC),
    .out(CURRENT_STATE),
    .tmrErr(CURRENT_STATETmrError)
    );

fanout #(.WIDTH(4)) NEXT_STATEFanout (
    .in(NEXT_STATE),
    .outA(NEXT_STATEA),
    .outB(NEXT_STATEB),
    .outC(NEXT_STATEC)
    );

fanout clockFanout (
    .in(clock),
    .outA(clockA),
    .outB(clockB),
    .outC(clockC)
    );

fanout resetFanout (
    .in(reset),
    .outA(resetA),
    .outB(resetB),
    .outC(resetC)
    );
endmodule

