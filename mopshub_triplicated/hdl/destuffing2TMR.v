/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/destuffing2TMR.v                                                              *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:07                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: destuffing2.v                                                                          *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? destuffing2.v)        *
 *           Modification time : 2022-11-11 13:05:48.420597                                         *
 *           File Size         : 4970                                                               *
 *           MD5 hash          : ec9193b14bd79bc54ebb4e331680fb6a                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module destuffing2TMR(
  input wire  clock ,
  input wire  bitin ,
  input wire  activ ,
  input wire  reset ,
  input wire  direct ,
  output wire  stfer ,
  output wire  stuff ,
  output wire  bitout 
);
wire stuff_iVC;
wire stuff_iVB;
wire stuff_iVA;
wire stfer_iVC;
wire stfer_iVB;
wire stfer_iVA;
wire resetC;
wire resetB;
wire resetA;
wire edgedVC;
wire edgedVB;
wire edgedVA;
wire directC;
wire directB;
wire directA;
wire [2:0] countVC;
wire [2:0] countVB;
wire [2:0] countVA;
wire clockC;
wire clockB;
wire clockA;
wire buffVC;
wire buffVB;
wire buffVA;
wire bitout_iVC;
wire bitout_iVB;
wire bitout_iVA;
wire bitinC;
wire bitinB;
wire bitinA;
wire activC;
wire activB;
wire activA;
wor stuff_iTmrError;
wire stuff_i;
wor stfer_iTmrError;
wire stfer_i;
wor edgedTmrError;
wire edged;
wor countTmrError;
wire [2:0] count;
wor buffTmrError;
wire buff;
wor bitout_iTmrError;
wire bitout_i;
reg  [2:0] countA ;
reg  [2:0] countB ;
reg  [2:0] countC ;
reg  [3:0] stateA ;
reg  [3:0] stateB ;
reg  [3:0] stateC ;
reg  buffA ;
reg  buffB ;
reg  buffC ;
reg  edgedA ;
reg  edgedB ;
reg  edgedC ;
reg  stfer_iA ;
reg  stfer_iB ;
reg  stfer_iC ;
reg  stuff_iA ;
reg  stuff_iB ;
reg  stuff_iC ;
reg  bitout_iA ;
reg  bitout_iB ;
reg  bitout_iC ;
wire edgedV =  edged;
wire stfer_iV =  stfer_i;
wire stuff_iV =  stuff_i;
wire bitout_iV =  bitout_i;
wire buffV =  buff;
wire [2:0] countV =  count;
assign stfer =  stfer_iV;
assign stuff =  stuff_iV;
assign bitout =  bitout_iV;

always @( posedge clockA )
  begin
    if (resetA==1'b0)
      begin
        countA =  3'b0;
        stateA =  4'b0000;
        stuff_iA <= 1'b0;
        stfer_iA <= 1'b0;
        edgedA =  1'b0;
      end
    else
      begin
        buffA =  buffVA;
        countA =  countVA;
        edgedA =  edgedVA;
        stfer_iA <= stfer_iVA;
        stuff_iA <= stuff_iVA;
        bitout_iA <= bitout_iVA;
        if (activA==1'b1)
          if (edgedVA==1'b0)
            begin
              edgedA =  1'b1;
              bitout_iA <= bitinA;
              if (bitinA==buffVA)
                stateA[3]  =  1'b1;
              else
                stateA[3]  =  1'b0;
              if (countVA==3'd0)
                stateA[2]  =  1'b1;
              else
                stateA[2]  =  1'b0;
              if (countVA==3'd5)
                stateA[1]  =  1'b1;
              else
                stateA[1]  =  1'b0;
              if (directA==1'b1)
                stateA[0]  =  1'b1;
              else
                stateA[0]  =  1'b0;
              case (stateA)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffA =  bitinA;
                    countA =  3'b1;
                    stuff_iA <= 1'b0;
                    stfer_iA <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countA =  3'b1;
                    stuff_iA <= 1'b1;
                    buffA =  bitinA;
                  end
                4'b1010 : 
                  begin
                    stfer_iA <= 1'b1;
                    stuff_iA <= 1'b0;
                    countA =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countA =  countVA+4'd1;
                    stuff_iA <= 1'b0;
                  end
                default : 
                  begin
                    buffA =  buffVA;
                    countA =  countVA;
                    stuff_iA <= stuff_iVA;
                    stfer_iA <= stfer_iVA;
                  end
              endcase
            end
          else
            edgedA =  1'b1;
        else
          edgedA =  1'b0;
      end
  end

always @( posedge clockB )
  begin
    if (resetB==1'b0)
      begin
        countB =  3'b0;
        stateB =  4'b0000;
        stuff_iB <= 1'b0;
        stfer_iB <= 1'b0;
        edgedB =  1'b0;
      end
    else
      begin
        buffB =  buffVB;
        countB =  countVB;
        edgedB =  edgedVB;
        stfer_iB <= stfer_iVB;
        stuff_iB <= stuff_iVB;
        bitout_iB <= bitout_iVB;
        if (activB==1'b1)
          if (edgedVB==1'b0)
            begin
              edgedB =  1'b1;
              bitout_iB <= bitinB;
              if (bitinB==buffVB)
                stateB[3]  =  1'b1;
              else
                stateB[3]  =  1'b0;
              if (countVB==3'd0)
                stateB[2]  =  1'b1;
              else
                stateB[2]  =  1'b0;
              if (countVB==3'd5)
                stateB[1]  =  1'b1;
              else
                stateB[1]  =  1'b0;
              if (directB==1'b1)
                stateB[0]  =  1'b1;
              else
                stateB[0]  =  1'b0;
              case (stateB)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffB =  bitinB;
                    countB =  3'b1;
                    stuff_iB <= 1'b0;
                    stfer_iB <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countB =  3'b1;
                    stuff_iB <= 1'b1;
                    buffB =  bitinB;
                  end
                4'b1010 : 
                  begin
                    stfer_iB <= 1'b1;
                    stuff_iB <= 1'b0;
                    countB =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countB =  countVB+4'd1;
                    stuff_iB <= 1'b0;
                  end
                default : 
                  begin
                    buffB =  buffVB;
                    countB =  countVB;
                    stuff_iB <= stuff_iVB;
                    stfer_iB <= stfer_iVB;
                  end
              endcase
            end
          else
            edgedB =  1'b1;
        else
          edgedB =  1'b0;
      end
  end

always @( posedge clockC )
  begin
    if (resetC==1'b0)
      begin
        countC =  3'b0;
        stateC =  4'b0000;
        stuff_iC <= 1'b0;
        stfer_iC <= 1'b0;
        edgedC =  1'b0;
      end
    else
      begin
        buffC =  buffVC;
        countC =  countVC;
        edgedC =  edgedVC;
        stfer_iC <= stfer_iVC;
        stuff_iC <= stuff_iVC;
        bitout_iC <= bitout_iVC;
        if (activC==1'b1)
          if (edgedVC==1'b0)
            begin
              edgedC =  1'b1;
              bitout_iC <= bitinC;
              if (bitinC==buffVC)
                stateC[3]  =  1'b1;
              else
                stateC[3]  =  1'b0;
              if (countVC==3'd0)
                stateC[2]  =  1'b1;
              else
                stateC[2]  =  1'b0;
              if (countVC==3'd5)
                stateC[1]  =  1'b1;
              else
                stateC[1]  =  1'b0;
              if (directC==1'b1)
                stateC[0]  =  1'b1;
              else
                stateC[0]  =  1'b0;
              case (stateC)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffC =  bitinC;
                    countC =  3'b1;
                    stuff_iC <= 1'b0;
                    stfer_iC <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countC =  3'b1;
                    stuff_iC <= 1'b1;
                    buffC =  bitinC;
                  end
                4'b1010 : 
                  begin
                    stfer_iC <= 1'b1;
                    stuff_iC <= 1'b0;
                    countC =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countC =  countVC+4'd1;
                    stuff_iC <= 1'b0;
                  end
                default : 
                  begin
                    buffC =  buffVC;
                    countC =  countVC;
                    stuff_iC <= stuff_iVC;
                    stfer_iC <= stfer_iVC;
                  end
              endcase
            end
          else
            edgedC =  1'b1;
        else
          edgedC =  1'b0;
      end
  end

majorityVoter bitout_iVoter (
    .inA(bitout_iA),
    .inB(bitout_iB),
    .inC(bitout_iC),
    .out(bitout_i),
    .tmrErr(bitout_iTmrError)
    );

majorityVoter buffVoter (
    .inA(buffA),
    .inB(buffB),
    .inC(buffC),
    .out(buff),
    .tmrErr(buffTmrError)
    );

majorityVoter #(.WIDTH(3)) countVoter (
    .inA(countA),
    .inB(countB),
    .inC(countC),
    .out(count),
    .tmrErr(countTmrError)
    );

majorityVoter edgedVoter (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edged),
    .tmrErr(edgedTmrError)
    );

majorityVoter stfer_iVoter (
    .inA(stfer_iA),
    .inB(stfer_iB),
    .inC(stfer_iC),
    .out(stfer_i),
    .tmrErr(stfer_iTmrError)
    );

majorityVoter stuff_iVoter (
    .inA(stuff_iA),
    .inB(stuff_iB),
    .inC(stuff_iC),
    .out(stuff_i),
    .tmrErr(stuff_iTmrError)
    );

fanout activFanout (
    .in(activ),
    .outA(activA),
    .outB(activB),
    .outC(activC)
    );

fanout bitinFanout (
    .in(bitin),
    .outA(bitinA),
    .outB(bitinB),
    .outC(bitinC)
    );

fanout bitout_iVFanout (
    .in(bitout_iV),
    .outA(bitout_iVA),
    .outB(bitout_iVB),
    .outC(bitout_iVC)
    );

fanout buffVFanout (
    .in(buffV),
    .outA(buffVA),
    .outB(buffVB),
    .outC(buffVC)
    );

fanout clockFanout (
    .in(clock),
    .outA(clockA),
    .outB(clockB),
    .outC(clockC)
    );

fanout #(.WIDTH(3)) countVFanout (
    .in(countV),
    .outA(countVA),
    .outB(countVB),
    .outC(countVC)
    );

fanout directFanout (
    .in(direct),
    .outA(directA),
    .outB(directB),
    .outC(directC)
    );

fanout edgedVFanout (
    .in(edgedV),
    .outA(edgedVA),
    .outB(edgedVB),
    .outC(edgedVC)
    );

fanout resetFanout (
    .in(reset),
    .outA(resetA),
    .outB(resetB),
    .outC(resetC)
    );

fanout stfer_iVFanout (
    .in(stfer_iV),
    .outA(stfer_iVA),
    .outB(stfer_iVB),
    .outC(stfer_iVC)
    );

fanout stuff_iVFanout (
    .in(stuff_iV),
    .outA(stuff_iVA),
    .outB(stuff_iVB),
    .outC(stuff_iVC)
    );
endmodule

