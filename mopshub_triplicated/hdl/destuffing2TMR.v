/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/destuffing2TMR.v                                                              *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:33                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: destuffing2.v                                                                          *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-29 13:49:21                                                *
 *           File Size         : 4792                                                               *
 *           MD5 hash          : 4bff58fb3a2d021bf534d08568f19aa3                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module destuffing2TMR(
  input wire  clockA ,
  input wire  clockB ,
  input wire  clockC ,
  input wire  bitinA ,
  input wire  bitinB ,
  input wire  bitinC ,
  input wire  activA ,
  input wire  activB ,
  input wire  activC ,
  input wire  resetA ,
  input wire  resetB ,
  input wire  resetC ,
  input wire  directA ,
  input wire  directB ,
  input wire  directC ,
  output wire  stferA ,
  output wire  stferB ,
  output wire  stferC ,
  output wire  stuffA ,
  output wire  stuffB ,
  output wire  stuffC ,
  output wire  bitoutA ,
  output wire  bitoutB ,
  output wire  bitoutC 
);
wor stuff_iTmrErrorC;
wire stuff_iVotedC;
wor stfer_iTmrErrorC;
wire stfer_iVotedC;
wor edgedTmrErrorC;
wire edgedVotedC;
wor bitout_iTmrErrorC;
wire bitout_iVotedC;
wor stuff_iTmrErrorB;
wire stuff_iVotedB;
wor stfer_iTmrErrorB;
wire stfer_iVotedB;
wor edgedTmrErrorB;
wire edgedVotedB;
wor bitout_iTmrErrorB;
wire bitout_iVotedB;
wor stuff_iTmrErrorA;
wire stuff_iVotedA;
wor stfer_iTmrErrorA;
wire stfer_iVotedA;
wor edgedTmrErrorA;
wire edgedVotedA;
wor bitout_iTmrErrorA;
wire bitout_iVotedA;
reg  [2:0] countA ;
reg  [2:0] countB ;
reg  [2:0] countC ;
reg  [3:0] stateA ;
reg  [3:0] stateB ;
reg  [3:0] stateC ;
reg  buffA ;
reg  buffB ;
reg  buffC ;
reg  edgedA ;
reg  edgedB ;
reg  edgedC ;
reg  stfer_iA ;
reg  stfer_iB ;
reg  stfer_iC ;
reg  stuff_iA ;
reg  stuff_iB ;
reg  stuff_iC ;
reg  bitout_iA ;
reg  bitout_iB ;
reg  bitout_iC ;
assign stferA =  stfer_iVotedA;
assign stferB =  stfer_iVotedB;
assign stferC =  stfer_iVotedC;
assign stuffA =  stuff_iVotedA;
assign stuffB =  stuff_iVotedB;
assign stuffC =  stuff_iVotedC;
assign bitoutA =  bitout_iVotedA;
assign bitoutB =  bitout_iVotedB;
assign bitoutC =  bitout_iVotedC;

always @( posedge clockA )
  begin
    if (resetA==1'b0)
      begin
        countA =  3'b0;
        stateA =  4'b0000;
        stuff_iA <= 1'b0;
        stfer_iA <= 1'b0;
        edgedA =  1'b0;
      end
    else
      begin
        edgedA =  edgedVotedA;
        stfer_iA <= stfer_iVotedA;
        stuff_iA <= stuff_iVotedA;
        bitout_iA <= bitout_iVotedA;
        if (activA==1'b1)
          if (edgedVotedA==1'b0)
            begin
              edgedA =  1'b1;
              bitout_iA <= bitinA;
              if (bitinA==buffA)
                stateA[3]  =  1'b1;
              else
                stateA[3]  =  1'b0;
              if (countA==3'd0)
                stateA[2]  =  1'b1;
              else
                stateA[2]  =  1'b0;
              if (countA==3'd5)
                stateA[1]  =  1'b1;
              else
                stateA[1]  =  1'b0;
              if (directA==1'b1)
                stateA[0]  =  1'b1;
              else
                stateA[0]  =  1'b0;
              case (stateA)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffA =  bitinA;
                    countA =  3'b1;
                    stuff_iA <= 1'b0;
                    stfer_iA <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countA =  3'b1;
                    stuff_iA <= 1'b1;
                    buffA =  bitinA;
                  end
                4'b1010 : 
                  begin
                    stfer_iA <= 1'b1;
                    stuff_iA <= 1'b0;
                    countA =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countA =  countA+4'd1;
                    stuff_iA <= 1'b0;
                  end
                default : 
                  begin
                    buffA =  buffA;
                    countA =  countA;
                    stuff_iA <= stuff_iVotedA;
                    stfer_iA <= stfer_iVotedA;
                  end
              endcase
            end
          else
            edgedA =  1'b1;
        else
          edgedA =  1'b0;
      end
  end

always @( posedge clockB )
  begin
    if (resetB==1'b0)
      begin
        countB =  3'b0;
        stateB =  4'b0000;
        stuff_iB <= 1'b0;
        stfer_iB <= 1'b0;
        edgedB =  1'b0;
      end
    else
      begin
        edgedB =  edgedVotedB;
        stfer_iB <= stfer_iVotedB;
        stuff_iB <= stuff_iVotedB;
        bitout_iB <= bitout_iVotedB;
        if (activB==1'b1)
          if (edgedVotedB==1'b0)
            begin
              edgedB =  1'b1;
              bitout_iB <= bitinB;
              if (bitinB==buffB)
                stateB[3]  =  1'b1;
              else
                stateB[3]  =  1'b0;
              if (countB==3'd0)
                stateB[2]  =  1'b1;
              else
                stateB[2]  =  1'b0;
              if (countB==3'd5)
                stateB[1]  =  1'b1;
              else
                stateB[1]  =  1'b0;
              if (directB==1'b1)
                stateB[0]  =  1'b1;
              else
                stateB[0]  =  1'b0;
              case (stateB)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffB =  bitinB;
                    countB =  3'b1;
                    stuff_iB <= 1'b0;
                    stfer_iB <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countB =  3'b1;
                    stuff_iB <= 1'b1;
                    buffB =  bitinB;
                  end
                4'b1010 : 
                  begin
                    stfer_iB <= 1'b1;
                    stuff_iB <= 1'b0;
                    countB =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countB =  countB+4'd1;
                    stuff_iB <= 1'b0;
                  end
                default : 
                  begin
                    buffB =  buffB;
                    countB =  countB;
                    stuff_iB <= stuff_iVotedB;
                    stfer_iB <= stfer_iVotedB;
                  end
              endcase
            end
          else
            edgedB =  1'b1;
        else
          edgedB =  1'b0;
      end
  end

always @( posedge clockC )
  begin
    if (resetC==1'b0)
      begin
        countC =  3'b0;
        stateC =  4'b0000;
        stuff_iC <= 1'b0;
        stfer_iC <= 1'b0;
        edgedC =  1'b0;
      end
    else
      begin
        edgedC =  edgedVotedC;
        stfer_iC <= stfer_iVotedC;
        stuff_iC <= stuff_iVotedC;
        bitout_iC <= bitout_iVotedC;
        if (activC==1'b1)
          if (edgedVotedC==1'b0)
            begin
              edgedC =  1'b1;
              bitout_iC <= bitinC;
              if (bitinC==buffC)
                stateC[3]  =  1'b1;
              else
                stateC[3]  =  1'b0;
              if (countC==3'd0)
                stateC[2]  =  1'b1;
              else
                stateC[2]  =  1'b0;
              if (countC==3'd5)
                stateC[1]  =  1'b1;
              else
                stateC[1]  =  1'b0;
              if (directC==1'b1)
                stateC[0]  =  1'b1;
              else
                stateC[0]  =  1'b0;
              case (stateC)
                4'b0100, 4'b1100, 4'b0000 : 
                  begin
                    buffC =  bitinC;
                    countC =  3'b1;
                    stuff_iC <= 1'b0;
                    stfer_iC <= 1'b0;
                  end
                4'b0010 : 
                  begin
                    countC =  3'b1;
                    stuff_iC <= 1'b1;
                    buffC =  bitinC;
                  end
                4'b1010 : 
                  begin
                    stfer_iC <= 1'b1;
                    stuff_iC <= 1'b0;
                    countC =  3'd0;
                  end
                4'b1000 : 
                  begin
                    countC =  countC+4'd1;
                    stuff_iC <= 1'b0;
                  end
                default : 
                  begin
                    buffC =  buffC;
                    countC =  countC;
                    stuff_iC <= stuff_iVotedC;
                    stfer_iC <= stfer_iVotedC;
                  end
              endcase
            end
          else
            edgedC =  1'b1;
        else
          edgedC =  1'b0;
      end
  end

majorityVoter bitout_iVoterA (
    .inA(bitout_iA),
    .inB(bitout_iB),
    .inC(bitout_iC),
    .out(bitout_iVotedA),
    .tmrErr(bitout_iTmrErrorA)
    );

majorityVoter edgedVoterA (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedA),
    .tmrErr(edgedTmrErrorA)
    );

majorityVoter stfer_iVoterA (
    .inA(stfer_iA),
    .inB(stfer_iB),
    .inC(stfer_iC),
    .out(stfer_iVotedA),
    .tmrErr(stfer_iTmrErrorA)
    );

majorityVoter stuff_iVoterA (
    .inA(stuff_iA),
    .inB(stuff_iB),
    .inC(stuff_iC),
    .out(stuff_iVotedA),
    .tmrErr(stuff_iTmrErrorA)
    );

majorityVoter bitout_iVoterB (
    .inA(bitout_iA),
    .inB(bitout_iB),
    .inC(bitout_iC),
    .out(bitout_iVotedB),
    .tmrErr(bitout_iTmrErrorB)
    );

majorityVoter edgedVoterB (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedB),
    .tmrErr(edgedTmrErrorB)
    );

majorityVoter stfer_iVoterB (
    .inA(stfer_iA),
    .inB(stfer_iB),
    .inC(stfer_iC),
    .out(stfer_iVotedB),
    .tmrErr(stfer_iTmrErrorB)
    );

majorityVoter stuff_iVoterB (
    .inA(stuff_iA),
    .inB(stuff_iB),
    .inC(stuff_iC),
    .out(stuff_iVotedB),
    .tmrErr(stuff_iTmrErrorB)
    );

majorityVoter bitout_iVoterC (
    .inA(bitout_iA),
    .inB(bitout_iB),
    .inC(bitout_iC),
    .out(bitout_iVotedC),
    .tmrErr(bitout_iTmrErrorC)
    );

majorityVoter edgedVoterC (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedC),
    .tmrErr(edgedTmrErrorC)
    );

majorityVoter stfer_iVoterC (
    .inA(stfer_iA),
    .inB(stfer_iB),
    .inC(stfer_iC),
    .out(stfer_iVotedC),
    .tmrErr(stfer_iTmrErrorC)
    );

majorityVoter stuff_iVoterC (
    .inA(stuff_iA),
    .inB(stuff_iB),
    .inC(stuff_iC),
    .out(stuff_iVotedC),
    .tmrErr(stuff_iTmrErrorC)
    );
endmodule

