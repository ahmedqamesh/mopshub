/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/dec_8b10b_wrap_structTMR.v                                                    *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:33                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: dec_8b10b_wrap_struct.v                                                                *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-28 21:55:53                                                *
 *           File Size         : 6324                                                               *
 *           MD5 hash          : 806ef65ebdd821f49dde5a11d761a347                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module dec_8b10b_wrapTMR(
  input wire [9:0] COMMAnA ,
  input wire [9:0] COMMAnB ,
  input wire [9:0] COMMAnC ,
  input wire [9:0] COMMApA ,
  input wire [9:0] COMMApB ,
  input wire [9:0] COMMApC ,
  input wire [7:0] Kchar_commaA ,
  input wire [7:0] Kchar_commaB ,
  input wire [7:0] Kchar_commaC ,
  input wire [7:0] Kchar_eopA ,
  input wire [7:0] Kchar_eopB ,
  input wire [7:0] Kchar_eopC ,
  input wire [7:0] Kchar_sopA ,
  input wire [7:0] Kchar_sopB ,
  input wire [7:0] Kchar_sopC ,
  input wire  clkA ,
  input wire  clkB ,
  input wire  clkC ,
  input wire  datain_validA ,
  input wire  datain_validB ,
  input wire  datain_validC ,
  input wire [9:0] enc10b_data_inA ,
  input wire [9:0] enc10b_data_inB ,
  input wire [9:0] enc10b_data_inC ,
  input wire  rstA ,
  input wire  rstB ,
  input wire  rstC ,
  output wire [1:0] ISKA ,
  output wire [1:0] ISKB ,
  output wire [1:0] ISKC ,
  output wire [7:0] dec8b_data_outA ,
  output wire [7:0] dec8b_data_outB ,
  output wire [7:0] dec8b_data_outC ,
  output wire  dec8b_rdyA ,
  output wire  dec8b_rdyB ,
  output wire  dec8b_rdyC 
);
wire disp_err;
wire [7:0] decoder_out;
wire code_err;
wire ISK_char;
wor rstTmrError;
wire rst;
wor enc10b_data_inTmrError;
wire [9:0] enc10b_data_in;
wor datain_validTmrError;
wire datain_valid;
wor clkTmrError;
wire clk;
reg  [9:0] EOBnA ;
reg  [9:0] EOBnB ;
reg  [9:0] EOBnC ;
reg  [9:0] EOBpA ;
reg  [9:0] EOBpB ;
reg  [9:0] EOBpC ;
reg  [9:0] EOCnA ;
reg  [9:0] EOCnB ;
reg  [9:0] EOCnC ;
reg  [9:0] EOCpA ;
reg  [9:0] EOCpB ;
reg  [9:0] EOCpC ;
wire ISK_charA;
wire ISK_charB;
wire ISK_charC;
wire ISK_commaA;
wire ISK_commaB;
wire ISK_commaC;
wire ISK_eobA;
wire ISK_eobB;
wire ISK_eobC;
wire ISK_eocA;
wire ISK_eocB;
wire ISK_eocC;
reg  [1:0] ISK_rA ;
reg  [1:0] ISK_rB ;
reg  [1:0] ISK_rC ;
wire ISK_sobA;
wire ISK_sobB;
wire ISK_sobC;
wire ISK_socA;
wire ISK_socB;
wire ISK_socC;
wire [1:0] ISKcodeA;
wire [1:0] ISKcodeB;
wire [1:0] ISKcodeC;
reg  [1:0] ISKcode_rA ;
reg  [1:0] ISKcode_rB ;
reg  [1:0] ISKcode_rC ;
reg  [9:0] SOBnA ;
reg  [9:0] SOBnB ;
reg  [9:0] SOBnC ;
reg  [9:0] SOBpA ;
reg  [9:0] SOBpB ;
reg  [9:0] SOBpC ;
reg  [9:0] SOCnA ;
reg  [9:0] SOCnB ;
reg  [9:0] SOCnC ;
reg  [9:0] SOCpA ;
reg  [9:0] SOCpB ;
reg  [9:0] SOCpC ;
reg  busy_rA ;
reg  busy_rB ;
reg  busy_rC ;
wire code_errA;
wire code_errB;
wire code_errC;
wire dataout_validA;
wire dataout_validB;
wire dataout_validC;
reg  dataout_valid_rA ;
reg  dataout_valid_rB ;
reg  dataout_valid_rC ;
reg  [7:0] dec8b_data_rA ;
reg  [7:0] dec8b_data_rB ;
reg  [7:0] dec8b_data_rC ;
reg  dec8b_rdy_rA ;
reg  dec8b_rdy_rB ;
reg  dec8b_rdy_rC ;
wire [7:0] decoder_outA;
wire [7:0] decoder_outB;
wire [7:0] decoder_outC;
wire disp_errA;
wire disp_errB;
wire disp_errC;
reg  flag_packA ;
reg  flag_packB ;
reg  flag_packC ;
wire valid_char_commaA;
wire valid_char_commaB;
wire valid_char_commaC;
wire valid_char_eopA;
wire valid_char_eopB;
wire valid_char_eopC;
wire valid_char_sopA;
wire valid_char_sopB;
wire valid_char_sopC;

dec_8b10b dec_8b10b0 (
    .rst(rst),
    .clk(clk),
    .datain(enc10b_data_in),
    .datain_valid(datain_valid),
    .ko(ISK_char),
    .dataout(decoder_out),
    .code_err(code_err),
    .disp_err(disp_err)
    );
assign ISK_commaA =  (enc10b_data_inA==COMMApA|enc10b_data_inA==COMMAnA) ? 1 : 0;
assign ISK_commaB =  (enc10b_data_inB==COMMApB|enc10b_data_inB==COMMAnB) ? 1 : 0;
assign ISK_commaC =  (enc10b_data_inC==COMMApC|enc10b_data_inC==COMMAnC) ? 1 : 0;
assign ISK_socA =  (enc10b_data_inA==SOCpA|enc10b_data_inA==SOCnA) ? 1 : 0;
assign ISK_socB =  (enc10b_data_inB==SOCpB|enc10b_data_inB==SOCnB) ? 1 : 0;
assign ISK_socC =  (enc10b_data_inC==SOCpC|enc10b_data_inC==SOCnC) ? 1 : 0;
assign ISK_eocA =  (enc10b_data_inA==EOCpA|enc10b_data_inA==EOCnA) ? 1 : 0;
assign ISK_eocB =  (enc10b_data_inB==EOCpB|enc10b_data_inB==EOCnB) ? 1 : 0;
assign ISK_eocC =  (enc10b_data_inC==EOCpC|enc10b_data_inC==EOCnC) ? 1 : 0;
assign ISK_sobA =  (enc10b_data_inA==SOBpA|enc10b_data_inA==SOBnA) ? 1 : 0;
assign ISK_sobB =  (enc10b_data_inB==SOBpB|enc10b_data_inB==SOBnB) ? 1 : 0;
assign ISK_sobC =  (enc10b_data_inC==SOBpC|enc10b_data_inC==SOBnC) ? 1 : 0;
assign ISK_eobA =  (enc10b_data_inA==EOBpA|enc10b_data_inA==EOBnA) ? 1 : 0;
assign ISK_eobB =  (enc10b_data_inB==EOBpB|enc10b_data_inB==EOBnB) ? 1 : 0;
assign ISK_eobC =  (enc10b_data_inC==EOBpC|enc10b_data_inC==EOBnC) ? 1 : 0;
assign ISKcodeA[0]  =  ((! ISK_socA )&(ISK_eocA^ISK_commaA))|ISK_sobA|ISK_eobA;
assign ISKcodeB[0]  =  ((! ISK_socB )&(ISK_eocB^ISK_commaB))|ISK_sobB|ISK_eobB;
assign ISKcodeC[0]  =  ((! ISK_socC )&(ISK_eocC^ISK_commaC))|ISK_sobC|ISK_eobC;
assign ISKcodeA[1]  =  ((! ISK_eocA )&(ISK_socA^ISK_commaA))|ISK_sobA|ISK_eobA;
assign ISKcodeB[1]  =  ((! ISK_eocB )&(ISK_socB^ISK_commaB))|ISK_sobB|ISK_eobB;
assign ISKcodeC[1]  =  ((! ISK_eocC )&(ISK_socC^ISK_commaC))|ISK_sobC|ISK_eobC;

always @( posedge clkA )
  if (!rstA)
    begin
      busy_rA <= 0;
      ISKcode_rA <= 2'b0;
    end
  else
    begin
      ISKcode_rA <= ISKcodeA;
      if (ISK_eobA==1)
        busy_rA <= 0;
      else
        if (ISK_sobA==1)
          busy_rA <= 1;
    end

always @( posedge clkB )
  if (!rstB)
    begin
      busy_rB <= 0;
      ISKcode_rB <= 2'b0;
    end
  else
    begin
      ISKcode_rB <= ISKcodeB;
      if (ISK_eobB==1)
        busy_rB <= 0;
      else
        if (ISK_sobB==1)
          busy_rB <= 1;
    end

always @( posedge clkC )
  if (!rstC)
    begin
      busy_rC <= 0;
      ISKcode_rC <= 2'b0;
    end
  else
    begin
      ISKcode_rC <= ISKcodeC;
      if (ISK_eobC==1)
        busy_rC <= 0;
      else
        if (ISK_sobC==1)
          busy_rC <= 1;
    end

always @( posedge clkA )
  if (!rstA)
    begin
      ISK_rA <= 2'b00;
    end
  else
    begin
      if (ISK_charA==1)
        ISK_rA <= ISKcode_rA;
      else
        ISK_rA <= 2'b00;
    end

always @( posedge clkB )
  if (!rstB)
    begin
      ISK_rB <= 2'b00;
    end
  else
    begin
      if (ISK_charB==1)
        ISK_rB <= ISKcode_rB;
      else
        ISK_rB <= 2'b00;
    end

always @( posedge clkC )
  if (!rstC)
    begin
      ISK_rC <= 2'b00;
    end
  else
    begin
      if (ISK_charC==1)
        ISK_rC <= ISKcode_rC;
      else
        ISK_rC <= 2'b00;
    end

always @( posedge clkA )
  if (!rstA)
    begin
      dataout_valid_rA <= 1'b0;
    end
  else
    begin
      if (datain_validA)
        dataout_valid_rA <= 1'b1;
      else
        dataout_valid_rA <= 1'b0;
    end

always @( posedge clkB )
  if (!rstB)
    begin
      dataout_valid_rB <= 1'b0;
    end
  else
    begin
      if (datain_validB)
        dataout_valid_rB <= 1'b1;
      else
        dataout_valid_rB <= 1'b0;
    end

always @( posedge clkC )
  if (!rstC)
    begin
      dataout_valid_rC <= 1'b0;
    end
  else
    begin
      if (datain_validC)
        dataout_valid_rC <= 1'b1;
      else
        dataout_valid_rC <= 1'b0;
    end
initial
  begin
    dataout_valid_rA =  0;
    dec8b_data_rA =  0;
    dec8b_rdy_rA =  0;
    flag_packA =  0;
    ISK_rA =  0;
    ISKcode_rA =  2'b0;
    EOBnA =  10'b1100001100;
    EOBpA =  10'b0011110011;
    EOCnA =  10'b1100001001;
    EOCpA =  10'b0011110110;
    SOBnA =  10'b1100001010;
    SOBpA =  10'b0011110101;
    SOCnA =  10'b1100000110;
    SOCpA =  10'b0011111001;
  end
initial
  begin
    dataout_valid_rB =  0;
    dec8b_data_rB =  0;
    dec8b_rdy_rB =  0;
    flag_packB =  0;
    ISK_rB =  0;
    ISKcode_rB =  2'b0;
    EOBnB =  10'b1100001100;
    EOBpB =  10'b0011110011;
    EOCnB =  10'b1100001001;
    EOCpB =  10'b0011110110;
    SOBnB =  10'b1100001010;
    SOBpB =  10'b0011110101;
    SOCnB =  10'b1100000110;
    SOCpB =  10'b0011111001;
  end
initial
  begin
    dataout_valid_rC =  0;
    dec8b_data_rC =  0;
    dec8b_rdy_rC =  0;
    flag_packC =  0;
    ISK_rC =  0;
    ISKcode_rC =  2'b0;
    EOBnC =  10'b1100001100;
    EOBpC =  10'b0011110011;
    EOCnC =  10'b1100001001;
    EOCpC =  10'b0011110110;
    SOBnC =  10'b1100001010;
    SOBpC =  10'b0011110101;
    SOCnC =  10'b1100000110;
    SOCpC =  10'b0011111001;
  end
assign ISKA =  ISK_rA;
assign ISKB =  ISK_rB;
assign ISKC =  ISK_rC;
assign dataout_validA =  dataout_valid_rA;
assign dataout_validB =  dataout_valid_rB;
assign dataout_validC =  dataout_valid_rC;
assign dec8b_data_outA =  dec8b_data_rA;
assign dec8b_data_outB =  dec8b_data_rB;
assign dec8b_data_outC =  dec8b_data_rC;
assign dec8b_rdyA =  dec8b_rdy_rA;
assign dec8b_rdyB =  dec8b_rdy_rB;
assign dec8b_rdyC =  dec8b_rdy_rC;
assign valid_char_commaA =  (ISK_charA==1&decoder_outA==Kchar_commaA) ? 1 : 0;
assign valid_char_commaB =  (ISK_charB==1&decoder_outB==Kchar_commaB) ? 1 : 0;
assign valid_char_commaC =  (ISK_charC==1&decoder_outC==Kchar_commaC) ? 1 : 0;
assign valid_char_sopA =  (ISK_charA==1&decoder_outA==Kchar_sopA) ? 1 : 0;
assign valid_char_sopB =  (ISK_charB==1&decoder_outB==Kchar_sopB) ? 1 : 0;
assign valid_char_sopC =  (ISK_charC==1&decoder_outC==Kchar_sopC) ? 1 : 0;
assign valid_char_eopA =  (ISK_charA==1&decoder_outA==Kchar_eopA) ? 1 : 0;
assign valid_char_eopB =  (ISK_charB==1&decoder_outB==Kchar_eopB) ? 1 : 0;
assign valid_char_eopC =  (ISK_charC==1&decoder_outC==Kchar_eopC) ? 1 : 0;

always @( posedge clkA )
  if (!rstA)
    begin
      dec8b_rdy_rA <= 1'b0;
      flag_packA <= 1'b0;
      dec8b_data_rA <= 0;
    end
  else
    begin
      dec8b_data_rA <= decoder_outA;
      if (dec8b_rdy_rA==1)
        begin
          dec8b_rdy_rA <= 1'b0;
          flag_packA <= flag_packA;
        end
      else
        if (flag_packA==1&&dataout_validA==1&&valid_char_commaA)
          begin
            dec8b_rdy_rA <= 1'b0;
            flag_packA <= flag_packA;
          end
        else
          if (flag_packA==0&&dataout_validA==1&&valid_char_sopA)
            begin
              dec8b_rdy_rA <= 1'b1;
              flag_packA <= 1'b1;
            end
          else
            if (flag_packA==1&&dataout_validA==1&&!valid_char_eopA)
              begin
                dec8b_rdy_rA <= 1'b1;
                flag_packA <= 1'b1;
              end
            else
              if (flag_packA==1&&dataout_validA==1&&valid_char_eopA)
                begin
                  dec8b_rdy_rA <= 1'b1;
                  flag_packA <= 1'b0;
                end
              else
                begin
                  dec8b_rdy_rA <= 1'b0;
                  flag_packA <= flag_packA;
                end
    end

always @( posedge clkB )
  if (!rstB)
    begin
      dec8b_rdy_rB <= 1'b0;
      flag_packB <= 1'b0;
      dec8b_data_rB <= 0;
    end
  else
    begin
      dec8b_data_rB <= decoder_outB;
      if (dec8b_rdy_rB==1)
        begin
          dec8b_rdy_rB <= 1'b0;
          flag_packB <= flag_packB;
        end
      else
        if (flag_packB==1&&dataout_validB==1&&valid_char_commaB)
          begin
            dec8b_rdy_rB <= 1'b0;
            flag_packB <= flag_packB;
          end
        else
          if (flag_packB==0&&dataout_validB==1&&valid_char_sopB)
            begin
              dec8b_rdy_rB <= 1'b1;
              flag_packB <= 1'b1;
            end
          else
            if (flag_packB==1&&dataout_validB==1&&!valid_char_eopB)
              begin
                dec8b_rdy_rB <= 1'b1;
                flag_packB <= 1'b1;
              end
            else
              if (flag_packB==1&&dataout_validB==1&&valid_char_eopB)
                begin
                  dec8b_rdy_rB <= 1'b1;
                  flag_packB <= 1'b0;
                end
              else
                begin
                  dec8b_rdy_rB <= 1'b0;
                  flag_packB <= flag_packB;
                end
    end

always @( posedge clkC )
  if (!rstC)
    begin
      dec8b_rdy_rC <= 1'b0;
      flag_packC <= 1'b0;
      dec8b_data_rC <= 0;
    end
  else
    begin
      dec8b_data_rC <= decoder_outC;
      if (dec8b_rdy_rC==1)
        begin
          dec8b_rdy_rC <= 1'b0;
          flag_packC <= flag_packC;
        end
      else
        if (flag_packC==1&&dataout_validC==1&&valid_char_commaC)
          begin
            dec8b_rdy_rC <= 1'b0;
            flag_packC <= flag_packC;
          end
        else
          if (flag_packC==0&&dataout_validC==1&&valid_char_sopC)
            begin
              dec8b_rdy_rC <= 1'b1;
              flag_packC <= 1'b1;
            end
          else
            if (flag_packC==1&&dataout_validC==1&&!valid_char_eopC)
              begin
                dec8b_rdy_rC <= 1'b1;
                flag_packC <= 1'b1;
              end
            else
              if (flag_packC==1&&dataout_validC==1&&valid_char_eopC)
                begin
                  dec8b_rdy_rC <= 1'b1;
                  flag_packC <= 1'b0;
                end
              else
                begin
                  dec8b_rdy_rC <= 1'b0;
                  flag_packC <= flag_packC;
                end
    end

majorityVoter clkVoter (
    .inA(clkA),
    .inB(clkB),
    .inC(clkC),
    .out(clk),
    .tmrErr(clkTmrError)
    );

majorityVoter datain_validVoter (
    .inA(datain_validA),
    .inB(datain_validB),
    .inC(datain_validC),
    .out(datain_valid),
    .tmrErr(datain_validTmrError)
    );

majorityVoter #(.WIDTH(10)) enc10b_data_inVoter (
    .inA(enc10b_data_inA),
    .inB(enc10b_data_inB),
    .inC(enc10b_data_inC),
    .out(enc10b_data_in),
    .tmrErr(enc10b_data_inTmrError)
    );

majorityVoter rstVoter (
    .inA(rstA),
    .inB(rstB),
    .inC(rstC),
    .out(rst),
    .tmrErr(rstTmrError)
    );

fanout ISK_charFanout (
    .in(ISK_char),
    .outA(ISK_charA),
    .outB(ISK_charB),
    .outC(ISK_charC)
    );

fanout code_errFanout (
    .in(code_err),
    .outA(code_errA),
    .outB(code_errB),
    .outC(code_errC)
    );

fanout #(.WIDTH(8)) decoder_outFanout (
    .in(decoder_out),
    .outA(decoder_outA),
    .outB(decoder_outB),
    .outC(decoder_outC)
    );

fanout disp_errFanout (
    .in(disp_err),
    .outA(disp_errA),
    .outB(disp_errB),
    .outC(disp_errC)
    );
endmodule

