/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/macfsm2TMR.v                                                                  *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:24                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: macfsm2.v                                                                              *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? macfsm2.v)            *
 *           Modification time : 2022-11-10 21:22:58                                                *
 *           File Size         : 207351                                                             *
 *           MD5 hash          : 6288ec70a10175c0b68ef0872b03c9c7                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module macfsm2TMR(
  input wire  clock ,
  input wire  Prescale_EN ,
  input wire  reset ,
  input wire  sendpoint ,
  input wire  smplpoint ,
  input wire  crc_ok ,
  input wire  inbit ,
  input wire  stufft ,
  input wire  stuffr ,
  input wire  biterror ,
  input wire  stferror ,
  input wire  trans ,
  input wire  text ,
  input wire  erroractiv ,
  input wire  errorpassiv ,
  input wire  busof ,
  input wire  ackerror ,
  input wire  onarbit ,
  input wire  transmitter ,
  input wire  receiver ,
  input wire  error ,
  input wire  first ,
  input wire  puffer ,
  input wire  rext ,
  input wire  rrtr ,
  input wire  lt3 ,
  input wire  gt3 ,
  input wire  eq3 ,
  input wire  lt11 ,
  input wire  eq11 ,
  input wire  startrcrc ,
  input wire  rmzero ,
  input wire  starttcrc ,
  output reg [1:0] ackerror_set ,
  output reg [1:0] onarbit_set ,
  output reg [1:0] transmitter_set ,
  output reg [1:0] receiver_set ,
  output reg [1:0] error_set ,
  output reg [1:0] first_set ,
  output reg [1:0] puffer_set ,
  output reg [1:0] rext_set ,
  output reg [1:0] rrtr_set ,
  input wire [6:0] count ,
  output reg [2:0] setrmleno ,
  output reg  actvrmln ,
  output reg  actvtcrc ,
  output reg  actvrcrc ,
  output reg  actvtstf ,
  output reg  actvrstf ,
  output reg  actvtsft ,
  output reg  actvrsft ,
  output reg  actvtdct ,
  output reg  actvrdct ,
  output reg  actvtbed ,
  output reg  setbdom ,
  output reg  setbrec ,
  output reg  lcrc ,
  output reg  lmsg ,
  output reg  tshift ,
  output reg  inconerec ,
  output reg  incegtrec ,
  output reg  incegttra ,
  output reg  decrec ,
  output reg  dectra ,
  output reg  elevrecb ,
  output reg  hardsync ,
  output reg  inccount ,
  output reg  resrmlen ,
  output reg  rescount ,
  output reg  resetdst ,
  output reg  resetstf ,
  output reg  activatefast ,
  output reg  crc_shft_out ,
  output reg  en_zerointcrc ,
  output wire [7:0] statedeb 
);
parameter sync_start =8'h00;
parameter sync_sample =8'h01;
parameter sync_sum =8'h02;
parameter sync_end =8'h03;
parameter inter_sample =8'h04;
parameter inter_check =8'h05;
parameter inter_goregtran =8'h06;
parameter inter_react =8'h07;
parameter bus_idle_chk =8'h08;
parameter bus_idle_sample =8'h09;
parameter inter_transhift =8'h0a;
parameter inter_regtrancnt =8'h0b;
parameter inter_preprec =8'h0c;
parameter inter_incsigres =8'h0d;
parameter tra_arbit_tactrsftn =8'h0e;
parameter tra_arbit_tactrsftsr =8'h0f;
parameter tra_arbit_tactrsfte =8'h10;
parameter tra_arbit_tactrsfter =8'h11;
parameter tra_arbit_tnactrnsft =8'h12;
parameter tra_arbit_tsftrsmpl =8'h13;
parameter tra_arbit_tnsftrsmpl =8'h14;
parameter tra_arbit_goreceive =8'h15;
parameter tra_data_activatecrc =8'h16;
parameter tra_data_activatncrc =8'h17;
parameter tra_data_shifting =8'h18;
parameter tra_data_noshift =8'h19;
parameter tra_data_lastshift =8'h1a;
parameter tra_data_loadcrc =8'h1b;
parameter tra_crc_activatedec =8'h1c;
parameter tra_crc_activatndec =8'h1d;
parameter tra_crc_shifting =8'h1e;
parameter tra_crc_noshift =8'h1f;
parameter tra_crc_delshft =8'h20;
parameter tra_ack_sendack =8'h21;
parameter tra_ack_shifting =8'h22;
parameter tra_ack_stopack =8'h23;
parameter tra_edof_sendrecb =8'h24;
parameter tra_edof_shifting =8'h25;
parameter rec_flglen_sample =8'h26;
parameter rec_flglen_shiftstdrtr =8'h27;
parameter rec_flglen_shiftextnor =8'h28;
parameter rec_flglen_shiftdlc64 =8'h29;
parameter rec_flglen_shiftdlc32 =8'h2a;
parameter rec_flglen_shiftdlc16 =8'h2b;
parameter rec_flglen_shiftdlc8 =8'h2c;
parameter rec_flglen_shiftextrtr =8'h2d;
parameter rec_flglen_shifting =8'h2e;
parameter rec_flglen_noshift =8'h2f;
parameter rec_acptdat_sample =8'h30;
parameter rec_acptdat_shifting =8'h31;
parameter rec_acptdat_noshift =8'h32;
parameter rec_crc_rescnt =8'h33;
parameter rec_crc_sample =8'h34;
parameter rec_crc_shifting =8'h35;
parameter rec_crc_noshift =8'h36;
parameter rec_ack_recdelim =8'h37;
parameter rec_ack_prepgiveack =8'h38;
parameter rec_ack_prepnoack =8'h39;
parameter rec_ack_noack =8'h3a;
parameter rec_ack_giveack =8'h3b;
parameter rec_ack_checkack =8'h3c;
parameter rec_ack_stopack =8'h3d;
parameter rec_edof_sample =8'h3e;
parameter rec_edof_check =8'h3f;
parameter rec_edof_endrec =8'h40;
parameter rec_flglen_setdlc =8'h41;
parameter rec_acptdat_lastshift =8'h42;
parameter over_firstdom =8'h43;
parameter over_senddomb =8'h44;
parameter over_check1 =8'h45;
parameter over_preprecb =8'h46;
parameter over_wtonrecb =8'h47;
parameter over_increccounter =8'h48;
parameter over_inctracounter =8'h49;
parameter over_check2 =8'h4a;
parameter over_sendrecb =8'h4b;
parameter over_check3 =8'h4c;
parameter over_waitoclk =8'h4d;
parameter over_prepsend =8'h4e;
parameter erroractiv_firstdom =8'h4f;
parameter erroractiv_inceinsrec =8'h50;
parameter erroractiv_incachtrec =8'h51;
parameter erroractiv_incachttra =8'h52;
parameter erroractiv_senddomb =8'h53;
parameter erroractiv_check1 =8'h54;
parameter erroractiv_preprecb =8'h55;
parameter erroractiv_wtonrecb =8'h56;
parameter erroractiv_dombitdct =8'h57;
parameter erroractiv_egtdombt =8'h58;
parameter erroractiv_egtdombr =8'h59;
parameter erroractiv_check2 =8'h5a;
parameter erroractiv_sendrecb =8'h5b;
parameter erroractiv_check3 =8'h5c;
parameter erroractiv_waitoclk =8'h5d;
parameter erroractiv_prepsend =8'h5e;
parameter errorpassiv_firstrec =8'h5f;
parameter errorpassiv_inceinsrec =8'h60;
parameter errorpassiv_incachtrec =8'h61;
parameter errorpassiv_fillpuffer =8'h62;
parameter errorpassiv_incachttra =8'h63;
parameter errorpassiv_incsrecb =8'h64;
parameter errorpassiv_zersrecbi =8'h65;
parameter errorpassiv_pufferrec =8'h66;
parameter errorpassiv_zersrecbz =8'h67;
parameter errorpassiv_zersrecbo =8'h68;
parameter errorpassiv_check1 =8'h69;
parameter errorpassiv_pufferdom =8'h6a;
parameter errorpassiv_wtonrecb =8'h6b;
parameter errorpassiv_dombitdct =8'h6c;
parameter errorpassiv_egtdombt =8'h6d;
parameter errorpassiv_pufferdomi =8'h6e;
parameter errorpassiv_egtdombr =8'h6f;
parameter errorpassiv_check2 =8'h70;
parameter errorpassiv_sendrecb =8'h71;
parameter errorpassiv_check3 =8'h72;
parameter errorpassiv_waitoclk =8'h73;
parameter errorpassiv_prepsend =8'h74;
parameter errorpassiv_preprecb =8'h75;
parameter errorpassiv_newcount =8'h76;
parameter errorpassiv_prepcount =8'h77;
parameter busoff_first =8'h78;
parameter busoff_sample =8'h79;
parameter busoff_setzer =8'h7a;
parameter busoff_increm =8'h7b;
parameter busoff_deccnt =8'h7c;
parameter rec_edof_lastbit =8'h7d;
parameter rec_edof_inter =8'h7e;
parameter tra_edof_dectra =8'h7f;
parameter inter_preprec_shifting =8'h80;
parameter inter_arbit_tsftrsmpl =8'h81;
wire resetC;
wire resetB;
wire resetA;
wire [7:0] next_stateC;
wire [7:0] next_stateB;
wire [7:0] next_stateA;
wire [7:0] current_stateVC;
wire [7:0] current_stateVB;
wire [7:0] current_stateVA;
wire clockC;
wire clockB;
wire clockA;
wire Prescale_ENC;
wire Prescale_ENB;
wire Prescale_ENA;
wor current_stateTmrError;
wire [7:0] current_state;
reg  [7:0] current_stateA ;
reg  [7:0] current_stateB ;
reg  [7:0] current_stateC ;
reg  [7:0] next_state ;
wire [7:0] current_stateV =  current_state;
assign statedeb =  current_stateV;

always @( posedge clockA or negedge resetA )
  begin
    if (resetA==1'b0)
      current_stateA <= sync_start;
    else
      if (Prescale_ENA==1'b1)
        current_stateA <= next_stateA;
      else
        current_stateA <= current_stateVA;
  end

always @( posedge clockB or negedge resetB )
  begin
    if (resetB==1'b0)
      current_stateB <= sync_start;
    else
      if (Prescale_ENB==1'b1)
        current_stateB <= next_stateB;
      else
        current_stateB <= current_stateVB;
  end

always @( posedge clockC or negedge resetC )
  begin
    if (resetC==1'b0)
      current_stateC <= sync_start;
    else
      if (Prescale_ENC==1'b1)
        current_stateC <= next_stateC;
      else
        current_stateC <= current_stateVC;
  end

always @*
  begin
    rext_set <= 2'b00;
    rrtr_set <= 2'b00;
    actvtcrc <= 1'b0;
    actvrcrc <= 1'b0;
    actvtstf <= 1'b0;
    actvrstf <= 1'b0;
    actvtsft <= 1'b0;
    actvrsft <= 1'b0;
    actvtdct <= 1'b0;
    actvrdct <= 1'b1;
    actvtbed <= 1'b0;
    setbdom <= 1'b0;
    setbrec <= 1'b0;
    lcrc <= 1'b0;
    tshift <= 1'b0;
    inconerec <= 1'b0;
    incegtrec <= 1'b0;
    incegttra <= 1'b0;
    lmsg <= 1'b0;
    decrec <= 1'b0;
    dectra <= 1'b0;
    elevrecb <= 1'b0;
    resetdst <= 1'b1;
    resetstf <= 1'b1;
    hardsync <= 1'b1;
    inccount <= 1'b0;
    rescount <= 1'b0;
    setrmleno <= 0;
    actvrmln <= 1'b0;
    resrmlen <= 1'b0;
    ackerror_set <= 2'b10;
    transmitter_set <= 2'b10;
    receiver_set <= 2'b10;
    error_set <= 2'b10;
    first_set <= 2'b10;
    activatefast <= 1'b0;
    puffer_set <= 2'b10;
    onarbit_set <= 2'b10;
    en_zerointcrc <= 1'b1;
    crc_shft_out <= 1'b0;
    next_state <= current_stateV;
    case (current_stateV)
      sync_start : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b0;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= sync_sample;
          else
            next_state <= sync_start;
        end
      sync_sample : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b1)
            next_state <= sync_sum;
          else
            next_state <= sync_start;
        end
      sync_sum : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&count!=8)
            next_state <= sync_sample;
          else
            if (count==8)
              next_state <= sync_end;
            else
              next_state <= sync_sum;
        end
      sync_end : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= bus_idle_sample;
          else
            next_state <= sync_end;
        end
      inter_sample : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (busof==1'b1)
            next_state <= busoff_first;
          else
            if ((((errorpassiv==1'b0||receiver==1'b1)&&lt3==1'b1)||((errorpassiv==1'b1&&receiver==1'b0)&&lt11==1'b1))&&inbit==1'b1)
              next_state <= inter_check;
            else
              if (lt3==1'b1&&inbit==1'b0)
                next_state <= over_firstdom;
              else
                if (inbit==1'b0&&(gt3==1'b1||((eq3==1'b1||gt3==1'b1)&&((errorpassiv==1'b1&&receiver==1'b0)||trans==1'b0))))
                  next_state <= inter_preprec;
                else
                  if (sendpoint==1'b1&&(((errorpassiv==1'b0||receiver==1'b1)&&(eq3==1'b1||gt3==1'b1))||((errorpassiv==1'b1&&receiver==1'b0)&&(eq11==1'b1||lt11==1'b0)))&&inbit==1'b1&&trans==1'b1)
                    next_state <= inter_goregtran;
                  else
                    if ((errorpassiv==1'b0||receiver==1'b1)&&(eq3==1'b1||gt3==1'b1)&&inbit==1'b0&&trans==1'b1)
                      next_state <= inter_react;
                    else
                      if (trans==1'b0&&(((eq3==1'b1||gt3==1'b1)&&(errorpassiv==1'b0||receiver==1'b1))||((eq11==1'b1||lt11==1'b0)&&(errorpassiv==1'b1&&receiver==1'b0))))
                        next_state <= bus_idle_chk;
                      else
                        next_state <= inter_sample;
        end
      inter_check : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b0;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= inter_check;
        end
      bus_idle_chk : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b0;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= bus_idle_sample;
          else
            next_state <= bus_idle_chk;
        end
      bus_idle_sample : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (trans==1'b0&&inbit==1'b1)
            next_state <= bus_idle_chk;
          else
            if (inbit==1'b0&&trans==1'b0)
              next_state <= inter_preprec;
            else
              if (inbit==1'b0&&trans==1'b1)
                next_state <= inter_react;
              else
                if (sendpoint==1'b1&&inbit==1'b1&&trans==1'b1)
                  next_state <= inter_goregtran;
                else
                  next_state <= bus_idle_sample;
        end
      inter_react : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b0;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          next_state <= inter_transhift;
        end
      inter_goregtran : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b0;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b0;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          next_state <= inter_regtrancnt;
        end
      inter_regtrancnt : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b0;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_arbit_tsftrsmpl;
          else
            next_state <= inter_regtrancnt;
        end
      inter_arbit_tsftrsmpl : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= tra_arbit_tactrsftn;
          else
            next_state <= inter_arbit_tsftrsmpl;
        end
      inter_transhift : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          next_state <= inter_incsigres;
        end
      inter_incsigres : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b0;
          crc_shft_out <= 1'b0;
          next_state <= tra_arbit_tactrsftn;
        end
      inter_preprec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b0;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= inter_preprec_shifting;
        end
      inter_preprec_shifting : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= inter_preprec_shifting;
        end
      tra_arbit_tnactrnsft : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= tra_arbit_tsftrsmpl;
          else
            next_state <= tra_arbit_tnactrnsft;
        end
      tra_arbit_tactrsftn : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&stufft==1'b0)
            next_state <= tra_arbit_tsftrsmpl;
          else
            if (smplpoint==1'b1&&stufft==1'b1)
              next_state <= tra_arbit_tnsftrsmpl;
            else
              next_state <= tra_arbit_tactrsftn;
        end
      tra_arbit_tactrsftsr : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b11;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&stufft==1'b0)
            next_state <= tra_arbit_tsftrsmpl;
          else
            if (smplpoint==1'b1&&stufft==1'b1)
              next_state <= tra_arbit_tnsftrsmpl;
            else
              next_state <= tra_arbit_tactrsftsr;
        end
      tra_arbit_tactrsfte : 
        begin
          rext_set <= 2'b11;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&stufft==1'b0)
            next_state <= tra_arbit_tsftrsmpl;
          else
            if (smplpoint==1'b1&&stufft==1'b1)
              next_state <= tra_arbit_tnsftrsmpl;
            else
              next_state <= tra_arbit_tactrsfte;
        end
      tra_arbit_tactrsfter : 
        begin
          rext_set <= 2'b11;
          rrtr_set <= 2'b11;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&stufft==1'b0)
            next_state <= tra_arbit_tsftrsmpl;
          else
            if (smplpoint==1'b1&&stufft==1'b1)
              next_state <= tra_arbit_tnsftrsmpl;
            else
              next_state <= tra_arbit_tactrsfter;
        end
      tra_arbit_tsftrsmpl : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&stferror==1'b0&&count==13&&inbit==1'b1&&text==1'b1)
            next_state <= tra_arbit_tactrsftsr;
          else
            if (sendpoint==1'b1&&biterror==1'b0&&stferror==1'b0&&count==14&&inbit==1'b1)
              next_state <= tra_arbit_tactrsfte;
            else
              if (sendpoint==1'b1&&biterror==1'b0&&stferror==1'b0&&count==33&&inbit==1'b1)
                next_state <= tra_arbit_tactrsfter;
              else
                if (sendpoint==1'b1&&biterror==1'b0&&stferror==1'b0&&(inbit==1'b0||(count!=13&&count!=14&&count!=33))&&(! ( (count==13&&text==1'b0)||(count==34&&text==1'b1) ) ))
                  next_state <= tra_arbit_tactrsftn;
                else
                  if (sendpoint==1'b1&&biterror==1'b0&&stferror==1'b0&&((count==13&&text==1'b0)||(count==34&&text==1'b1)))
                    next_state <= tra_data_activatecrc;
                  else
                    if (biterror==1'b1&&stferror==1'b0)
                      next_state <= tra_arbit_goreceive;
                    else
                      next_state <= tra_arbit_tsftrsmpl;
        end
      tra_arbit_goreceive : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= tra_arbit_goreceive;
        end
      tra_arbit_tnsftrsmpl : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          hardsync <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b11;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_arbit_tnactrnsft;
          else
            if (stferror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (stferror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_arbit_tnsftrsmpl;
        end
      tra_data_activatecrc : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b1;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&stufft==1'b0&&starttcrc==1'b0)
            next_state <= tra_data_shifting;
          else
            if (smplpoint==1'b1&&stufft==1'b0&&starttcrc==1'b1)
              next_state <= tra_data_lastshift;
            else
              if (smplpoint==1'b1&&stufft==1'b1)
                next_state <= tra_data_noshift;
              else
                next_state <= tra_data_activatecrc;
        end
      tra_data_activatncrc : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&starttcrc==1'b0)
            next_state <= tra_data_shifting;
          else
            if (smplpoint==1'b1&&starttcrc==1'b1)
              next_state <= tra_data_lastshift;
            else
              next_state <= tra_data_activatncrc;
        end
      tra_data_shifting : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_data_activatecrc;
          else
            if (biterror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_data_shifting;
        end
      tra_data_lastshift : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (biterror==1'b1&&erroractiv==1'b1)
            next_state <= erroractiv_firstdom;
          else
            if (biterror==1'b1&&errorpassiv==1'b1)
              next_state <= errorpassiv_firstrec;
            else
              next_state <= tra_data_loadcrc;
        end
      tra_data_noshift : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_data_activatncrc;
          else
            if (biterror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_data_noshift;
        end
      tra_data_loadcrc : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= tra_crc_activatedec;
          else
            next_state <= tra_data_loadcrc;
        end
      tra_crc_activatedec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b1;
          if (smplpoint==1'b1&&stufft==1'b0&&count!=16)
            next_state <= tra_crc_shifting;
          else
            if (smplpoint==1'b1&&stufft==1'b0&&count==16)
              next_state <= tra_crc_delshft;
            else
              if (smplpoint==1'b1&&stufft==1'b1)
                next_state <= tra_crc_noshift;
              else
                next_state <= tra_crc_activatedec;
        end
      tra_crc_activatndec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b1;
          if (smplpoint==1'b1&&count!=16)
            next_state <= tra_crc_shifting;
          else
            if (smplpoint==1'b1&&count==16)
              next_state <= tra_crc_delshft;
            else
              next_state <= tra_crc_activatndec;
        end
      tra_crc_shifting : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b1;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_crc_activatedec;
          else
            if (biterror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_crc_shifting;
        end
      tra_crc_noshift : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b1;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_crc_activatndec;
          else
            if (biterror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_crc_noshift;
        end
      tra_crc_delshft : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b1;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b1;
          if (sendpoint==1'b1&&biterror==1'b0)
            next_state <= tra_ack_sendack;
          else
            if (biterror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= tra_crc_delshft;
        end
      tra_ack_sendack : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= tra_ack_shifting;
          else
            next_state <= tra_ack_sendack;
        end
      tra_ack_shifting : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (biterror==1'b0)
            next_state <= tra_ack_stopack;
          else
            if (sendpoint==1'b1&&biterror==1'b1)
              next_state <= tra_edof_sendrecb;
            else
              next_state <= tra_ack_shifting;
        end
      tra_ack_stopack : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b11;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (erroractiv==1'b1)
            next_state <= erroractiv_firstdom;
          else
            next_state <= errorpassiv_firstrec;
        end
      tra_edof_sendrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= tra_edof_shifting;
          else
            next_state <= tra_edof_sendrecb;
        end
      tra_edof_shifting : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=8)
            next_state <= tra_edof_sendrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b0&&count==8)
              next_state <= tra_edof_dectra;
            else
              if (biterror==1'b1&&count==8)
                next_state <= over_firstdom;
              else
                if (biterror==1'b1&&erroractiv==1'b1&&count!=8)
                  next_state <= erroractiv_firstdom;
                else
                  if (biterror==1'b1&&errorpassiv==1'b1&&count!=8)
                    next_state <= errorpassiv_firstrec;
                  else
                    next_state <= tra_edof_shifting;
        end
      tra_edof_dectra : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b1;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b11;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= tra_edof_dectra;
        end
      rec_flglen_sample : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (stuffr==1'b1&&stferror==1'b0)
            next_state <= rec_flglen_noshift;
          else
            if (stferror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (stferror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==12)
                  next_state <= rec_flglen_shiftstdrtr;
                else
                  if ((stuffr==1'b0)&&(stferror==1'b0)&&(inbit==1'b1)&&(count==13))
                    next_state <= rec_flglen_shiftextnor;
                  else
                    if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==15&&rrtr==1'b0&&rext==1'b0)
                      next_state <= rec_flglen_shiftdlc64;
                    else
                      if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==16&&rrtr==1'b0&&rext==1'b0)
                        next_state <= rec_flglen_shiftdlc32;
                      else
                        if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==17&&rrtr==1'b0&&rext==1'b0)
                          next_state <= rec_flglen_shiftdlc16;
                        else
                          if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==18&&rrtr==1'b0&&rext==1'b0)
                            next_state <= rec_flglen_shiftdlc8;
                          else
                            if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==32&&rext==1'b1)
                              next_state <= rec_flglen_shiftextrtr;
                            else
                              if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==35&&rrtr==1'b0&&rext==1'b1)
                                next_state <= rec_flglen_shiftdlc64;
                              else
                                if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==36&&rrtr==1'b0&&rext==1'b1)
                                  next_state <= rec_flglen_shiftdlc32;
                                else
                                  if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==37&&rrtr==1'b0&&rext==1'b1)
                                    next_state <= rec_flglen_shiftdlc16;
                                  else
                                    if (stuffr==1'b0&&stferror==1'b0&&inbit==1'b1&&count==38&&rrtr==1'b0&&rext==1'b1)
                                      next_state <= rec_flglen_shiftdlc8;
                                    else
                                      if (stuffr==1'b0&&stferror==1'b0&&(inbit==1'b0||(count!=12&&count!=13&&(rext==1'b1||rrtr==1'b1||(count!=15&&count!=16&&count!=17&&count!=18))&&(count!=32||rext==1'b0)&&(rext==1'b0||rrtr==1'b1||(count!=35&&count!=36&&count!=37&&count!=38)))))
                                        next_state <= rec_flglen_shifting;
                                      else
                                        next_state <= rec_flglen_sample;
        end
      rec_flglen_shifting : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&(! ( (count==19&&rext==1'b0)||(count==39&&rext==1'b1) ) ))
            next_state <= rec_flglen_sample;
          else
            if (smplpoint==1'b1&&((count==19&&rext==1'b0)||(count==39&&rext==1'b1))&&rrtr==1'b0&&rmzero==1'b0)
              next_state <= rec_acptdat_sample;
            else
              if (smplpoint==1'b1&&((count==19&&rext==1'b0)||(count==39&&rext==1'b1))&&(rrtr==1'b1||rmzero==1'b1))
                next_state <= rec_crc_rescnt;
              else
                next_state <= rec_flglen_shifting;
        end
      rec_flglen_shiftstdrtr : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b11;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= rec_flglen_shiftstdrtr;
        end
      rec_flglen_shiftextnor : 
        begin
          rext_set <= 2'b11;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= rec_flglen_shiftextnor;
        end
      rec_flglen_shiftdlc64 : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 4;
          actvrmln <= 1'b1;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc32 : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 3;
          actvrmln <= 1'b1;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc16 : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 2;
          actvrmln <= 1'b1;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc8 : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 1;
          actvrmln <= 1'b1;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= rec_flglen_setdlc;
        end
      rec_flglen_setdlc : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 7;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&(! ( (count==19&&rext==1'b0)||(count==39&&rext==1'b1) ) ))
            next_state <= rec_flglen_sample;
          else
            if (smplpoint==1'b1&&((count==19&&rext==1'b0)||(count==39&&rext==1'b1))&&rrtr==1'b0)
              next_state <= rec_acptdat_sample;
            else
              next_state <= rec_flglen_setdlc;
        end
      rec_flglen_shiftextrtr : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b11;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= rec_flglen_shiftextrtr;
        end
      rec_flglen_noshift : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_flglen_sample;
          else
            next_state <= rec_flglen_noshift;
        end
      rec_acptdat_sample : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (stuffr==1'b1&&stferror==1'b0)
            next_state <= rec_acptdat_noshift;
          else
            if (stferror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (stferror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                next_state <= rec_acptdat_shifting;
        end
      rec_acptdat_shifting : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&startrcrc==1'b0)
            next_state <= rec_acptdat_sample;
          else
            if (startrcrc==1'b1)
              next_state <= rec_acptdat_lastshift;
            else
              next_state <= rec_acptdat_shifting;
        end
      rec_acptdat_noshift : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_acptdat_sample;
          else
            next_state <= rec_acptdat_noshift;
        end
      rec_acptdat_lastshift : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_crc_rescnt;
          else
            next_state <= rec_acptdat_lastshift;
        end
      rec_crc_rescnt : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b1;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= rec_crc_sample;
        end
      rec_crc_sample : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (stuffr==1'b1&&stferror==1'b0)
            next_state <= rec_crc_noshift;
          else
            if (stferror==1'b1&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (stferror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                if (count==15)
                  next_state <= rec_ack_recdelim;
                else
                  next_state <= rec_crc_shifting;
        end
      rec_crc_shifting : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b1;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b1;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_crc_sample;
          else
            next_state <= rec_crc_shifting;
        end
      rec_crc_noshift : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b1;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_crc_sample;
          else
            next_state <= rec_crc_noshift;
        end
      rec_ack_recdelim : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b1&&crc_ok==1'b0)
            next_state <= rec_ack_prepnoack;
          else
            if (inbit==1'b0&&erroractiv==1'b1)
              next_state <= erroractiv_firstdom;
            else
              if (inbit==1'b0&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                if (inbit==1'b0&&busof==1'b1)
                  next_state <= busoff_first;
                else
                  next_state <= rec_ack_prepgiveack;
        end
      rec_ack_prepgiveack : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b1;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= rec_ack_giveack;
          else
            next_state <= rec_ack_prepgiveack;
        end
      rec_ack_giveack : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_ack_checkack;
          else
            next_state <= rec_ack_giveack;
        end
      rec_ack_checkack : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (biterror==1'b1&&erroractiv==1'b1)
            next_state <= erroractiv_firstdom;
          else
            if (biterror==1'b1&&errorpassiv==1'b1)
              next_state <= errorpassiv_firstrec;
            else
              if (sendpoint==1'b1)
                next_state <= rec_ack_stopack;
              else
                next_state <= rec_ack_checkack;
        end
      rec_ack_prepnoack : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= rec_ack_noack;
          else
            next_state <= rec_ack_prepnoack;
        end
      rec_ack_noack : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&erroractiv==1'b1)
            next_state <= erroractiv_firstdom;
          else
            if (smplpoint==1'b1&&errorpassiv==1'b1)
              next_state <= errorpassiv_firstrec;
            else
              if (smplpoint==1'b1&&busof==1'b1)
                next_state <= busoff_first;
              else
                next_state <= rec_ack_noack;
        end
      rec_ack_stopack : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_edof_sample;
          else
            next_state <= rec_ack_stopack;
        end
      rec_edof_sample : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b0&&erroractiv==1'b1)
            next_state <= erroractiv_firstdom;
          else
            if (inbit==1'b0&&errorpassiv==1'b1)
              next_state <= errorpassiv_firstrec;
            else
              next_state <= rec_edof_check;
        end
      rec_edof_check : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (count!=7&&smplpoint==1'b1)
            next_state <= rec_edof_sample;
          else
            if (count==7&&inbit==1'b1)
              next_state <= rec_edof_endrec;
            else
              next_state <= rec_edof_check;
        end
      rec_edof_endrec : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b1;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= rec_edof_lastbit;
          else
            next_state <= rec_edof_endrec;
        end
      rec_edof_lastbit : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b1)
            next_state <= rec_edof_inter;
          else
            if (inbit==1'b0)
              next_state <= over_firstdom;
            else
              next_state <= rec_edof_lastbit;
        end
      rec_edof_inter : 
        begin
          rext_set <= 2'b00;
          rrtr_set <= 2'b00;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b11;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= rec_edof_inter;
        end
      over_firstdom : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= over_senddomb;
          else
            next_state <= over_firstdom;
        end
      over_senddomb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= over_check1;
          else
            next_state <= over_senddomb;
        end
      over_check1 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=6)
            next_state <= over_senddomb;
          else
            if (biterror==1'b0&&count==6)
              next_state <= over_preprecb;
            else
              if (biterror==1'b1&&erroractiv==1'b1)
                next_state <= erroractiv_firstdom;
              else
                if (biterror==1'b1&&errorpassiv==1'b1)
                  next_state <= errorpassiv_firstrec;
                else
                  if (biterror==1'b1&&busof==1'b1)
                    next_state <= busoff_first;
                  else
                    next_state <= over_check1;
        end
      over_preprecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= over_wtonrecb;
          else
            next_state <= over_preprecb;
        end
      over_wtonrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= over_check2;
          else
            next_state <= over_wtonrecb;
        end
      over_inctracounter : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= over_check2;
          else
            next_state <= over_inctracounter;
        end
      over_increccounter : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= over_check2;
          else
            next_state <= over_increccounter;
        end
      over_check2 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b1&&count!=7)
            next_state <= over_wtonrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b1&&count==7&&receiver==1'b1)
              next_state <= over_increccounter;
            else
              if (sendpoint==1'b1&&biterror==1'b1&&count==7&&transmitter==1'b1)
                next_state <= over_inctracounter;
              else
                if (biterror==1'b0)
                  next_state <= over_prepsend;
                else
                  next_state <= over_check2;
        end
      over_prepsend : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= over_sendrecb;
          else
            next_state <= over_prepsend;
        end
      over_sendrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= over_check3;
          else
            next_state <= over_sendrecb;
        end
      over_check3 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=7)
            next_state <= over_sendrecb;
          else
            if (biterror==1'b0&&count==7)
              next_state <= over_waitoclk;
            else
              if (biterror==1'b1&&count==7)
                next_state <= over_firstdom;
              else
                if (biterror==1'b1&&erroractiv==1'b1&&count!=7)
                  next_state <= erroractiv_firstdom;
                else
                  if (biterror==1'b1&&errorpassiv==1'b1&&count!=7)
                    next_state <= errorpassiv_firstrec;
                  else
                    if (biterror==1'b1&&busof==1'b1&&count!=7)
                      next_state <= busoff_first;
                    else
                      next_state <= over_check3;
        end
      over_waitoclk : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= over_waitoclk;
        end
      erroractiv_firstdom : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b00;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b00;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&onarbit==1'b1)
            next_state <= erroractiv_senddomb;
          else
            if (onarbit==1'b0&&transmitter==1'b0&&receiver==1'b1&&error==1'b0)
              next_state <= erroractiv_inceinsrec;
            else
              if (onarbit==1'b0&&transmitter==1'b0&&receiver==1'b1&&error==1'b1)
                next_state <= erroractiv_incachtrec;
              else
                if (onarbit==1'b0&&transmitter==1'b1)
                  next_state <= erroractiv_incachttra;
                else
                  next_state <= erroractiv_firstdom;
        end
      erroractiv_inceinsrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b1;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= erroractiv_senddomb;
          else
            next_state <= erroractiv_inceinsrec;
        end
      erroractiv_incachtrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= erroractiv_senddomb;
          else
            next_state <= erroractiv_incachtrec;
        end
      erroractiv_incachttra : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= erroractiv_senddomb;
          else
            next_state <= erroractiv_incachttra;
        end
      erroractiv_senddomb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check1;
          else
            next_state <= erroractiv_senddomb;
        end
      erroractiv_check1 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b1;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=6)
            next_state <= erroractiv_senddomb;
          else
            if (biterror==1'b0&&count==6)
              next_state <= erroractiv_preprecb;
            else
              if (biterror==1'b1&&erroractiv==1'b1)
                next_state <= erroractiv_firstdom;
              else
                if (biterror==1'b1&&errorpassiv==1'b1)
                  next_state <= errorpassiv_firstrec;
                else
                  if (biterror==1'b1&&busof==1'b1)
                    next_state <= busoff_first;
                  else
                    next_state <= erroractiv_check1;
        end
      erroractiv_preprecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= erroractiv_wtonrecb;
          else
            next_state <= erroractiv_preprecb;
        end
      erroractiv_wtonrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b00;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check2;
          else
            next_state <= erroractiv_wtonrecb;
        end
      erroractiv_dombitdct : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check2;
          else
            next_state <= erroractiv_dombitdct;
        end
      erroractiv_egtdombr : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check2;
          else
            next_state <= erroractiv_egtdombr;
        end
      erroractiv_egtdombt : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check2;
          else
            next_state <= erroractiv_egtdombt;
        end
      erroractiv_check2 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b00;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b1&&count!=7&&(count!=1||receiver==1'b0||first==1'b0))
            next_state <= erroractiv_wtonrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b1&&count==1&&receiver==1'b1&&first==1'b1)
              next_state <= erroractiv_dombitdct;
            else
              if (sendpoint==1'b1&&biterror==1'b1&&count==7&&transmitter==1'b1&&receiver==1'b0)
                next_state <= erroractiv_egtdombt;
              else
                if (sendpoint==1'b1&&biterror==1'b1&&count==7&&transmitter==1'b0&&receiver==1'b1)
                  next_state <= erroractiv_egtdombr;
                else
                  if (biterror==1'b0)
                    next_state <= erroractiv_prepsend;
                  else
                    next_state <= erroractiv_check2;
        end
      erroractiv_prepsend : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= erroractiv_sendrecb;
          else
            next_state <= erroractiv_prepsend;
        end
      erroractiv_sendrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= erroractiv_check3;
          else
            next_state <= erroractiv_sendrecb;
        end
      erroractiv_check3 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=7)
            next_state <= erroractiv_sendrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b0&&count==7)
              next_state <= erroractiv_waitoclk;
            else
              if (biterror==1'b1&&erroractiv==1'b1)
                next_state <= erroractiv_firstdom;
              else
                if (biterror==1'b1&&errorpassiv==1'b1)
                  next_state <= errorpassiv_firstrec;
                else
                  if (biterror==1'b1&&busof==1'b1)
                    next_state <= busoff_first;
                  else
                    next_state <= erroractiv_check3;
        end
      erroractiv_waitoclk : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= erroractiv_waitoclk;
        end
      errorpassiv_firstrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b00;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b00;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&transmitter==1'b1&&(onarbit==1'b1||ackerror==1'b1))
            next_state <= errorpassiv_incsrecb;
          else
            if (onarbit==1'b0&&transmitter==1'b0&&receiver==1'b1&&error==1'b0)
              next_state <= errorpassiv_inceinsrec;
            else
              if (onarbit==1'b0&&transmitter==1'b0&&receiver==1'b1&&error==1'b1)
                next_state <= errorpassiv_incachtrec;
              else
                if (onarbit==1'b0&&transmitter==1'b1&&ackerror==1'b0)
                  next_state <= errorpassiv_incachttra;
                else
                  next_state <= errorpassiv_firstrec;
        end
      errorpassiv_inceinsrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b1;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_inceinsrec;
        end
      errorpassiv_incachtrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_incachtrec;
        end
      errorpassiv_incachttra : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_incachttra;
        end
      errorpassiv_incsrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b00;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&count!=0)
            next_state <= errorpassiv_check1;
          else
            if (smplpoint==1'b1&&count==0)
              next_state <= errorpassiv_fillpuffer;
            else
              next_state <= errorpassiv_incsrecb;
        end
      errorpassiv_fillpuffer : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b0&&transmitter==1'b1&&ackerror==1'b1)
            next_state <= errorpassiv_pufferdomi;
          else
            if (inbit==1'b0&&(transmitter==1'b0||ackerror==1'b0))
              next_state <= errorpassiv_pufferdom;
            else
              next_state <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferrec : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b11;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferdom : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_pufferdom;
        end
      errorpassiv_pufferdomi : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_incsrecb;
          else
            next_state <= errorpassiv_pufferdomi;
        end
      errorpassiv_zersrecbo : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b11;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbz : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbi : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= errorpassiv_newcount;
        end
      errorpassiv_newcount : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b00;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          next_state <= errorpassiv_prepcount;
        end
      errorpassiv_prepcount : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b00;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check1;
          else
            next_state <= errorpassiv_prepcount;
        end
      errorpassiv_check1 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b00;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b00;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==puffer&&biterror==1'b1&&transmitter==1'b1&&ackerror==1'b1)
            next_state <= errorpassiv_zersrecbi;
          else
            if (sendpoint==1'b1&&biterror==puffer&&biterror==1'b1&&(ackerror==1'b0||transmitter==1'b0))
              next_state <= errorpassiv_zersrecbz;
            else
              if (sendpoint==1'b1&&biterror==puffer&&biterror==1'b0)
                next_state <= errorpassiv_zersrecbo;
              else
                if (sendpoint==1'b1&&biterror!=puffer&&count!=6)
                  next_state <= errorpassiv_incsrecb;
                else
                  if (biterror!=puffer&&count==6)
                    next_state <= errorpassiv_preprecb;
                  else
                    next_state <= errorpassiv_check1;
        end
      errorpassiv_preprecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b11;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_wtonrecb;
          else
            next_state <= errorpassiv_preprecb;
        end
      errorpassiv_wtonrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b00;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check2;
          else
            next_state <= errorpassiv_wtonrecb;
        end
      errorpassiv_dombitdct : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check2;
          else
            next_state <= errorpassiv_dombitdct;
        end
      errorpassiv_egtdombr : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b1;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check2;
          else
            next_state <= errorpassiv_egtdombr;
        end
      errorpassiv_egtdombt : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b1;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check2;
          else
            next_state <= errorpassiv_egtdombt;
        end
      errorpassiv_check2 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b00;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b1&&count!=7&&(count!=1||receiver==1'b0||first==1'b0))
            next_state <= errorpassiv_wtonrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b1&&count==1&&receiver==1'b1&&first==1'b1)
              next_state <= errorpassiv_dombitdct;
            else
              if (sendpoint==1'b1&&biterror==1'b1&&count==7&&transmitter==1'b1&&receiver==1'b0)
                next_state <= errorpassiv_egtdombt;
              else
                if (sendpoint==1'b1&&biterror==1'b1&&count==7&&transmitter==1'b0&&receiver==1'b1)
                  next_state <= errorpassiv_egtdombr;
                else
                  if (biterror==1'b0)
                    next_state <= errorpassiv_prepsend;
                  else
                    next_state <= errorpassiv_check2;
        end
      errorpassiv_prepsend : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1)
            next_state <= errorpassiv_sendrecb;
          else
            next_state <= errorpassiv_prepsend;
        end
      errorpassiv_sendrecb : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b1;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b1;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= errorpassiv_check3;
          else
            next_state <= errorpassiv_sendrecb;
        end
      errorpassiv_check3 : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b1;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (sendpoint==1'b1&&biterror==1'b0&&count!=7)
            next_state <= errorpassiv_sendrecb;
          else
            if (sendpoint==1'b1&&biterror==1'b0&&count==7)
              next_state <= errorpassiv_waitoclk;
            else
              if (biterror==1'b1&&errorpassiv==1'b1)
                next_state <= errorpassiv_firstrec;
              else
                if (biterror==1'b1&&busof==1'b1)
                  next_state <= busoff_first;
                else
                  next_state <= errorpassiv_check3;
        end
      errorpassiv_waitoclk : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b1;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b0;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b1;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b00;
          receiver_set <= 2'b00;
          error_set <= 2'b11;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= inter_sample;
          else
            next_state <= errorpassiv_waitoclk;
        end
      busoff_first : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= busoff_sample;
          else
            next_state <= busoff_first;
        end
      busoff_sample : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b1;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (inbit==1'b1&&count!=10)
            next_state <= busoff_increm;
          else
            if (inbit==1'b1&&count==10)
              next_state <= busoff_deccnt;
            else
              next_state <= busoff_setzer;
        end
      busoff_increm : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b1;
          rescount <= 1'b1;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= busoff_sample;
          else
            next_state <= busoff_increm;
        end
      busoff_setzer : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b0;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b1;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1)
            next_state <= busoff_sample;
          else
            next_state <= busoff_setzer;
        end
      busoff_deccnt : 
        begin
          rext_set <= 2'b10;
          rrtr_set <= 2'b10;
          actvtcrc <= 1'b0;
          actvrcrc <= 1'b0;
          actvtstf <= 1'b0;
          actvrstf <= 1'b0;
          actvtsft <= 1'b0;
          actvrsft <= 1'b0;
          actvtdct <= 1'b0;
          actvrdct <= 1'b1;
          actvtbed <= 1'b0;
          setbdom <= 1'b0;
          setbrec <= 1'b0;
          lcrc <= 1'b0;
          tshift <= 1'b0;
          inconerec <= 1'b0;
          incegtrec <= 1'b0;
          incegttra <= 1'b0;
          lmsg <= 1'b0;
          decrec <= 1'b0;
          dectra <= 1'b0;
          elevrecb <= 1'b1;
          hardsync <= 1'b0;
          resetdst <= 1'b1;
          resetstf <= 1'b0;
          inccount <= 1'b0;
          rescount <= 1'b0;
          setrmleno <= 0;
          actvrmln <= 1'b0;
          resrmlen <= 1'b1;
          ackerror_set <= 2'b10;
          transmitter_set <= 2'b10;
          receiver_set <= 2'b10;
          error_set <= 2'b10;
          first_set <= 2'b10;
          activatefast <= 1'b0;
          puffer_set <= 2'b10;
          onarbit_set <= 2'b10;
          en_zerointcrc <= 1'b1;
          crc_shft_out <= 1'b0;
          if (smplpoint==1'b1&&busof==1'b1)
            next_state <= busoff_sample;
          else
            if (smplpoint==1'b1&&busof==1'b0)
              next_state <= inter_sample;
            else
              next_state <= busoff_deccnt;
        end
      default : 
        begin
        end
    endcase
  end

majorityVoter #(.WIDTH(8)) current_stateVoter (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_state),
    .tmrErr(current_stateTmrError)
    );

fanout Prescale_ENFanout (
    .in(Prescale_EN),
    .outA(Prescale_ENA),
    .outB(Prescale_ENB),
    .outC(Prescale_ENC)
    );

fanout clockFanout (
    .in(clock),
    .outA(clockA),
    .outB(clockB),
    .outC(clockC)
    );

fanout #(.WIDTH(8)) current_stateVFanout (
    .in(current_stateV),
    .outA(current_stateVA),
    .outB(current_stateVB),
    .outC(current_stateVC)
    );

fanout #(.WIDTH(8)) next_stateFanout (
    .in(next_state),
    .outA(next_stateA),
    .outB(next_stateB),
    .outC(next_stateC)
    );

fanout resetFanout (
    .in(reset),
    .outA(resetA),
    .outB(resetB),
    .outC(resetC)
    );
endmodule

