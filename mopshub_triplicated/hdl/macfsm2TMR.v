/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/macfsm2TMR.v                                                                  *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 16/08/2022 12:58:31                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/mopshub_top_board_canakari_ftrim/hdl   *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -c tmrg.cfg -vvv  *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: macfsm2.v                                                                              *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-29 13:49:21                                                *
 *           File Size         : 207348                                                             *
 *           MD5 hash          : d270896709851c64968d634119cdd133                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module macfsm2TMR(
  input wire  clockA ,
  input wire  clockB ,
  input wire  clockC ,
  input wire  Prescale_ENA ,
  input wire  Prescale_ENB ,
  input wire  Prescale_ENC ,
  input wire  resetA ,
  input wire  resetB ,
  input wire  resetC ,
  input wire  sendpointA ,
  input wire  sendpointB ,
  input wire  sendpointC ,
  input wire  smplpointA ,
  input wire  smplpointB ,
  input wire  smplpointC ,
  input wire  crc_okA ,
  input wire  crc_okB ,
  input wire  crc_okC ,
  input wire  inbitA ,
  input wire  inbitB ,
  input wire  inbitC ,
  input wire  stufftA ,
  input wire  stufftB ,
  input wire  stufftC ,
  input wire  stuffrA ,
  input wire  stuffrB ,
  input wire  stuffrC ,
  input wire  biterrorA ,
  input wire  biterrorB ,
  input wire  biterrorC ,
  input wire  stferrorA ,
  input wire  stferrorB ,
  input wire  stferrorC ,
  input wire  transA ,
  input wire  transB ,
  input wire  transC ,
  input wire  textA ,
  input wire  textB ,
  input wire  textC ,
  input wire  erroractivA ,
  input wire  erroractivB ,
  input wire  erroractivC ,
  input wire  errorpassivA ,
  input wire  errorpassivB ,
  input wire  errorpassivC ,
  input wire  busofA ,
  input wire  busofB ,
  input wire  busofC ,
  input wire  ackerrorA ,
  input wire  ackerrorB ,
  input wire  ackerrorC ,
  input wire  onarbitA ,
  input wire  onarbitB ,
  input wire  onarbitC ,
  input wire  transmitterA ,
  input wire  transmitterB ,
  input wire  transmitterC ,
  input wire  receiverA ,
  input wire  receiverB ,
  input wire  receiverC ,
  input wire  errorA ,
  input wire  errorB ,
  input wire  errorC ,
  input wire  firstA ,
  input wire  firstB ,
  input wire  firstC ,
  input wire  pufferA ,
  input wire  pufferB ,
  input wire  pufferC ,
  input wire  rextA ,
  input wire  rextB ,
  input wire  rextC ,
  input wire  rrtrA ,
  input wire  rrtrB ,
  input wire  rrtrC ,
  input wire  lt3A ,
  input wire  lt3B ,
  input wire  lt3C ,
  input wire  gt3A ,
  input wire  gt3B ,
  input wire  gt3C ,
  input wire  eq3A ,
  input wire  eq3B ,
  input wire  eq3C ,
  input wire  lt11A ,
  input wire  lt11B ,
  input wire  lt11C ,
  input wire  eq11A ,
  input wire  eq11B ,
  input wire  eq11C ,
  input wire  startrcrcA ,
  input wire  startrcrcB ,
  input wire  startrcrcC ,
  input wire  rmzeroA ,
  input wire  rmzeroB ,
  input wire  rmzeroC ,
  input wire  starttcrcA ,
  input wire  starttcrcB ,
  input wire  starttcrcC ,
  output reg [1:0] ackerror_setA ,
  output reg [1:0] ackerror_setB ,
  output reg [1:0] ackerror_setC ,
  output reg [1:0] onarbit_setA ,
  output reg [1:0] onarbit_setB ,
  output reg [1:0] onarbit_setC ,
  output reg [1:0] transmitter_setA ,
  output reg [1:0] transmitter_setB ,
  output reg [1:0] transmitter_setC ,
  output reg [1:0] receiver_setA ,
  output reg [1:0] receiver_setB ,
  output reg [1:0] receiver_setC ,
  output reg [1:0] error_setA ,
  output reg [1:0] error_setB ,
  output reg [1:0] error_setC ,
  output reg [1:0] first_setA ,
  output reg [1:0] first_setB ,
  output reg [1:0] first_setC ,
  output reg [1:0] puffer_setA ,
  output reg [1:0] puffer_setB ,
  output reg [1:0] puffer_setC ,
  output reg [1:0] rext_setA ,
  output reg [1:0] rext_setB ,
  output reg [1:0] rext_setC ,
  output reg [1:0] rrtr_setA ,
  output reg [1:0] rrtr_setB ,
  output reg [1:0] rrtr_setC ,
  input wire [6:0] countA ,
  input wire [6:0] countB ,
  input wire [6:0] countC ,
  output reg [2:0] setrmlenoA ,
  output reg [2:0] setrmlenoB ,
  output reg [2:0] setrmlenoC ,
  output reg  actvrmlnA ,
  output reg  actvrmlnB ,
  output reg  actvrmlnC ,
  output reg  actvtcrcA ,
  output reg  actvtcrcB ,
  output reg  actvtcrcC ,
  output reg  actvrcrcA ,
  output reg  actvrcrcB ,
  output reg  actvrcrcC ,
  output reg  actvtstfA ,
  output reg  actvtstfB ,
  output reg  actvtstfC ,
  output reg  actvrstfA ,
  output reg  actvrstfB ,
  output reg  actvrstfC ,
  output reg  actvtsftA ,
  output reg  actvtsftB ,
  output reg  actvtsftC ,
  output reg  actvrsftA ,
  output reg  actvrsftB ,
  output reg  actvrsftC ,
  output reg  actvtdctA ,
  output reg  actvtdctB ,
  output reg  actvtdctC ,
  output reg  actvrdctA ,
  output reg  actvrdctB ,
  output reg  actvrdctC ,
  output reg  actvtbedA ,
  output reg  actvtbedB ,
  output reg  actvtbedC ,
  output reg  setbdomA ,
  output reg  setbdomB ,
  output reg  setbdomC ,
  output reg  setbrecA ,
  output reg  setbrecB ,
  output reg  setbrecC ,
  output reg  lcrcA ,
  output reg  lcrcB ,
  output reg  lcrcC ,
  output reg  lmsgA ,
  output reg  lmsgB ,
  output reg  lmsgC ,
  output reg  tshiftA ,
  output reg  tshiftB ,
  output reg  tshiftC ,
  output reg  inconerecA ,
  output reg  inconerecB ,
  output reg  inconerecC ,
  output reg  incegtrecA ,
  output reg  incegtrecB ,
  output reg  incegtrecC ,
  output reg  incegttraA ,
  output reg  incegttraB ,
  output reg  incegttraC ,
  output reg  decrecA ,
  output reg  decrecB ,
  output reg  decrecC ,
  output reg  dectraA ,
  output reg  dectraB ,
  output reg  dectraC ,
  output reg  elevrecbA ,
  output reg  elevrecbB ,
  output reg  elevrecbC ,
  output reg  hardsyncA ,
  output reg  hardsyncB ,
  output reg  hardsyncC ,
  output reg  inccountA ,
  output reg  inccountB ,
  output reg  inccountC ,
  output reg  resrmlenA ,
  output reg  resrmlenB ,
  output reg  resrmlenC ,
  output reg  rescountA ,
  output reg  rescountB ,
  output reg  rescountC ,
  output reg  resetdstA ,
  output reg  resetdstB ,
  output reg  resetdstC ,
  output reg  resetstfA ,
  output reg  resetstfB ,
  output reg  resetstfC ,
  output reg  activatefastA ,
  output reg  activatefastB ,
  output reg  activatefastC ,
  output reg  crc_shft_outA ,
  output reg  crc_shft_outB ,
  output reg  crc_shft_outC ,
  output reg  en_zerointcrcA ,
  output reg  en_zerointcrcB ,
  output reg  en_zerointcrcC ,
  output wire [7:0] statedebA ,
  output wire [7:0] statedebB ,
  output wire [7:0] statedebC 
);
parameter sync_start =8'h00;
parameter sync_sample =8'h01;
parameter sync_sum =8'h02;
parameter sync_end =8'h03;
parameter inter_sample =8'h04;
parameter inter_check =8'h05;
parameter inter_goregtran =8'h06;
parameter inter_react =8'h07;
parameter bus_idle_chk =8'h08;
parameter bus_idle_sample =8'h09;
parameter inter_transhift =8'h0a;
parameter inter_regtrancnt =8'h0b;
parameter inter_preprec =8'h0c;
parameter inter_incsigres =8'h0d;
parameter tra_arbit_tactrsftn =8'h0e;
parameter tra_arbit_tactrsftsr =8'h0f;
parameter tra_arbit_tactrsfte =8'h10;
parameter tra_arbit_tactrsfter =8'h11;
parameter tra_arbit_tnactrnsft =8'h12;
parameter tra_arbit_tsftrsmpl =8'h13;
parameter tra_arbit_tnsftrsmpl =8'h14;
parameter tra_arbit_goreceive =8'h15;
parameter tra_data_activatecrc =8'h16;
parameter tra_data_activatncrc =8'h17;
parameter tra_data_shifting =8'h18;
parameter tra_data_noshift =8'h19;
parameter tra_data_lastshift =8'h1a;
parameter tra_data_loadcrc =8'h1b;
parameter tra_crc_activatedec =8'h1c;
parameter tra_crc_activatndec =8'h1d;
parameter tra_crc_shifting =8'h1e;
parameter tra_crc_noshift =8'h1f;
parameter tra_crc_delshft =8'h20;
parameter tra_ack_sendack =8'h21;
parameter tra_ack_shifting =8'h22;
parameter tra_ack_stopack =8'h23;
parameter tra_edof_sendrecb =8'h24;
parameter tra_edof_shifting =8'h25;
parameter rec_flglen_sample =8'h26;
parameter rec_flglen_shiftstdrtr =8'h27;
parameter rec_flglen_shiftextnor =8'h28;
parameter rec_flglen_shiftdlc64 =8'h29;
parameter rec_flglen_shiftdlc32 =8'h2a;
parameter rec_flglen_shiftdlc16 =8'h2b;
parameter rec_flglen_shiftdlc8 =8'h2c;
parameter rec_flglen_shiftextrtr =8'h2d;
parameter rec_flglen_shifting =8'h2e;
parameter rec_flglen_noshift =8'h2f;
parameter rec_acptdat_sample =8'h30;
parameter rec_acptdat_shifting =8'h31;
parameter rec_acptdat_noshift =8'h32;
parameter rec_crc_rescnt =8'h33;
parameter rec_crc_sample =8'h34;
parameter rec_crc_shifting =8'h35;
parameter rec_crc_noshift =8'h36;
parameter rec_ack_recdelim =8'h37;
parameter rec_ack_prepgiveack =8'h38;
parameter rec_ack_prepnoack =8'h39;
parameter rec_ack_noack =8'h3a;
parameter rec_ack_giveack =8'h3b;
parameter rec_ack_checkack =8'h3c;
parameter rec_ack_stopack =8'h3d;
parameter rec_edof_sample =8'h3e;
parameter rec_edof_check =8'h3f;
parameter rec_edof_endrec =8'h40;
parameter rec_flglen_setdlc =8'h41;
parameter rec_acptdat_lastshift =8'h42;
parameter over_firstdom =8'h43;
parameter over_senddomb =8'h44;
parameter over_check1 =8'h45;
parameter over_preprecb =8'h46;
parameter over_wtonrecb =8'h47;
parameter over_increccounter =8'h48;
parameter over_inctracounter =8'h49;
parameter over_check2 =8'h4a;
parameter over_sendrecb =8'h4b;
parameter over_check3 =8'h4c;
parameter over_waitoclk =8'h4d;
parameter over_prepsend =8'h4e;
parameter erroractiv_firstdom =8'h4f;
parameter erroractiv_inceinsrec =8'h50;
parameter erroractiv_incachtrec =8'h51;
parameter erroractiv_incachttra =8'h52;
parameter erroractiv_senddomb =8'h53;
parameter erroractiv_check1 =8'h54;
parameter erroractiv_preprecb =8'h55;
parameter erroractiv_wtonrecb =8'h56;
parameter erroractiv_dombitdct =8'h57;
parameter erroractiv_egtdombt =8'h58;
parameter erroractiv_egtdombr =8'h59;
parameter erroractiv_check2 =8'h5a;
parameter erroractiv_sendrecb =8'h5b;
parameter erroractiv_check3 =8'h5c;
parameter erroractiv_waitoclk =8'h5d;
parameter erroractiv_prepsend =8'h5e;
parameter errorpassiv_firstrec =8'h5f;
parameter errorpassiv_inceinsrec =8'h60;
parameter errorpassiv_incachtrec =8'h61;
parameter errorpassiv_fillpuffer =8'h62;
parameter errorpassiv_incachttra =8'h63;
parameter errorpassiv_incsrecb =8'h64;
parameter errorpassiv_zersrecbi =8'h65;
parameter errorpassiv_pufferrec =8'h66;
parameter errorpassiv_zersrecbz =8'h67;
parameter errorpassiv_zersrecbo =8'h68;
parameter errorpassiv_check1 =8'h69;
parameter errorpassiv_pufferdom =8'h6a;
parameter errorpassiv_wtonrecb =8'h6b;
parameter errorpassiv_dombitdct =8'h6c;
parameter errorpassiv_egtdombt =8'h6d;
parameter errorpassiv_pufferdomi =8'h6e;
parameter errorpassiv_egtdombr =8'h6f;
parameter errorpassiv_check2 =8'h70;
parameter errorpassiv_sendrecb =8'h71;
parameter errorpassiv_check3 =8'h72;
parameter errorpassiv_waitoclk =8'h73;
parameter errorpassiv_prepsend =8'h74;
parameter errorpassiv_preprecb =8'h75;
parameter errorpassiv_newcount =8'h76;
parameter errorpassiv_prepcount =8'h77;
parameter busoff_first =8'h78;
parameter busoff_sample =8'h79;
parameter busoff_setzer =8'h7a;
parameter busoff_increm =8'h7b;
parameter busoff_deccnt =8'h7c;
parameter rec_edof_lastbit =8'h7d;
parameter rec_edof_inter =8'h7e;
parameter tra_edof_dectra =8'h7f;
parameter inter_preprec_shifting =8'h80;
parameter inter_arbit_tsftrsmpl =8'h81;
wor current_stateTmrErrorC;
wire [7:0] current_stateVotedC;
wor current_stateTmrErrorB;
wire [7:0] current_stateVotedB;
wor current_stateTmrErrorA;
wire [7:0] current_stateVotedA;
reg  [7:0] current_stateA ;
reg  [7:0] next_stateA ;
reg  [7:0] current_stateB ;
reg  [7:0] next_stateB ;
reg  [7:0] current_stateC ;
reg  [7:0] next_stateC ;
assign statedebA =  current_stateVotedA;
assign statedebB =  current_stateVotedB;
assign statedebC =  current_stateVotedC;

always @( posedge clockA or negedge resetA )
  begin
    if (resetA==1'b0)
      current_stateA <= sync_start;
    else
      if (Prescale_ENA==1'b1)
        current_stateA <= next_stateA;
      else
        current_stateA <= current_stateVotedA;
  end

always @( posedge clockB or negedge resetB )
  begin
    if (resetB==1'b0)
      current_stateB <= sync_start;
    else
      if (Prescale_ENB==1'b1)
        current_stateB <= next_stateB;
      else
        current_stateB <= current_stateVotedB;
  end

always @( posedge clockC or negedge resetC )
  begin
    if (resetC==1'b0)
      current_stateC <= sync_start;
    else
      if (Prescale_ENC==1'b1)
        current_stateC <= next_stateC;
      else
        current_stateC <= current_stateVotedC;
  end

always @*
  begin
    rext_setA <= 2'b00;
    rrtr_setA <= 2'b00;
    actvtcrcA <= 1'b0;
    actvrcrcA <= 1'b0;
    actvtstfA <= 1'b0;
    actvrstfA <= 1'b0;
    actvtsftA <= 1'b0;
    actvrsftA <= 1'b0;
    actvtdctA <= 1'b0;
    actvrdctA <= 1'b1;
    actvtbedA <= 1'b0;
    setbdomA <= 1'b0;
    setbrecA <= 1'b0;
    lcrcA <= 1'b0;
    tshiftA <= 1'b0;
    inconerecA <= 1'b0;
    incegtrecA <= 1'b0;
    incegttraA <= 1'b0;
    lmsgA <= 1'b0;
    decrecA <= 1'b0;
    dectraA <= 1'b0;
    elevrecbA <= 1'b0;
    resetdstA <= 1'b1;
    resetstfA <= 1'b1;
    hardsyncA <= 1'b1;
    inccountA <= 1'b0;
    rescountA <= 1'b0;
    setrmlenoA <= 0;
    actvrmlnA <= 1'b0;
    resrmlenA <= 1'b0;
    ackerror_setA <= 2'b10;
    transmitter_setA <= 2'b10;
    receiver_setA <= 2'b10;
    error_setA <= 2'b10;
    first_setA <= 2'b10;
    activatefastA <= 1'b0;
    puffer_setA <= 2'b10;
    onarbit_setA <= 2'b10;
    en_zerointcrcA <= 1'b1;
    crc_shft_outA <= 1'b0;
    next_stateA <= current_stateVotedA;
    case (current_stateVotedA)
      sync_start : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b0;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= sync_sample;
          else
            next_stateA <= sync_start;
        end
      sync_sample : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b1)
            next_stateA <= sync_sum;
          else
            next_stateA <= sync_start;
        end
      sync_sum : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&countA!=8)
            next_stateA <= sync_sample;
          else
            if (countA==8)
              next_stateA <= sync_end;
            else
              next_stateA <= sync_sum;
        end
      sync_end : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= bus_idle_sample;
          else
            next_stateA <= sync_end;
        end
      inter_sample : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (busofA==1'b1)
            next_stateA <= busoff_first;
          else
            if ((((errorpassivA==1'b0||receiverA==1'b1)&&lt3A==1'b1)||((errorpassivA==1'b1&&receiverA==1'b0)&&lt11A==1'b1))&&inbitA==1'b1)
              next_stateA <= inter_check;
            else
              if (lt3A==1'b1&&inbitA==1'b0)
                next_stateA <= over_firstdom;
              else
                if (inbitA==1'b0&&(gt3A==1'b1||((eq3A==1'b1||gt3A==1'b1)&&((errorpassivA==1'b1&&receiverA==1'b0)||transA==1'b0))))
                  next_stateA <= inter_preprec;
                else
                  if (sendpointA==1'b1&&(((errorpassivA==1'b0||receiverA==1'b1)&&(eq3A==1'b1||gt3A==1'b1))||((errorpassivA==1'b1&&receiverA==1'b0)&&(eq11A==1'b1||lt11A==1'b0)))&&inbitA==1'b1&&transA==1'b1)
                    next_stateA <= inter_goregtran;
                  else
                    if ((errorpassivA==1'b0||receiverA==1'b1)&&(eq3A==1'b1||gt3A==1'b1)&&inbitA==1'b0&&transA==1'b1)
                      next_stateA <= inter_react;
                    else
                      if (transA==1'b0&&(((eq3A==1'b1||gt3A==1'b1)&&(errorpassivA==1'b0||receiverA==1'b1))||((eq11A==1'b1||lt11A==1'b0)&&(errorpassivA==1'b1&&receiverA==1'b0))))
                        next_stateA <= bus_idle_chk;
                      else
                        next_stateA <= inter_sample;
        end
      inter_check : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b0;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= inter_check;
        end
      bus_idle_chk : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b0;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= bus_idle_sample;
          else
            next_stateA <= bus_idle_chk;
        end
      bus_idle_sample : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (transA==1'b0&&inbitA==1'b1)
            next_stateA <= bus_idle_chk;
          else
            if (inbitA==1'b0&&transA==1'b0)
              next_stateA <= inter_preprec;
            else
              if (inbitA==1'b0&&transA==1'b1)
                next_stateA <= inter_react;
              else
                if (sendpointA==1'b1&&inbitA==1'b1&&transA==1'b1)
                  next_stateA <= inter_goregtran;
                else
                  next_stateA <= bus_idle_sample;
        end
      inter_react : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b0;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          next_stateA <= inter_transhift;
        end
      inter_goregtran : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b0;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b0;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          next_stateA <= inter_regtrancnt;
        end
      inter_regtrancnt : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b0;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_arbit_tsftrsmpl;
          else
            next_stateA <= inter_regtrancnt;
        end
      inter_arbit_tsftrsmpl : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= tra_arbit_tactrsftn;
          else
            next_stateA <= inter_arbit_tsftrsmpl;
        end
      inter_transhift : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          next_stateA <= inter_incsigres;
        end
      inter_incsigres : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b0;
          crc_shft_outA <= 1'b0;
          next_stateA <= tra_arbit_tactrsftn;
        end
      inter_preprec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b0;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= inter_preprec_shifting;
        end
      inter_preprec_shifting : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= inter_preprec_shifting;
        end
      tra_arbit_tnactrnsft : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= tra_arbit_tsftrsmpl;
          else
            next_stateA <= tra_arbit_tnactrnsft;
        end
      tra_arbit_tactrsftn : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&stufftA==1'b0)
            next_stateA <= tra_arbit_tsftrsmpl;
          else
            if (smplpointA==1'b1&&stufftA==1'b1)
              next_stateA <= tra_arbit_tnsftrsmpl;
            else
              next_stateA <= tra_arbit_tactrsftn;
        end
      tra_arbit_tactrsftsr : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b11;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&stufftA==1'b0)
            next_stateA <= tra_arbit_tsftrsmpl;
          else
            if (smplpointA==1'b1&&stufftA==1'b1)
              next_stateA <= tra_arbit_tnsftrsmpl;
            else
              next_stateA <= tra_arbit_tactrsftsr;
        end
      tra_arbit_tactrsfte : 
        begin
          rext_setA <= 2'b11;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&stufftA==1'b0)
            next_stateA <= tra_arbit_tsftrsmpl;
          else
            if (smplpointA==1'b1&&stufftA==1'b1)
              next_stateA <= tra_arbit_tnsftrsmpl;
            else
              next_stateA <= tra_arbit_tactrsfte;
        end
      tra_arbit_tactrsfter : 
        begin
          rext_setA <= 2'b11;
          rrtr_setA <= 2'b11;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&stufftA==1'b0)
            next_stateA <= tra_arbit_tsftrsmpl;
          else
            if (smplpointA==1'b1&&stufftA==1'b1)
              next_stateA <= tra_arbit_tnsftrsmpl;
            else
              next_stateA <= tra_arbit_tactrsfter;
        end
      tra_arbit_tsftrsmpl : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&stferrorA==1'b0&&countA==13&&inbitA==1'b1&&textA==1'b1)
            next_stateA <= tra_arbit_tactrsftsr;
          else
            if (sendpointA==1'b1&&biterrorA==1'b0&&stferrorA==1'b0&&countA==14&&inbitA==1'b1)
              next_stateA <= tra_arbit_tactrsfte;
            else
              if (sendpointA==1'b1&&biterrorA==1'b0&&stferrorA==1'b0&&countA==33&&inbitA==1'b1)
                next_stateA <= tra_arbit_tactrsfter;
              else
                if (sendpointA==1'b1&&biterrorA==1'b0&&stferrorA==1'b0&&(inbitA==1'b0||(countA!=13&&countA!=14&&countA!=33))&&(! ( (countA==13&&textA==1'b0)||(countA==34&&textA==1'b1) ) ))
                  next_stateA <= tra_arbit_tactrsftn;
                else
                  if (sendpointA==1'b1&&biterrorA==1'b0&&stferrorA==1'b0&&((countA==13&&textA==1'b0)||(countA==34&&textA==1'b1)))
                    next_stateA <= tra_data_activatecrc;
                  else
                    if (biterrorA==1'b1&&stferrorA==1'b0)
                      next_stateA <= tra_arbit_goreceive;
                    else
                      next_stateA <= tra_arbit_tsftrsmpl;
        end
      tra_arbit_goreceive : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= tra_arbit_goreceive;
        end
      tra_arbit_tnsftrsmpl : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          hardsyncA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b11;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_arbit_tnactrnsft;
          else
            if (stferrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (stferrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_arbit_tnsftrsmpl;
        end
      tra_data_activatecrc : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b1;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&stufftA==1'b0&&starttcrcA==1'b0)
            next_stateA <= tra_data_shifting;
          else
            if (smplpointA==1'b1&&stufftA==1'b0&&starttcrcA==1'b1)
              next_stateA <= tra_data_lastshift;
            else
              if (smplpointA==1'b1&&stufftA==1'b1)
                next_stateA <= tra_data_noshift;
              else
                next_stateA <= tra_data_activatecrc;
        end
      tra_data_activatncrc : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&starttcrcA==1'b0)
            next_stateA <= tra_data_shifting;
          else
            if (smplpointA==1'b1&&starttcrcA==1'b1)
              next_stateA <= tra_data_lastshift;
            else
              next_stateA <= tra_data_activatncrc;
        end
      tra_data_shifting : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_data_activatecrc;
          else
            if (biterrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_data_shifting;
        end
      tra_data_lastshift : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (biterrorA==1'b1&&erroractivA==1'b1)
            next_stateA <= erroractiv_firstdom;
          else
            if (biterrorA==1'b1&&errorpassivA==1'b1)
              next_stateA <= errorpassiv_firstrec;
            else
              next_stateA <= tra_data_loadcrc;
        end
      tra_data_noshift : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_data_activatncrc;
          else
            if (biterrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_data_noshift;
        end
      tra_data_loadcrc : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= tra_crc_activatedec;
          else
            next_stateA <= tra_data_loadcrc;
        end
      tra_crc_activatedec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b1;
          if (smplpointA==1'b1&&stufftA==1'b0&&countA!=16)
            next_stateA <= tra_crc_shifting;
          else
            if (smplpointA==1'b1&&stufftA==1'b0&&countA==16)
              next_stateA <= tra_crc_delshft;
            else
              if (smplpointA==1'b1&&stufftA==1'b1)
                next_stateA <= tra_crc_noshift;
              else
                next_stateA <= tra_crc_activatedec;
        end
      tra_crc_activatndec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b1;
          if (smplpointA==1'b1&&countA!=16)
            next_stateA <= tra_crc_shifting;
          else
            if (smplpointA==1'b1&&countA==16)
              next_stateA <= tra_crc_delshft;
            else
              next_stateA <= tra_crc_activatndec;
        end
      tra_crc_shifting : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b1;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_crc_activatedec;
          else
            if (biterrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_crc_shifting;
        end
      tra_crc_noshift : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b1;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_crc_activatndec;
          else
            if (biterrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_crc_noshift;
        end
      tra_crc_delshft : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b1;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b1;
          if (sendpointA==1'b1&&biterrorA==1'b0)
            next_stateA <= tra_ack_sendack;
          else
            if (biterrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= tra_crc_delshft;
        end
      tra_ack_sendack : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= tra_ack_shifting;
          else
            next_stateA <= tra_ack_sendack;
        end
      tra_ack_shifting : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (biterrorA==1'b0)
            next_stateA <= tra_ack_stopack;
          else
            if (sendpointA==1'b1&&biterrorA==1'b1)
              next_stateA <= tra_edof_sendrecb;
            else
              next_stateA <= tra_ack_shifting;
        end
      tra_ack_stopack : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b11;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (erroractivA==1'b1)
            next_stateA <= erroractiv_firstdom;
          else
            next_stateA <= errorpassiv_firstrec;
        end
      tra_edof_sendrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= tra_edof_shifting;
          else
            next_stateA <= tra_edof_sendrecb;
        end
      tra_edof_shifting : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=8)
            next_stateA <= tra_edof_sendrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b0&&countA==8)
              next_stateA <= tra_edof_dectra;
            else
              if (biterrorA==1'b1&&countA==8)
                next_stateA <= over_firstdom;
              else
                if (biterrorA==1'b1&&erroractivA==1'b1&&countA!=8)
                  next_stateA <= erroractiv_firstdom;
                else
                  if (biterrorA==1'b1&&errorpassivA==1'b1&&countA!=8)
                    next_stateA <= errorpassiv_firstrec;
                  else
                    next_stateA <= tra_edof_shifting;
        end
      tra_edof_dectra : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b1;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b11;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= tra_edof_dectra;
        end
      rec_flglen_sample : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (stuffrA==1'b1&&stferrorA==1'b0)
            next_stateA <= rec_flglen_noshift;
          else
            if (stferrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (stferrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==12)
                  next_stateA <= rec_flglen_shiftstdrtr;
                else
                  if ((stuffrA==1'b0)&&(stferrorA==1'b0)&&(inbitA==1'b1)&&(countA==13))
                    next_stateA <= rec_flglen_shiftextnor;
                  else
                    if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==15&&rrtrA==1'b0&&rextA==1'b0)
                      next_stateA <= rec_flglen_shiftdlc64;
                    else
                      if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==16&&rrtrA==1'b0&&rextA==1'b0)
                        next_stateA <= rec_flglen_shiftdlc32;
                      else
                        if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==17&&rrtrA==1'b0&&rextA==1'b0)
                          next_stateA <= rec_flglen_shiftdlc16;
                        else
                          if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==18&&rrtrA==1'b0&&rextA==1'b0)
                            next_stateA <= rec_flglen_shiftdlc8;
                          else
                            if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==32&&rextA==1'b1)
                              next_stateA <= rec_flglen_shiftextrtr;
                            else
                              if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==35&&rrtrA==1'b0&&rextA==1'b1)
                                next_stateA <= rec_flglen_shiftdlc64;
                              else
                                if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==36&&rrtrA==1'b0&&rextA==1'b1)
                                  next_stateA <= rec_flglen_shiftdlc32;
                                else
                                  if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==37&&rrtrA==1'b0&&rextA==1'b1)
                                    next_stateA <= rec_flglen_shiftdlc16;
                                  else
                                    if (stuffrA==1'b0&&stferrorA==1'b0&&inbitA==1'b1&&countA==38&&rrtrA==1'b0&&rextA==1'b1)
                                      next_stateA <= rec_flglen_shiftdlc8;
                                    else
                                      if (stuffrA==1'b0&&stferrorA==1'b0&&(inbitA==1'b0||(countA!=12&&countA!=13&&(rextA==1'b1||rrtrA==1'b1||(countA!=15&&countA!=16&&countA!=17&&countA!=18))&&(countA!=32||rextA==1'b0)&&(rextA==1'b0||rrtrA==1'b1||(countA!=35&&countA!=36&&countA!=37&&countA!=38)))))
                                        next_stateA <= rec_flglen_shifting;
                                      else
                                        next_stateA <= rec_flglen_sample;
        end
      rec_flglen_shifting : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&(! ( (countA==19&&rextA==1'b0)||(countA==39&&rextA==1'b1) ) ))
            next_stateA <= rec_flglen_sample;
          else
            if (smplpointA==1'b1&&((countA==19&&rextA==1'b0)||(countA==39&&rextA==1'b1))&&rrtrA==1'b0&&rmzeroA==1'b0)
              next_stateA <= rec_acptdat_sample;
            else
              if (smplpointA==1'b1&&((countA==19&&rextA==1'b0)||(countA==39&&rextA==1'b1))&&(rrtrA==1'b1||rmzeroA==1'b1))
                next_stateA <= rec_crc_rescnt;
              else
                next_stateA <= rec_flglen_shifting;
        end
      rec_flglen_shiftstdrtr : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b11;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= rec_flglen_shiftstdrtr;
        end
      rec_flglen_shiftextnor : 
        begin
          rext_setA <= 2'b11;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= rec_flglen_shiftextnor;
        end
      rec_flglen_shiftdlc64 : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 4;
          actvrmlnA <= 1'b1;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc32 : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 3;
          actvrmlnA <= 1'b1;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc16 : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 2;
          actvrmlnA <= 1'b1;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc8 : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 1;
          actvrmlnA <= 1'b1;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= rec_flglen_setdlc;
        end
      rec_flglen_setdlc : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 7;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&(! ( (countA==19&&rextA==1'b0)||(countA==39&&rextA==1'b1) ) ))
            next_stateA <= rec_flglen_sample;
          else
            if (smplpointA==1'b1&&((countA==19&&rextA==1'b0)||(countA==39&&rextA==1'b1))&&rrtrA==1'b0)
              next_stateA <= rec_acptdat_sample;
            else
              next_stateA <= rec_flglen_setdlc;
        end
      rec_flglen_shiftextrtr : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b11;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= rec_flglen_shiftextrtr;
        end
      rec_flglen_noshift : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_flglen_sample;
          else
            next_stateA <= rec_flglen_noshift;
        end
      rec_acptdat_sample : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (stuffrA==1'b1&&stferrorA==1'b0)
            next_stateA <= rec_acptdat_noshift;
          else
            if (stferrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (stferrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                next_stateA <= rec_acptdat_shifting;
        end
      rec_acptdat_shifting : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&startrcrcA==1'b0)
            next_stateA <= rec_acptdat_sample;
          else
            if (startrcrcA==1'b1)
              next_stateA <= rec_acptdat_lastshift;
            else
              next_stateA <= rec_acptdat_shifting;
        end
      rec_acptdat_noshift : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_acptdat_sample;
          else
            next_stateA <= rec_acptdat_noshift;
        end
      rec_acptdat_lastshift : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_crc_rescnt;
          else
            next_stateA <= rec_acptdat_lastshift;
        end
      rec_crc_rescnt : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b1;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= rec_crc_sample;
        end
      rec_crc_sample : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (stuffrA==1'b1&&stferrorA==1'b0)
            next_stateA <= rec_crc_noshift;
          else
            if (stferrorA==1'b1&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (stferrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                if (countA==15)
                  next_stateA <= rec_ack_recdelim;
                else
                  next_stateA <= rec_crc_shifting;
        end
      rec_crc_shifting : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b1;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b1;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_crc_sample;
          else
            next_stateA <= rec_crc_shifting;
        end
      rec_crc_noshift : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b1;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_crc_sample;
          else
            next_stateA <= rec_crc_noshift;
        end
      rec_ack_recdelim : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b1&&crc_okA==1'b0)
            next_stateA <= rec_ack_prepnoack;
          else
            if (inbitA==1'b0&&erroractivA==1'b1)
              next_stateA <= erroractiv_firstdom;
            else
              if (inbitA==1'b0&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                if (inbitA==1'b0&&busofA==1'b1)
                  next_stateA <= busoff_first;
                else
                  next_stateA <= rec_ack_prepgiveack;
        end
      rec_ack_prepgiveack : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b1;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= rec_ack_giveack;
          else
            next_stateA <= rec_ack_prepgiveack;
        end
      rec_ack_giveack : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_ack_checkack;
          else
            next_stateA <= rec_ack_giveack;
        end
      rec_ack_checkack : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (biterrorA==1'b1&&erroractivA==1'b1)
            next_stateA <= erroractiv_firstdom;
          else
            if (biterrorA==1'b1&&errorpassivA==1'b1)
              next_stateA <= errorpassiv_firstrec;
            else
              if (sendpointA==1'b1)
                next_stateA <= rec_ack_stopack;
              else
                next_stateA <= rec_ack_checkack;
        end
      rec_ack_prepnoack : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= rec_ack_noack;
          else
            next_stateA <= rec_ack_prepnoack;
        end
      rec_ack_noack : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&erroractivA==1'b1)
            next_stateA <= erroractiv_firstdom;
          else
            if (smplpointA==1'b1&&errorpassivA==1'b1)
              next_stateA <= errorpassiv_firstrec;
            else
              if (smplpointA==1'b1&&busofA==1'b1)
                next_stateA <= busoff_first;
              else
                next_stateA <= rec_ack_noack;
        end
      rec_ack_stopack : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_edof_sample;
          else
            next_stateA <= rec_ack_stopack;
        end
      rec_edof_sample : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b0&&erroractivA==1'b1)
            next_stateA <= erroractiv_firstdom;
          else
            if (inbitA==1'b0&&errorpassivA==1'b1)
              next_stateA <= errorpassiv_firstrec;
            else
              next_stateA <= rec_edof_check;
        end
      rec_edof_check : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (countA!=7&&smplpointA==1'b1)
            next_stateA <= rec_edof_sample;
          else
            if (countA==7&&inbitA==1'b1)
              next_stateA <= rec_edof_endrec;
            else
              next_stateA <= rec_edof_check;
        end
      rec_edof_endrec : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b1;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= rec_edof_lastbit;
          else
            next_stateA <= rec_edof_endrec;
        end
      rec_edof_lastbit : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b1)
            next_stateA <= rec_edof_inter;
          else
            if (inbitA==1'b0)
              next_stateA <= over_firstdom;
            else
              next_stateA <= rec_edof_lastbit;
        end
      rec_edof_inter : 
        begin
          rext_setA <= 2'b00;
          rrtr_setA <= 2'b00;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b11;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= rec_edof_inter;
        end
      over_firstdom : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= over_senddomb;
          else
            next_stateA <= over_firstdom;
        end
      over_senddomb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= over_check1;
          else
            next_stateA <= over_senddomb;
        end
      over_check1 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=6)
            next_stateA <= over_senddomb;
          else
            if (biterrorA==1'b0&&countA==6)
              next_stateA <= over_preprecb;
            else
              if (biterrorA==1'b1&&erroractivA==1'b1)
                next_stateA <= erroractiv_firstdom;
              else
                if (biterrorA==1'b1&&errorpassivA==1'b1)
                  next_stateA <= errorpassiv_firstrec;
                else
                  if (biterrorA==1'b1&&busofA==1'b1)
                    next_stateA <= busoff_first;
                  else
                    next_stateA <= over_check1;
        end
      over_preprecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= over_wtonrecb;
          else
            next_stateA <= over_preprecb;
        end
      over_wtonrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= over_check2;
          else
            next_stateA <= over_wtonrecb;
        end
      over_inctracounter : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= over_check2;
          else
            next_stateA <= over_inctracounter;
        end
      over_increccounter : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= over_check2;
          else
            next_stateA <= over_increccounter;
        end
      over_check2 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b1&&countA!=7)
            next_stateA <= over_wtonrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&receiverA==1'b1)
              next_stateA <= over_increccounter;
            else
              if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&transmitterA==1'b1)
                next_stateA <= over_inctracounter;
              else
                if (biterrorA==1'b0)
                  next_stateA <= over_prepsend;
                else
                  next_stateA <= over_check2;
        end
      over_prepsend : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= over_sendrecb;
          else
            next_stateA <= over_prepsend;
        end
      over_sendrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= over_check3;
          else
            next_stateA <= over_sendrecb;
        end
      over_check3 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=7)
            next_stateA <= over_sendrecb;
          else
            if (biterrorA==1'b0&&countA==7)
              next_stateA <= over_waitoclk;
            else
              if (biterrorA==1'b1&&countA==7)
                next_stateA <= over_firstdom;
              else
                if (biterrorA==1'b1&&erroractivA==1'b1&&countA!=7)
                  next_stateA <= erroractiv_firstdom;
                else
                  if (biterrorA==1'b1&&errorpassivA==1'b1&&countA!=7)
                    next_stateA <= errorpassiv_firstrec;
                  else
                    if (biterrorA==1'b1&&busofA==1'b1&&countA!=7)
                      next_stateA <= busoff_first;
                    else
                      next_stateA <= over_check3;
        end
      over_waitoclk : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= over_waitoclk;
        end
      erroractiv_firstdom : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b00;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b00;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&onarbitA==1'b1)
            next_stateA <= erroractiv_senddomb;
          else
            if (onarbitA==1'b0&&transmitterA==1'b0&&receiverA==1'b1&&errorA==1'b0)
              next_stateA <= erroractiv_inceinsrec;
            else
              if (onarbitA==1'b0&&transmitterA==1'b0&&receiverA==1'b1&&errorA==1'b1)
                next_stateA <= erroractiv_incachtrec;
              else
                if (onarbitA==1'b0&&transmitterA==1'b1)
                  next_stateA <= erroractiv_incachttra;
                else
                  next_stateA <= erroractiv_firstdom;
        end
      erroractiv_inceinsrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b1;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= erroractiv_senddomb;
          else
            next_stateA <= erroractiv_inceinsrec;
        end
      erroractiv_incachtrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= erroractiv_senddomb;
          else
            next_stateA <= erroractiv_incachtrec;
        end
      erroractiv_incachttra : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= erroractiv_senddomb;
          else
            next_stateA <= erroractiv_incachttra;
        end
      erroractiv_senddomb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check1;
          else
            next_stateA <= erroractiv_senddomb;
        end
      erroractiv_check1 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b1;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=6)
            next_stateA <= erroractiv_senddomb;
          else
            if (biterrorA==1'b0&&countA==6)
              next_stateA <= erroractiv_preprecb;
            else
              if (biterrorA==1'b1&&erroractivA==1'b1)
                next_stateA <= erroractiv_firstdom;
              else
                if (biterrorA==1'b1&&errorpassivA==1'b1)
                  next_stateA <= errorpassiv_firstrec;
                else
                  if (biterrorA==1'b1&&busofA==1'b1)
                    next_stateA <= busoff_first;
                  else
                    next_stateA <= erroractiv_check1;
        end
      erroractiv_preprecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= erroractiv_wtonrecb;
          else
            next_stateA <= erroractiv_preprecb;
        end
      erroractiv_wtonrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b00;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check2;
          else
            next_stateA <= erroractiv_wtonrecb;
        end
      erroractiv_dombitdct : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check2;
          else
            next_stateA <= erroractiv_dombitdct;
        end
      erroractiv_egtdombr : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check2;
          else
            next_stateA <= erroractiv_egtdombr;
        end
      erroractiv_egtdombt : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check2;
          else
            next_stateA <= erroractiv_egtdombt;
        end
      erroractiv_check2 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b00;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b1&&countA!=7&&(countA!=1||receiverA==1'b0||firstA==1'b0))
            next_stateA <= erroractiv_wtonrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b1&&countA==1&&receiverA==1'b1&&firstA==1'b1)
              next_stateA <= erroractiv_dombitdct;
            else
              if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&transmitterA==1'b1&&receiverA==1'b0)
                next_stateA <= erroractiv_egtdombt;
              else
                if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&transmitterA==1'b0&&receiverA==1'b1)
                  next_stateA <= erroractiv_egtdombr;
                else
                  if (biterrorA==1'b0)
                    next_stateA <= erroractiv_prepsend;
                  else
                    next_stateA <= erroractiv_check2;
        end
      erroractiv_prepsend : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= erroractiv_sendrecb;
          else
            next_stateA <= erroractiv_prepsend;
        end
      erroractiv_sendrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= erroractiv_check3;
          else
            next_stateA <= erroractiv_sendrecb;
        end
      erroractiv_check3 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=7)
            next_stateA <= erroractiv_sendrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b0&&countA==7)
              next_stateA <= erroractiv_waitoclk;
            else
              if (biterrorA==1'b1&&erroractivA==1'b1)
                next_stateA <= erroractiv_firstdom;
              else
                if (biterrorA==1'b1&&errorpassivA==1'b1)
                  next_stateA <= errorpassiv_firstrec;
                else
                  if (biterrorA==1'b1&&busofA==1'b1)
                    next_stateA <= busoff_first;
                  else
                    next_stateA <= erroractiv_check3;
        end
      erroractiv_waitoclk : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= erroractiv_waitoclk;
        end
      errorpassiv_firstrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b00;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b00;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&transmitterA==1'b1&&(onarbitA==1'b1||ackerrorA==1'b1))
            next_stateA <= errorpassiv_incsrecb;
          else
            if (onarbitA==1'b0&&transmitterA==1'b0&&receiverA==1'b1&&errorA==1'b0)
              next_stateA <= errorpassiv_inceinsrec;
            else
              if (onarbitA==1'b0&&transmitterA==1'b0&&receiverA==1'b1&&errorA==1'b1)
                next_stateA <= errorpassiv_incachtrec;
              else
                if (onarbitA==1'b0&&transmitterA==1'b1&&ackerrorA==1'b0)
                  next_stateA <= errorpassiv_incachttra;
                else
                  next_stateA <= errorpassiv_firstrec;
        end
      errorpassiv_inceinsrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b1;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_inceinsrec;
        end
      errorpassiv_incachtrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_incachtrec;
        end
      errorpassiv_incachttra : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_incachttra;
        end
      errorpassiv_incsrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b00;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&countA!=0)
            next_stateA <= errorpassiv_check1;
          else
            if (smplpointA==1'b1&&countA==0)
              next_stateA <= errorpassiv_fillpuffer;
            else
              next_stateA <= errorpassiv_incsrecb;
        end
      errorpassiv_fillpuffer : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b0&&transmitterA==1'b1&&ackerrorA==1'b1)
            next_stateA <= errorpassiv_pufferdomi;
          else
            if (inbitA==1'b0&&(transmitterA==1'b0||ackerrorA==1'b0))
              next_stateA <= errorpassiv_pufferdom;
            else
              next_stateA <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferrec : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b11;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferdom : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_pufferdom;
        end
      errorpassiv_pufferdomi : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_incsrecb;
          else
            next_stateA <= errorpassiv_pufferdomi;
        end
      errorpassiv_zersrecbo : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b11;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbz : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbi : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= errorpassiv_newcount;
        end
      errorpassiv_newcount : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b00;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          next_stateA <= errorpassiv_prepcount;
        end
      errorpassiv_prepcount : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b00;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check1;
          else
            next_stateA <= errorpassiv_prepcount;
        end
      errorpassiv_check1 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b00;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b00;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==pufferA&&biterrorA==1'b1&&transmitterA==1'b1&&ackerrorA==1'b1)
            next_stateA <= errorpassiv_zersrecbi;
          else
            if (sendpointA==1'b1&&biterrorA==pufferA&&biterrorA==1'b1&&(ackerrorA==1'b0||transmitterA==1'b0))
              next_stateA <= errorpassiv_zersrecbz;
            else
              if (sendpointA==1'b1&&biterrorA==pufferA&&biterrorA==1'b0)
                next_stateA <= errorpassiv_zersrecbo;
              else
                if (sendpointA==1'b1&&biterrorA!=pufferA&&countA!=6)
                  next_stateA <= errorpassiv_incsrecb;
                else
                  if (biterrorA!=pufferA&&countA==6)
                    next_stateA <= errorpassiv_preprecb;
                  else
                    next_stateA <= errorpassiv_check1;
        end
      errorpassiv_preprecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b11;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_wtonrecb;
          else
            next_stateA <= errorpassiv_preprecb;
        end
      errorpassiv_wtonrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b00;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check2;
          else
            next_stateA <= errorpassiv_wtonrecb;
        end
      errorpassiv_dombitdct : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check2;
          else
            next_stateA <= errorpassiv_dombitdct;
        end
      errorpassiv_egtdombr : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b1;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check2;
          else
            next_stateA <= errorpassiv_egtdombr;
        end
      errorpassiv_egtdombt : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b1;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check2;
          else
            next_stateA <= errorpassiv_egtdombt;
        end
      errorpassiv_check2 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b00;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b1&&countA!=7&&(countA!=1||receiverA==1'b0||firstA==1'b0))
            next_stateA <= errorpassiv_wtonrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b1&&countA==1&&receiverA==1'b1&&firstA==1'b1)
              next_stateA <= errorpassiv_dombitdct;
            else
              if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&transmitterA==1'b1&&receiverA==1'b0)
                next_stateA <= errorpassiv_egtdombt;
              else
                if (sendpointA==1'b1&&biterrorA==1'b1&&countA==7&&transmitterA==1'b0&&receiverA==1'b1)
                  next_stateA <= errorpassiv_egtdombr;
                else
                  if (biterrorA==1'b0)
                    next_stateA <= errorpassiv_prepsend;
                  else
                    next_stateA <= errorpassiv_check2;
        end
      errorpassiv_prepsend : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1)
            next_stateA <= errorpassiv_sendrecb;
          else
            next_stateA <= errorpassiv_prepsend;
        end
      errorpassiv_sendrecb : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b1;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b1;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= errorpassiv_check3;
          else
            next_stateA <= errorpassiv_sendrecb;
        end
      errorpassiv_check3 : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b1;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (sendpointA==1'b1&&biterrorA==1'b0&&countA!=7)
            next_stateA <= errorpassiv_sendrecb;
          else
            if (sendpointA==1'b1&&biterrorA==1'b0&&countA==7)
              next_stateA <= errorpassiv_waitoclk;
            else
              if (biterrorA==1'b1&&errorpassivA==1'b1)
                next_stateA <= errorpassiv_firstrec;
              else
                if (biterrorA==1'b1&&busofA==1'b1)
                  next_stateA <= busoff_first;
                else
                  next_stateA <= errorpassiv_check3;
        end
      errorpassiv_waitoclk : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b1;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b0;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b1;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b00;
          receiver_setA <= 2'b00;
          error_setA <= 2'b11;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= inter_sample;
          else
            next_stateA <= errorpassiv_waitoclk;
        end
      busoff_first : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= busoff_sample;
          else
            next_stateA <= busoff_first;
        end
      busoff_sample : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b1;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (inbitA==1'b1&&countA!=10)
            next_stateA <= busoff_increm;
          else
            if (inbitA==1'b1&&countA==10)
              next_stateA <= busoff_deccnt;
            else
              next_stateA <= busoff_setzer;
        end
      busoff_increm : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b1;
          rescountA <= 1'b1;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= busoff_sample;
          else
            next_stateA <= busoff_increm;
        end
      busoff_setzer : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b0;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b1;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1)
            next_stateA <= busoff_sample;
          else
            next_stateA <= busoff_setzer;
        end
      busoff_deccnt : 
        begin
          rext_setA <= 2'b10;
          rrtr_setA <= 2'b10;
          actvtcrcA <= 1'b0;
          actvrcrcA <= 1'b0;
          actvtstfA <= 1'b0;
          actvrstfA <= 1'b0;
          actvtsftA <= 1'b0;
          actvrsftA <= 1'b0;
          actvtdctA <= 1'b0;
          actvrdctA <= 1'b1;
          actvtbedA <= 1'b0;
          setbdomA <= 1'b0;
          setbrecA <= 1'b0;
          lcrcA <= 1'b0;
          tshiftA <= 1'b0;
          inconerecA <= 1'b0;
          incegtrecA <= 1'b0;
          incegttraA <= 1'b0;
          lmsgA <= 1'b0;
          decrecA <= 1'b0;
          dectraA <= 1'b0;
          elevrecbA <= 1'b1;
          hardsyncA <= 1'b0;
          resetdstA <= 1'b1;
          resetstfA <= 1'b0;
          inccountA <= 1'b0;
          rescountA <= 1'b0;
          setrmlenoA <= 0;
          actvrmlnA <= 1'b0;
          resrmlenA <= 1'b1;
          ackerror_setA <= 2'b10;
          transmitter_setA <= 2'b10;
          receiver_setA <= 2'b10;
          error_setA <= 2'b10;
          first_setA <= 2'b10;
          activatefastA <= 1'b0;
          puffer_setA <= 2'b10;
          onarbit_setA <= 2'b10;
          en_zerointcrcA <= 1'b1;
          crc_shft_outA <= 1'b0;
          if (smplpointA==1'b1&&busofA==1'b1)
            next_stateA <= busoff_sample;
          else
            if (smplpointA==1'b1&&busofA==1'b0)
              next_stateA <= inter_sample;
            else
              next_stateA <= busoff_deccnt;
        end
      default : 
        begin
        end
    endcase
  end

always @*
  begin
    rext_setB <= 2'b00;
    rrtr_setB <= 2'b00;
    actvtcrcB <= 1'b0;
    actvrcrcB <= 1'b0;
    actvtstfB <= 1'b0;
    actvrstfB <= 1'b0;
    actvtsftB <= 1'b0;
    actvrsftB <= 1'b0;
    actvtdctB <= 1'b0;
    actvrdctB <= 1'b1;
    actvtbedB <= 1'b0;
    setbdomB <= 1'b0;
    setbrecB <= 1'b0;
    lcrcB <= 1'b0;
    tshiftB <= 1'b0;
    inconerecB <= 1'b0;
    incegtrecB <= 1'b0;
    incegttraB <= 1'b0;
    lmsgB <= 1'b0;
    decrecB <= 1'b0;
    dectraB <= 1'b0;
    elevrecbB <= 1'b0;
    resetdstB <= 1'b1;
    resetstfB <= 1'b1;
    hardsyncB <= 1'b1;
    inccountB <= 1'b0;
    rescountB <= 1'b0;
    setrmlenoB <= 0;
    actvrmlnB <= 1'b0;
    resrmlenB <= 1'b0;
    ackerror_setB <= 2'b10;
    transmitter_setB <= 2'b10;
    receiver_setB <= 2'b10;
    error_setB <= 2'b10;
    first_setB <= 2'b10;
    activatefastB <= 1'b0;
    puffer_setB <= 2'b10;
    onarbit_setB <= 2'b10;
    en_zerointcrcB <= 1'b1;
    crc_shft_outB <= 1'b0;
    next_stateB <= current_stateVotedB;
    case (current_stateVotedB)
      sync_start : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b0;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= sync_sample;
          else
            next_stateB <= sync_start;
        end
      sync_sample : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b1)
            next_stateB <= sync_sum;
          else
            next_stateB <= sync_start;
        end
      sync_sum : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&countB!=8)
            next_stateB <= sync_sample;
          else
            if (countB==8)
              next_stateB <= sync_end;
            else
              next_stateB <= sync_sum;
        end
      sync_end : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= bus_idle_sample;
          else
            next_stateB <= sync_end;
        end
      inter_sample : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (busofB==1'b1)
            next_stateB <= busoff_first;
          else
            if ((((errorpassivB==1'b0||receiverB==1'b1)&&lt3B==1'b1)||((errorpassivB==1'b1&&receiverB==1'b0)&&lt11B==1'b1))&&inbitB==1'b1)
              next_stateB <= inter_check;
            else
              if (lt3B==1'b1&&inbitB==1'b0)
                next_stateB <= over_firstdom;
              else
                if (inbitB==1'b0&&(gt3B==1'b1||((eq3B==1'b1||gt3B==1'b1)&&((errorpassivB==1'b1&&receiverB==1'b0)||transB==1'b0))))
                  next_stateB <= inter_preprec;
                else
                  if (sendpointB==1'b1&&(((errorpassivB==1'b0||receiverB==1'b1)&&(eq3B==1'b1||gt3B==1'b1))||((errorpassivB==1'b1&&receiverB==1'b0)&&(eq11B==1'b1||lt11B==1'b0)))&&inbitB==1'b1&&transB==1'b1)
                    next_stateB <= inter_goregtran;
                  else
                    if ((errorpassivB==1'b0||receiverB==1'b1)&&(eq3B==1'b1||gt3B==1'b1)&&inbitB==1'b0&&transB==1'b1)
                      next_stateB <= inter_react;
                    else
                      if (transB==1'b0&&(((eq3B==1'b1||gt3B==1'b1)&&(errorpassivB==1'b0||receiverB==1'b1))||((eq11B==1'b1||lt11B==1'b0)&&(errorpassivB==1'b1&&receiverB==1'b0))))
                        next_stateB <= bus_idle_chk;
                      else
                        next_stateB <= inter_sample;
        end
      inter_check : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b0;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= inter_check;
        end
      bus_idle_chk : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b0;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= bus_idle_sample;
          else
            next_stateB <= bus_idle_chk;
        end
      bus_idle_sample : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (transB==1'b0&&inbitB==1'b1)
            next_stateB <= bus_idle_chk;
          else
            if (inbitB==1'b0&&transB==1'b0)
              next_stateB <= inter_preprec;
            else
              if (inbitB==1'b0&&transB==1'b1)
                next_stateB <= inter_react;
              else
                if (sendpointB==1'b1&&inbitB==1'b1&&transB==1'b1)
                  next_stateB <= inter_goregtran;
                else
                  next_stateB <= bus_idle_sample;
        end
      inter_react : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b0;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          next_stateB <= inter_transhift;
        end
      inter_goregtran : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b0;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b0;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          next_stateB <= inter_regtrancnt;
        end
      inter_regtrancnt : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b0;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_arbit_tsftrsmpl;
          else
            next_stateB <= inter_regtrancnt;
        end
      inter_arbit_tsftrsmpl : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= tra_arbit_tactrsftn;
          else
            next_stateB <= inter_arbit_tsftrsmpl;
        end
      inter_transhift : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          next_stateB <= inter_incsigres;
        end
      inter_incsigres : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b0;
          crc_shft_outB <= 1'b0;
          next_stateB <= tra_arbit_tactrsftn;
        end
      inter_preprec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b0;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= inter_preprec_shifting;
        end
      inter_preprec_shifting : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= inter_preprec_shifting;
        end
      tra_arbit_tnactrnsft : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= tra_arbit_tsftrsmpl;
          else
            next_stateB <= tra_arbit_tnactrnsft;
        end
      tra_arbit_tactrsftn : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&stufftB==1'b0)
            next_stateB <= tra_arbit_tsftrsmpl;
          else
            if (smplpointB==1'b1&&stufftB==1'b1)
              next_stateB <= tra_arbit_tnsftrsmpl;
            else
              next_stateB <= tra_arbit_tactrsftn;
        end
      tra_arbit_tactrsftsr : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b11;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&stufftB==1'b0)
            next_stateB <= tra_arbit_tsftrsmpl;
          else
            if (smplpointB==1'b1&&stufftB==1'b1)
              next_stateB <= tra_arbit_tnsftrsmpl;
            else
              next_stateB <= tra_arbit_tactrsftsr;
        end
      tra_arbit_tactrsfte : 
        begin
          rext_setB <= 2'b11;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&stufftB==1'b0)
            next_stateB <= tra_arbit_tsftrsmpl;
          else
            if (smplpointB==1'b1&&stufftB==1'b1)
              next_stateB <= tra_arbit_tnsftrsmpl;
            else
              next_stateB <= tra_arbit_tactrsfte;
        end
      tra_arbit_tactrsfter : 
        begin
          rext_setB <= 2'b11;
          rrtr_setB <= 2'b11;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&stufftB==1'b0)
            next_stateB <= tra_arbit_tsftrsmpl;
          else
            if (smplpointB==1'b1&&stufftB==1'b1)
              next_stateB <= tra_arbit_tnsftrsmpl;
            else
              next_stateB <= tra_arbit_tactrsfter;
        end
      tra_arbit_tsftrsmpl : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&stferrorB==1'b0&&countB==13&&inbitB==1'b1&&textB==1'b1)
            next_stateB <= tra_arbit_tactrsftsr;
          else
            if (sendpointB==1'b1&&biterrorB==1'b0&&stferrorB==1'b0&&countB==14&&inbitB==1'b1)
              next_stateB <= tra_arbit_tactrsfte;
            else
              if (sendpointB==1'b1&&biterrorB==1'b0&&stferrorB==1'b0&&countB==33&&inbitB==1'b1)
                next_stateB <= tra_arbit_tactrsfter;
              else
                if (sendpointB==1'b1&&biterrorB==1'b0&&stferrorB==1'b0&&(inbitB==1'b0||(countB!=13&&countB!=14&&countB!=33))&&(! ( (countB==13&&textB==1'b0)||(countB==34&&textB==1'b1) ) ))
                  next_stateB <= tra_arbit_tactrsftn;
                else
                  if (sendpointB==1'b1&&biterrorB==1'b0&&stferrorB==1'b0&&((countB==13&&textB==1'b0)||(countB==34&&textB==1'b1)))
                    next_stateB <= tra_data_activatecrc;
                  else
                    if (biterrorB==1'b1&&stferrorB==1'b0)
                      next_stateB <= tra_arbit_goreceive;
                    else
                      next_stateB <= tra_arbit_tsftrsmpl;
        end
      tra_arbit_goreceive : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= tra_arbit_goreceive;
        end
      tra_arbit_tnsftrsmpl : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          hardsyncB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b11;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_arbit_tnactrnsft;
          else
            if (stferrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (stferrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_arbit_tnsftrsmpl;
        end
      tra_data_activatecrc : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b1;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&stufftB==1'b0&&starttcrcB==1'b0)
            next_stateB <= tra_data_shifting;
          else
            if (smplpointB==1'b1&&stufftB==1'b0&&starttcrcB==1'b1)
              next_stateB <= tra_data_lastshift;
            else
              if (smplpointB==1'b1&&stufftB==1'b1)
                next_stateB <= tra_data_noshift;
              else
                next_stateB <= tra_data_activatecrc;
        end
      tra_data_activatncrc : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&starttcrcB==1'b0)
            next_stateB <= tra_data_shifting;
          else
            if (smplpointB==1'b1&&starttcrcB==1'b1)
              next_stateB <= tra_data_lastshift;
            else
              next_stateB <= tra_data_activatncrc;
        end
      tra_data_shifting : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_data_activatecrc;
          else
            if (biterrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_data_shifting;
        end
      tra_data_lastshift : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (biterrorB==1'b1&&erroractivB==1'b1)
            next_stateB <= erroractiv_firstdom;
          else
            if (biterrorB==1'b1&&errorpassivB==1'b1)
              next_stateB <= errorpassiv_firstrec;
            else
              next_stateB <= tra_data_loadcrc;
        end
      tra_data_noshift : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_data_activatncrc;
          else
            if (biterrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_data_noshift;
        end
      tra_data_loadcrc : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= tra_crc_activatedec;
          else
            next_stateB <= tra_data_loadcrc;
        end
      tra_crc_activatedec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b1;
          if (smplpointB==1'b1&&stufftB==1'b0&&countB!=16)
            next_stateB <= tra_crc_shifting;
          else
            if (smplpointB==1'b1&&stufftB==1'b0&&countB==16)
              next_stateB <= tra_crc_delshft;
            else
              if (smplpointB==1'b1&&stufftB==1'b1)
                next_stateB <= tra_crc_noshift;
              else
                next_stateB <= tra_crc_activatedec;
        end
      tra_crc_activatndec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b1;
          if (smplpointB==1'b1&&countB!=16)
            next_stateB <= tra_crc_shifting;
          else
            if (smplpointB==1'b1&&countB==16)
              next_stateB <= tra_crc_delshft;
            else
              next_stateB <= tra_crc_activatndec;
        end
      tra_crc_shifting : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b1;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_crc_activatedec;
          else
            if (biterrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_crc_shifting;
        end
      tra_crc_noshift : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b1;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_crc_activatndec;
          else
            if (biterrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_crc_noshift;
        end
      tra_crc_delshft : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b1;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b1;
          if (sendpointB==1'b1&&biterrorB==1'b0)
            next_stateB <= tra_ack_sendack;
          else
            if (biterrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= tra_crc_delshft;
        end
      tra_ack_sendack : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= tra_ack_shifting;
          else
            next_stateB <= tra_ack_sendack;
        end
      tra_ack_shifting : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (biterrorB==1'b0)
            next_stateB <= tra_ack_stopack;
          else
            if (sendpointB==1'b1&&biterrorB==1'b1)
              next_stateB <= tra_edof_sendrecb;
            else
              next_stateB <= tra_ack_shifting;
        end
      tra_ack_stopack : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b11;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (erroractivB==1'b1)
            next_stateB <= erroractiv_firstdom;
          else
            next_stateB <= errorpassiv_firstrec;
        end
      tra_edof_sendrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= tra_edof_shifting;
          else
            next_stateB <= tra_edof_sendrecb;
        end
      tra_edof_shifting : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=8)
            next_stateB <= tra_edof_sendrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b0&&countB==8)
              next_stateB <= tra_edof_dectra;
            else
              if (biterrorB==1'b1&&countB==8)
                next_stateB <= over_firstdom;
              else
                if (biterrorB==1'b1&&erroractivB==1'b1&&countB!=8)
                  next_stateB <= erroractiv_firstdom;
                else
                  if (biterrorB==1'b1&&errorpassivB==1'b1&&countB!=8)
                    next_stateB <= errorpassiv_firstrec;
                  else
                    next_stateB <= tra_edof_shifting;
        end
      tra_edof_dectra : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b1;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b11;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= tra_edof_dectra;
        end
      rec_flglen_sample : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (stuffrB==1'b1&&stferrorB==1'b0)
            next_stateB <= rec_flglen_noshift;
          else
            if (stferrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (stferrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==12)
                  next_stateB <= rec_flglen_shiftstdrtr;
                else
                  if ((stuffrB==1'b0)&&(stferrorB==1'b0)&&(inbitB==1'b1)&&(countB==13))
                    next_stateB <= rec_flglen_shiftextnor;
                  else
                    if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==15&&rrtrB==1'b0&&rextB==1'b0)
                      next_stateB <= rec_flglen_shiftdlc64;
                    else
                      if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==16&&rrtrB==1'b0&&rextB==1'b0)
                        next_stateB <= rec_flglen_shiftdlc32;
                      else
                        if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==17&&rrtrB==1'b0&&rextB==1'b0)
                          next_stateB <= rec_flglen_shiftdlc16;
                        else
                          if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==18&&rrtrB==1'b0&&rextB==1'b0)
                            next_stateB <= rec_flglen_shiftdlc8;
                          else
                            if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==32&&rextB==1'b1)
                              next_stateB <= rec_flglen_shiftextrtr;
                            else
                              if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==35&&rrtrB==1'b0&&rextB==1'b1)
                                next_stateB <= rec_flglen_shiftdlc64;
                              else
                                if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==36&&rrtrB==1'b0&&rextB==1'b1)
                                  next_stateB <= rec_flglen_shiftdlc32;
                                else
                                  if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==37&&rrtrB==1'b0&&rextB==1'b1)
                                    next_stateB <= rec_flglen_shiftdlc16;
                                  else
                                    if (stuffrB==1'b0&&stferrorB==1'b0&&inbitB==1'b1&&countB==38&&rrtrB==1'b0&&rextB==1'b1)
                                      next_stateB <= rec_flglen_shiftdlc8;
                                    else
                                      if (stuffrB==1'b0&&stferrorB==1'b0&&(inbitB==1'b0||(countB!=12&&countB!=13&&(rextB==1'b1||rrtrB==1'b1||(countB!=15&&countB!=16&&countB!=17&&countB!=18))&&(countB!=32||rextB==1'b0)&&(rextB==1'b0||rrtrB==1'b1||(countB!=35&&countB!=36&&countB!=37&&countB!=38)))))
                                        next_stateB <= rec_flglen_shifting;
                                      else
                                        next_stateB <= rec_flglen_sample;
        end
      rec_flglen_shifting : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&(! ( (countB==19&&rextB==1'b0)||(countB==39&&rextB==1'b1) ) ))
            next_stateB <= rec_flglen_sample;
          else
            if (smplpointB==1'b1&&((countB==19&&rextB==1'b0)||(countB==39&&rextB==1'b1))&&rrtrB==1'b0&&rmzeroB==1'b0)
              next_stateB <= rec_acptdat_sample;
            else
              if (smplpointB==1'b1&&((countB==19&&rextB==1'b0)||(countB==39&&rextB==1'b1))&&(rrtrB==1'b1||rmzeroB==1'b1))
                next_stateB <= rec_crc_rescnt;
              else
                next_stateB <= rec_flglen_shifting;
        end
      rec_flglen_shiftstdrtr : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b11;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= rec_flglen_shiftstdrtr;
        end
      rec_flglen_shiftextnor : 
        begin
          rext_setB <= 2'b11;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= rec_flglen_shiftextnor;
        end
      rec_flglen_shiftdlc64 : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 4;
          actvrmlnB <= 1'b1;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc32 : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 3;
          actvrmlnB <= 1'b1;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc16 : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 2;
          actvrmlnB <= 1'b1;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc8 : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 1;
          actvrmlnB <= 1'b1;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= rec_flglen_setdlc;
        end
      rec_flglen_setdlc : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 7;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&(! ( (countB==19&&rextB==1'b0)||(countB==39&&rextB==1'b1) ) ))
            next_stateB <= rec_flglen_sample;
          else
            if (smplpointB==1'b1&&((countB==19&&rextB==1'b0)||(countB==39&&rextB==1'b1))&&rrtrB==1'b0)
              next_stateB <= rec_acptdat_sample;
            else
              next_stateB <= rec_flglen_setdlc;
        end
      rec_flglen_shiftextrtr : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b11;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= rec_flglen_shiftextrtr;
        end
      rec_flglen_noshift : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_flglen_sample;
          else
            next_stateB <= rec_flglen_noshift;
        end
      rec_acptdat_sample : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (stuffrB==1'b1&&stferrorB==1'b0)
            next_stateB <= rec_acptdat_noshift;
          else
            if (stferrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (stferrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                next_stateB <= rec_acptdat_shifting;
        end
      rec_acptdat_shifting : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&startrcrcB==1'b0)
            next_stateB <= rec_acptdat_sample;
          else
            if (startrcrcB==1'b1)
              next_stateB <= rec_acptdat_lastshift;
            else
              next_stateB <= rec_acptdat_shifting;
        end
      rec_acptdat_noshift : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_acptdat_sample;
          else
            next_stateB <= rec_acptdat_noshift;
        end
      rec_acptdat_lastshift : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_crc_rescnt;
          else
            next_stateB <= rec_acptdat_lastshift;
        end
      rec_crc_rescnt : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b1;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= rec_crc_sample;
        end
      rec_crc_sample : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (stuffrB==1'b1&&stferrorB==1'b0)
            next_stateB <= rec_crc_noshift;
          else
            if (stferrorB==1'b1&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (stferrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                if (countB==15)
                  next_stateB <= rec_ack_recdelim;
                else
                  next_stateB <= rec_crc_shifting;
        end
      rec_crc_shifting : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b1;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b1;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_crc_sample;
          else
            next_stateB <= rec_crc_shifting;
        end
      rec_crc_noshift : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b1;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_crc_sample;
          else
            next_stateB <= rec_crc_noshift;
        end
      rec_ack_recdelim : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b1&&crc_okB==1'b0)
            next_stateB <= rec_ack_prepnoack;
          else
            if (inbitB==1'b0&&erroractivB==1'b1)
              next_stateB <= erroractiv_firstdom;
            else
              if (inbitB==1'b0&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                if (inbitB==1'b0&&busofB==1'b1)
                  next_stateB <= busoff_first;
                else
                  next_stateB <= rec_ack_prepgiveack;
        end
      rec_ack_prepgiveack : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b1;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= rec_ack_giveack;
          else
            next_stateB <= rec_ack_prepgiveack;
        end
      rec_ack_giveack : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_ack_checkack;
          else
            next_stateB <= rec_ack_giveack;
        end
      rec_ack_checkack : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (biterrorB==1'b1&&erroractivB==1'b1)
            next_stateB <= erroractiv_firstdom;
          else
            if (biterrorB==1'b1&&errorpassivB==1'b1)
              next_stateB <= errorpassiv_firstrec;
            else
              if (sendpointB==1'b1)
                next_stateB <= rec_ack_stopack;
              else
                next_stateB <= rec_ack_checkack;
        end
      rec_ack_prepnoack : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= rec_ack_noack;
          else
            next_stateB <= rec_ack_prepnoack;
        end
      rec_ack_noack : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&erroractivB==1'b1)
            next_stateB <= erroractiv_firstdom;
          else
            if (smplpointB==1'b1&&errorpassivB==1'b1)
              next_stateB <= errorpassiv_firstrec;
            else
              if (smplpointB==1'b1&&busofB==1'b1)
                next_stateB <= busoff_first;
              else
                next_stateB <= rec_ack_noack;
        end
      rec_ack_stopack : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_edof_sample;
          else
            next_stateB <= rec_ack_stopack;
        end
      rec_edof_sample : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b0&&erroractivB==1'b1)
            next_stateB <= erroractiv_firstdom;
          else
            if (inbitB==1'b0&&errorpassivB==1'b1)
              next_stateB <= errorpassiv_firstrec;
            else
              next_stateB <= rec_edof_check;
        end
      rec_edof_check : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (countB!=7&&smplpointB==1'b1)
            next_stateB <= rec_edof_sample;
          else
            if (countB==7&&inbitB==1'b1)
              next_stateB <= rec_edof_endrec;
            else
              next_stateB <= rec_edof_check;
        end
      rec_edof_endrec : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b1;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= rec_edof_lastbit;
          else
            next_stateB <= rec_edof_endrec;
        end
      rec_edof_lastbit : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b1)
            next_stateB <= rec_edof_inter;
          else
            if (inbitB==1'b0)
              next_stateB <= over_firstdom;
            else
              next_stateB <= rec_edof_lastbit;
        end
      rec_edof_inter : 
        begin
          rext_setB <= 2'b00;
          rrtr_setB <= 2'b00;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b11;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= rec_edof_inter;
        end
      over_firstdom : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= over_senddomb;
          else
            next_stateB <= over_firstdom;
        end
      over_senddomb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= over_check1;
          else
            next_stateB <= over_senddomb;
        end
      over_check1 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=6)
            next_stateB <= over_senddomb;
          else
            if (biterrorB==1'b0&&countB==6)
              next_stateB <= over_preprecb;
            else
              if (biterrorB==1'b1&&erroractivB==1'b1)
                next_stateB <= erroractiv_firstdom;
              else
                if (biterrorB==1'b1&&errorpassivB==1'b1)
                  next_stateB <= errorpassiv_firstrec;
                else
                  if (biterrorB==1'b1&&busofB==1'b1)
                    next_stateB <= busoff_first;
                  else
                    next_stateB <= over_check1;
        end
      over_preprecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= over_wtonrecb;
          else
            next_stateB <= over_preprecb;
        end
      over_wtonrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= over_check2;
          else
            next_stateB <= over_wtonrecb;
        end
      over_inctracounter : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= over_check2;
          else
            next_stateB <= over_inctracounter;
        end
      over_increccounter : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= over_check2;
          else
            next_stateB <= over_increccounter;
        end
      over_check2 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b1&&countB!=7)
            next_stateB <= over_wtonrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&receiverB==1'b1)
              next_stateB <= over_increccounter;
            else
              if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&transmitterB==1'b1)
                next_stateB <= over_inctracounter;
              else
                if (biterrorB==1'b0)
                  next_stateB <= over_prepsend;
                else
                  next_stateB <= over_check2;
        end
      over_prepsend : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= over_sendrecb;
          else
            next_stateB <= over_prepsend;
        end
      over_sendrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= over_check3;
          else
            next_stateB <= over_sendrecb;
        end
      over_check3 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=7)
            next_stateB <= over_sendrecb;
          else
            if (biterrorB==1'b0&&countB==7)
              next_stateB <= over_waitoclk;
            else
              if (biterrorB==1'b1&&countB==7)
                next_stateB <= over_firstdom;
              else
                if (biterrorB==1'b1&&erroractivB==1'b1&&countB!=7)
                  next_stateB <= erroractiv_firstdom;
                else
                  if (biterrorB==1'b1&&errorpassivB==1'b1&&countB!=7)
                    next_stateB <= errorpassiv_firstrec;
                  else
                    if (biterrorB==1'b1&&busofB==1'b1&&countB!=7)
                      next_stateB <= busoff_first;
                    else
                      next_stateB <= over_check3;
        end
      over_waitoclk : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= over_waitoclk;
        end
      erroractiv_firstdom : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b00;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b00;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&onarbitB==1'b1)
            next_stateB <= erroractiv_senddomb;
          else
            if (onarbitB==1'b0&&transmitterB==1'b0&&receiverB==1'b1&&errorB==1'b0)
              next_stateB <= erroractiv_inceinsrec;
            else
              if (onarbitB==1'b0&&transmitterB==1'b0&&receiverB==1'b1&&errorB==1'b1)
                next_stateB <= erroractiv_incachtrec;
              else
                if (onarbitB==1'b0&&transmitterB==1'b1)
                  next_stateB <= erroractiv_incachttra;
                else
                  next_stateB <= erroractiv_firstdom;
        end
      erroractiv_inceinsrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b1;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= erroractiv_senddomb;
          else
            next_stateB <= erroractiv_inceinsrec;
        end
      erroractiv_incachtrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= erroractiv_senddomb;
          else
            next_stateB <= erroractiv_incachtrec;
        end
      erroractiv_incachttra : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= erroractiv_senddomb;
          else
            next_stateB <= erroractiv_incachttra;
        end
      erroractiv_senddomb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check1;
          else
            next_stateB <= erroractiv_senddomb;
        end
      erroractiv_check1 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b1;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=6)
            next_stateB <= erroractiv_senddomb;
          else
            if (biterrorB==1'b0&&countB==6)
              next_stateB <= erroractiv_preprecb;
            else
              if (biterrorB==1'b1&&erroractivB==1'b1)
                next_stateB <= erroractiv_firstdom;
              else
                if (biterrorB==1'b1&&errorpassivB==1'b1)
                  next_stateB <= errorpassiv_firstrec;
                else
                  if (biterrorB==1'b1&&busofB==1'b1)
                    next_stateB <= busoff_first;
                  else
                    next_stateB <= erroractiv_check1;
        end
      erroractiv_preprecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= erroractiv_wtonrecb;
          else
            next_stateB <= erroractiv_preprecb;
        end
      erroractiv_wtonrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b00;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check2;
          else
            next_stateB <= erroractiv_wtonrecb;
        end
      erroractiv_dombitdct : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check2;
          else
            next_stateB <= erroractiv_dombitdct;
        end
      erroractiv_egtdombr : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check2;
          else
            next_stateB <= erroractiv_egtdombr;
        end
      erroractiv_egtdombt : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check2;
          else
            next_stateB <= erroractiv_egtdombt;
        end
      erroractiv_check2 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b00;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b1&&countB!=7&&(countB!=1||receiverB==1'b0||firstB==1'b0))
            next_stateB <= erroractiv_wtonrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b1&&countB==1&&receiverB==1'b1&&firstB==1'b1)
              next_stateB <= erroractiv_dombitdct;
            else
              if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&transmitterB==1'b1&&receiverB==1'b0)
                next_stateB <= erroractiv_egtdombt;
              else
                if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&transmitterB==1'b0&&receiverB==1'b1)
                  next_stateB <= erroractiv_egtdombr;
                else
                  if (biterrorB==1'b0)
                    next_stateB <= erroractiv_prepsend;
                  else
                    next_stateB <= erroractiv_check2;
        end
      erroractiv_prepsend : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= erroractiv_sendrecb;
          else
            next_stateB <= erroractiv_prepsend;
        end
      erroractiv_sendrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= erroractiv_check3;
          else
            next_stateB <= erroractiv_sendrecb;
        end
      erroractiv_check3 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=7)
            next_stateB <= erroractiv_sendrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b0&&countB==7)
              next_stateB <= erroractiv_waitoclk;
            else
              if (biterrorB==1'b1&&erroractivB==1'b1)
                next_stateB <= erroractiv_firstdom;
              else
                if (biterrorB==1'b1&&errorpassivB==1'b1)
                  next_stateB <= errorpassiv_firstrec;
                else
                  if (biterrorB==1'b1&&busofB==1'b1)
                    next_stateB <= busoff_first;
                  else
                    next_stateB <= erroractiv_check3;
        end
      erroractiv_waitoclk : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= erroractiv_waitoclk;
        end
      errorpassiv_firstrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b00;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b00;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&transmitterB==1'b1&&(onarbitB==1'b1||ackerrorB==1'b1))
            next_stateB <= errorpassiv_incsrecb;
          else
            if (onarbitB==1'b0&&transmitterB==1'b0&&receiverB==1'b1&&errorB==1'b0)
              next_stateB <= errorpassiv_inceinsrec;
            else
              if (onarbitB==1'b0&&transmitterB==1'b0&&receiverB==1'b1&&errorB==1'b1)
                next_stateB <= errorpassiv_incachtrec;
              else
                if (onarbitB==1'b0&&transmitterB==1'b1&&ackerrorB==1'b0)
                  next_stateB <= errorpassiv_incachttra;
                else
                  next_stateB <= errorpassiv_firstrec;
        end
      errorpassiv_inceinsrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b1;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_inceinsrec;
        end
      errorpassiv_incachtrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_incachtrec;
        end
      errorpassiv_incachttra : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_incachttra;
        end
      errorpassiv_incsrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b00;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&countB!=0)
            next_stateB <= errorpassiv_check1;
          else
            if (smplpointB==1'b1&&countB==0)
              next_stateB <= errorpassiv_fillpuffer;
            else
              next_stateB <= errorpassiv_incsrecb;
        end
      errorpassiv_fillpuffer : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b0&&transmitterB==1'b1&&ackerrorB==1'b1)
            next_stateB <= errorpassiv_pufferdomi;
          else
            if (inbitB==1'b0&&(transmitterB==1'b0||ackerrorB==1'b0))
              next_stateB <= errorpassiv_pufferdom;
            else
              next_stateB <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferrec : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b11;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferdom : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_pufferdom;
        end
      errorpassiv_pufferdomi : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_incsrecb;
          else
            next_stateB <= errorpassiv_pufferdomi;
        end
      errorpassiv_zersrecbo : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b11;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbz : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbi : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= errorpassiv_newcount;
        end
      errorpassiv_newcount : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b00;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          next_stateB <= errorpassiv_prepcount;
        end
      errorpassiv_prepcount : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b00;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check1;
          else
            next_stateB <= errorpassiv_prepcount;
        end
      errorpassiv_check1 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b00;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b00;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==pufferB&&biterrorB==1'b1&&transmitterB==1'b1&&ackerrorB==1'b1)
            next_stateB <= errorpassiv_zersrecbi;
          else
            if (sendpointB==1'b1&&biterrorB==pufferB&&biterrorB==1'b1&&(ackerrorB==1'b0||transmitterB==1'b0))
              next_stateB <= errorpassiv_zersrecbz;
            else
              if (sendpointB==1'b1&&biterrorB==pufferB&&biterrorB==1'b0)
                next_stateB <= errorpassiv_zersrecbo;
              else
                if (sendpointB==1'b1&&biterrorB!=pufferB&&countB!=6)
                  next_stateB <= errorpassiv_incsrecb;
                else
                  if (biterrorB!=pufferB&&countB==6)
                    next_stateB <= errorpassiv_preprecb;
                  else
                    next_stateB <= errorpassiv_check1;
        end
      errorpassiv_preprecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b11;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_wtonrecb;
          else
            next_stateB <= errorpassiv_preprecb;
        end
      errorpassiv_wtonrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b00;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check2;
          else
            next_stateB <= errorpassiv_wtonrecb;
        end
      errorpassiv_dombitdct : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check2;
          else
            next_stateB <= errorpassiv_dombitdct;
        end
      errorpassiv_egtdombr : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b1;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check2;
          else
            next_stateB <= errorpassiv_egtdombr;
        end
      errorpassiv_egtdombt : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b1;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check2;
          else
            next_stateB <= errorpassiv_egtdombt;
        end
      errorpassiv_check2 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b00;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b1&&countB!=7&&(countB!=1||receiverB==1'b0||firstB==1'b0))
            next_stateB <= errorpassiv_wtonrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b1&&countB==1&&receiverB==1'b1&&firstB==1'b1)
              next_stateB <= errorpassiv_dombitdct;
            else
              if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&transmitterB==1'b1&&receiverB==1'b0)
                next_stateB <= errorpassiv_egtdombt;
              else
                if (sendpointB==1'b1&&biterrorB==1'b1&&countB==7&&transmitterB==1'b0&&receiverB==1'b1)
                  next_stateB <= errorpassiv_egtdombr;
                else
                  if (biterrorB==1'b0)
                    next_stateB <= errorpassiv_prepsend;
                  else
                    next_stateB <= errorpassiv_check2;
        end
      errorpassiv_prepsend : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1)
            next_stateB <= errorpassiv_sendrecb;
          else
            next_stateB <= errorpassiv_prepsend;
        end
      errorpassiv_sendrecb : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b1;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b1;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= errorpassiv_check3;
          else
            next_stateB <= errorpassiv_sendrecb;
        end
      errorpassiv_check3 : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b1;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (sendpointB==1'b1&&biterrorB==1'b0&&countB!=7)
            next_stateB <= errorpassiv_sendrecb;
          else
            if (sendpointB==1'b1&&biterrorB==1'b0&&countB==7)
              next_stateB <= errorpassiv_waitoclk;
            else
              if (biterrorB==1'b1&&errorpassivB==1'b1)
                next_stateB <= errorpassiv_firstrec;
              else
                if (biterrorB==1'b1&&busofB==1'b1)
                  next_stateB <= busoff_first;
                else
                  next_stateB <= errorpassiv_check3;
        end
      errorpassiv_waitoclk : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b1;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b0;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b1;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b00;
          receiver_setB <= 2'b00;
          error_setB <= 2'b11;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= inter_sample;
          else
            next_stateB <= errorpassiv_waitoclk;
        end
      busoff_first : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= busoff_sample;
          else
            next_stateB <= busoff_first;
        end
      busoff_sample : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b1;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (inbitB==1'b1&&countB!=10)
            next_stateB <= busoff_increm;
          else
            if (inbitB==1'b1&&countB==10)
              next_stateB <= busoff_deccnt;
            else
              next_stateB <= busoff_setzer;
        end
      busoff_increm : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b1;
          rescountB <= 1'b1;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= busoff_sample;
          else
            next_stateB <= busoff_increm;
        end
      busoff_setzer : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b0;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b1;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1)
            next_stateB <= busoff_sample;
          else
            next_stateB <= busoff_setzer;
        end
      busoff_deccnt : 
        begin
          rext_setB <= 2'b10;
          rrtr_setB <= 2'b10;
          actvtcrcB <= 1'b0;
          actvrcrcB <= 1'b0;
          actvtstfB <= 1'b0;
          actvrstfB <= 1'b0;
          actvtsftB <= 1'b0;
          actvrsftB <= 1'b0;
          actvtdctB <= 1'b0;
          actvrdctB <= 1'b1;
          actvtbedB <= 1'b0;
          setbdomB <= 1'b0;
          setbrecB <= 1'b0;
          lcrcB <= 1'b0;
          tshiftB <= 1'b0;
          inconerecB <= 1'b0;
          incegtrecB <= 1'b0;
          incegttraB <= 1'b0;
          lmsgB <= 1'b0;
          decrecB <= 1'b0;
          dectraB <= 1'b0;
          elevrecbB <= 1'b1;
          hardsyncB <= 1'b0;
          resetdstB <= 1'b1;
          resetstfB <= 1'b0;
          inccountB <= 1'b0;
          rescountB <= 1'b0;
          setrmlenoB <= 0;
          actvrmlnB <= 1'b0;
          resrmlenB <= 1'b1;
          ackerror_setB <= 2'b10;
          transmitter_setB <= 2'b10;
          receiver_setB <= 2'b10;
          error_setB <= 2'b10;
          first_setB <= 2'b10;
          activatefastB <= 1'b0;
          puffer_setB <= 2'b10;
          onarbit_setB <= 2'b10;
          en_zerointcrcB <= 1'b1;
          crc_shft_outB <= 1'b0;
          if (smplpointB==1'b1&&busofB==1'b1)
            next_stateB <= busoff_sample;
          else
            if (smplpointB==1'b1&&busofB==1'b0)
              next_stateB <= inter_sample;
            else
              next_stateB <= busoff_deccnt;
        end
      default : 
        begin
        end
    endcase
  end

always @*
  begin
    rext_setC <= 2'b00;
    rrtr_setC <= 2'b00;
    actvtcrcC <= 1'b0;
    actvrcrcC <= 1'b0;
    actvtstfC <= 1'b0;
    actvrstfC <= 1'b0;
    actvtsftC <= 1'b0;
    actvrsftC <= 1'b0;
    actvtdctC <= 1'b0;
    actvrdctC <= 1'b1;
    actvtbedC <= 1'b0;
    setbdomC <= 1'b0;
    setbrecC <= 1'b0;
    lcrcC <= 1'b0;
    tshiftC <= 1'b0;
    inconerecC <= 1'b0;
    incegtrecC <= 1'b0;
    incegttraC <= 1'b0;
    lmsgC <= 1'b0;
    decrecC <= 1'b0;
    dectraC <= 1'b0;
    elevrecbC <= 1'b0;
    resetdstC <= 1'b1;
    resetstfC <= 1'b1;
    hardsyncC <= 1'b1;
    inccountC <= 1'b0;
    rescountC <= 1'b0;
    setrmlenoC <= 0;
    actvrmlnC <= 1'b0;
    resrmlenC <= 1'b0;
    ackerror_setC <= 2'b10;
    transmitter_setC <= 2'b10;
    receiver_setC <= 2'b10;
    error_setC <= 2'b10;
    first_setC <= 2'b10;
    activatefastC <= 1'b0;
    puffer_setC <= 2'b10;
    onarbit_setC <= 2'b10;
    en_zerointcrcC <= 1'b1;
    crc_shft_outC <= 1'b0;
    next_stateC <= current_stateVotedC;
    case (current_stateVotedC)
      sync_start : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b0;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= sync_sample;
          else
            next_stateC <= sync_start;
        end
      sync_sample : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b1)
            next_stateC <= sync_sum;
          else
            next_stateC <= sync_start;
        end
      sync_sum : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&countC!=8)
            next_stateC <= sync_sample;
          else
            if (countC==8)
              next_stateC <= sync_end;
            else
              next_stateC <= sync_sum;
        end
      sync_end : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= bus_idle_sample;
          else
            next_stateC <= sync_end;
        end
      inter_sample : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (busofC==1'b1)
            next_stateC <= busoff_first;
          else
            if ((((errorpassivC==1'b0||receiverC==1'b1)&&lt3C==1'b1)||((errorpassivC==1'b1&&receiverC==1'b0)&&lt11C==1'b1))&&inbitC==1'b1)
              next_stateC <= inter_check;
            else
              if (lt3C==1'b1&&inbitC==1'b0)
                next_stateC <= over_firstdom;
              else
                if (inbitC==1'b0&&(gt3C==1'b1||((eq3C==1'b1||gt3C==1'b1)&&((errorpassivC==1'b1&&receiverC==1'b0)||transC==1'b0))))
                  next_stateC <= inter_preprec;
                else
                  if (sendpointC==1'b1&&(((errorpassivC==1'b0||receiverC==1'b1)&&(eq3C==1'b1||gt3C==1'b1))||((errorpassivC==1'b1&&receiverC==1'b0)&&(eq11C==1'b1||lt11C==1'b0)))&&inbitC==1'b1&&transC==1'b1)
                    next_stateC <= inter_goregtran;
                  else
                    if ((errorpassivC==1'b0||receiverC==1'b1)&&(eq3C==1'b1||gt3C==1'b1)&&inbitC==1'b0&&transC==1'b1)
                      next_stateC <= inter_react;
                    else
                      if (transC==1'b0&&(((eq3C==1'b1||gt3C==1'b1)&&(errorpassivC==1'b0||receiverC==1'b1))||((eq11C==1'b1||lt11C==1'b0)&&(errorpassivC==1'b1&&receiverC==1'b0))))
                        next_stateC <= bus_idle_chk;
                      else
                        next_stateC <= inter_sample;
        end
      inter_check : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b0;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= inter_check;
        end
      bus_idle_chk : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b0;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= bus_idle_sample;
          else
            next_stateC <= bus_idle_chk;
        end
      bus_idle_sample : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (transC==1'b0&&inbitC==1'b1)
            next_stateC <= bus_idle_chk;
          else
            if (inbitC==1'b0&&transC==1'b0)
              next_stateC <= inter_preprec;
            else
              if (inbitC==1'b0&&transC==1'b1)
                next_stateC <= inter_react;
              else
                if (sendpointC==1'b1&&inbitC==1'b1&&transC==1'b1)
                  next_stateC <= inter_goregtran;
                else
                  next_stateC <= bus_idle_sample;
        end
      inter_react : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b0;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          next_stateC <= inter_transhift;
        end
      inter_goregtran : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b0;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b0;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          next_stateC <= inter_regtrancnt;
        end
      inter_regtrancnt : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b0;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_arbit_tsftrsmpl;
          else
            next_stateC <= inter_regtrancnt;
        end
      inter_arbit_tsftrsmpl : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= tra_arbit_tactrsftn;
          else
            next_stateC <= inter_arbit_tsftrsmpl;
        end
      inter_transhift : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          next_stateC <= inter_incsigres;
        end
      inter_incsigres : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b0;
          crc_shft_outC <= 1'b0;
          next_stateC <= tra_arbit_tactrsftn;
        end
      inter_preprec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b0;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= inter_preprec_shifting;
        end
      inter_preprec_shifting : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= inter_preprec_shifting;
        end
      tra_arbit_tnactrnsft : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= tra_arbit_tsftrsmpl;
          else
            next_stateC <= tra_arbit_tnactrnsft;
        end
      tra_arbit_tactrsftn : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&stufftC==1'b0)
            next_stateC <= tra_arbit_tsftrsmpl;
          else
            if (smplpointC==1'b1&&stufftC==1'b1)
              next_stateC <= tra_arbit_tnsftrsmpl;
            else
              next_stateC <= tra_arbit_tactrsftn;
        end
      tra_arbit_tactrsftsr : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b11;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&stufftC==1'b0)
            next_stateC <= tra_arbit_tsftrsmpl;
          else
            if (smplpointC==1'b1&&stufftC==1'b1)
              next_stateC <= tra_arbit_tnsftrsmpl;
            else
              next_stateC <= tra_arbit_tactrsftsr;
        end
      tra_arbit_tactrsfte : 
        begin
          rext_setC <= 2'b11;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&stufftC==1'b0)
            next_stateC <= tra_arbit_tsftrsmpl;
          else
            if (smplpointC==1'b1&&stufftC==1'b1)
              next_stateC <= tra_arbit_tnsftrsmpl;
            else
              next_stateC <= tra_arbit_tactrsfte;
        end
      tra_arbit_tactrsfter : 
        begin
          rext_setC <= 2'b11;
          rrtr_setC <= 2'b11;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&stufftC==1'b0)
            next_stateC <= tra_arbit_tsftrsmpl;
          else
            if (smplpointC==1'b1&&stufftC==1'b1)
              next_stateC <= tra_arbit_tnsftrsmpl;
            else
              next_stateC <= tra_arbit_tactrsfter;
        end
      tra_arbit_tsftrsmpl : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&stferrorC==1'b0&&countC==13&&inbitC==1'b1&&textC==1'b1)
            next_stateC <= tra_arbit_tactrsftsr;
          else
            if (sendpointC==1'b1&&biterrorC==1'b0&&stferrorC==1'b0&&countC==14&&inbitC==1'b1)
              next_stateC <= tra_arbit_tactrsfte;
            else
              if (sendpointC==1'b1&&biterrorC==1'b0&&stferrorC==1'b0&&countC==33&&inbitC==1'b1)
                next_stateC <= tra_arbit_tactrsfter;
              else
                if (sendpointC==1'b1&&biterrorC==1'b0&&stferrorC==1'b0&&(inbitC==1'b0||(countC!=13&&countC!=14&&countC!=33))&&(! ( (countC==13&&textC==1'b0)||(countC==34&&textC==1'b1) ) ))
                  next_stateC <= tra_arbit_tactrsftn;
                else
                  if (sendpointC==1'b1&&biterrorC==1'b0&&stferrorC==1'b0&&((countC==13&&textC==1'b0)||(countC==34&&textC==1'b1)))
                    next_stateC <= tra_data_activatecrc;
                  else
                    if (biterrorC==1'b1&&stferrorC==1'b0)
                      next_stateC <= tra_arbit_goreceive;
                    else
                      next_stateC <= tra_arbit_tsftrsmpl;
        end
      tra_arbit_goreceive : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= tra_arbit_goreceive;
        end
      tra_arbit_tnsftrsmpl : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          hardsyncC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b11;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_arbit_tnactrnsft;
          else
            if (stferrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (stferrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_arbit_tnsftrsmpl;
        end
      tra_data_activatecrc : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b1;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&stufftC==1'b0&&starttcrcC==1'b0)
            next_stateC <= tra_data_shifting;
          else
            if (smplpointC==1'b1&&stufftC==1'b0&&starttcrcC==1'b1)
              next_stateC <= tra_data_lastshift;
            else
              if (smplpointC==1'b1&&stufftC==1'b1)
                next_stateC <= tra_data_noshift;
              else
                next_stateC <= tra_data_activatecrc;
        end
      tra_data_activatncrc : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&starttcrcC==1'b0)
            next_stateC <= tra_data_shifting;
          else
            if (smplpointC==1'b1&&starttcrcC==1'b1)
              next_stateC <= tra_data_lastshift;
            else
              next_stateC <= tra_data_activatncrc;
        end
      tra_data_shifting : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_data_activatecrc;
          else
            if (biterrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_data_shifting;
        end
      tra_data_lastshift : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (biterrorC==1'b1&&erroractivC==1'b1)
            next_stateC <= erroractiv_firstdom;
          else
            if (biterrorC==1'b1&&errorpassivC==1'b1)
              next_stateC <= errorpassiv_firstrec;
            else
              next_stateC <= tra_data_loadcrc;
        end
      tra_data_noshift : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_data_activatncrc;
          else
            if (biterrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_data_noshift;
        end
      tra_data_loadcrc : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= tra_crc_activatedec;
          else
            next_stateC <= tra_data_loadcrc;
        end
      tra_crc_activatedec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b1;
          if (smplpointC==1'b1&&stufftC==1'b0&&countC!=16)
            next_stateC <= tra_crc_shifting;
          else
            if (smplpointC==1'b1&&stufftC==1'b0&&countC==16)
              next_stateC <= tra_crc_delshft;
            else
              if (smplpointC==1'b1&&stufftC==1'b1)
                next_stateC <= tra_crc_noshift;
              else
                next_stateC <= tra_crc_activatedec;
        end
      tra_crc_activatndec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b1;
          if (smplpointC==1'b1&&countC!=16)
            next_stateC <= tra_crc_shifting;
          else
            if (smplpointC==1'b1&&countC==16)
              next_stateC <= tra_crc_delshft;
            else
              next_stateC <= tra_crc_activatndec;
        end
      tra_crc_shifting : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b1;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_crc_activatedec;
          else
            if (biterrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_crc_shifting;
        end
      tra_crc_noshift : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b1;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_crc_activatndec;
          else
            if (biterrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_crc_noshift;
        end
      tra_crc_delshft : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b1;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b1;
          if (sendpointC==1'b1&&biterrorC==1'b0)
            next_stateC <= tra_ack_sendack;
          else
            if (biterrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= tra_crc_delshft;
        end
      tra_ack_sendack : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= tra_ack_shifting;
          else
            next_stateC <= tra_ack_sendack;
        end
      tra_ack_shifting : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (biterrorC==1'b0)
            next_stateC <= tra_ack_stopack;
          else
            if (sendpointC==1'b1&&biterrorC==1'b1)
              next_stateC <= tra_edof_sendrecb;
            else
              next_stateC <= tra_ack_shifting;
        end
      tra_ack_stopack : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b11;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (erroractivC==1'b1)
            next_stateC <= erroractiv_firstdom;
          else
            next_stateC <= errorpassiv_firstrec;
        end
      tra_edof_sendrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= tra_edof_shifting;
          else
            next_stateC <= tra_edof_sendrecb;
        end
      tra_edof_shifting : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=8)
            next_stateC <= tra_edof_sendrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b0&&countC==8)
              next_stateC <= tra_edof_dectra;
            else
              if (biterrorC==1'b1&&countC==8)
                next_stateC <= over_firstdom;
              else
                if (biterrorC==1'b1&&erroractivC==1'b1&&countC!=8)
                  next_stateC <= erroractiv_firstdom;
                else
                  if (biterrorC==1'b1&&errorpassivC==1'b1&&countC!=8)
                    next_stateC <= errorpassiv_firstrec;
                  else
                    next_stateC <= tra_edof_shifting;
        end
      tra_edof_dectra : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b1;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b11;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= tra_edof_dectra;
        end
      rec_flglen_sample : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (stuffrC==1'b1&&stferrorC==1'b0)
            next_stateC <= rec_flglen_noshift;
          else
            if (stferrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (stferrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==12)
                  next_stateC <= rec_flglen_shiftstdrtr;
                else
                  if ((stuffrC==1'b0)&&(stferrorC==1'b0)&&(inbitC==1'b1)&&(countC==13))
                    next_stateC <= rec_flglen_shiftextnor;
                  else
                    if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==15&&rrtrC==1'b0&&rextC==1'b0)
                      next_stateC <= rec_flglen_shiftdlc64;
                    else
                      if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==16&&rrtrC==1'b0&&rextC==1'b0)
                        next_stateC <= rec_flglen_shiftdlc32;
                      else
                        if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==17&&rrtrC==1'b0&&rextC==1'b0)
                          next_stateC <= rec_flglen_shiftdlc16;
                        else
                          if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==18&&rrtrC==1'b0&&rextC==1'b0)
                            next_stateC <= rec_flglen_shiftdlc8;
                          else
                            if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==32&&rextC==1'b1)
                              next_stateC <= rec_flglen_shiftextrtr;
                            else
                              if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==35&&rrtrC==1'b0&&rextC==1'b1)
                                next_stateC <= rec_flglen_shiftdlc64;
                              else
                                if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==36&&rrtrC==1'b0&&rextC==1'b1)
                                  next_stateC <= rec_flglen_shiftdlc32;
                                else
                                  if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==37&&rrtrC==1'b0&&rextC==1'b1)
                                    next_stateC <= rec_flglen_shiftdlc16;
                                  else
                                    if (stuffrC==1'b0&&stferrorC==1'b0&&inbitC==1'b1&&countC==38&&rrtrC==1'b0&&rextC==1'b1)
                                      next_stateC <= rec_flglen_shiftdlc8;
                                    else
                                      if (stuffrC==1'b0&&stferrorC==1'b0&&(inbitC==1'b0||(countC!=12&&countC!=13&&(rextC==1'b1||rrtrC==1'b1||(countC!=15&&countC!=16&&countC!=17&&countC!=18))&&(countC!=32||rextC==1'b0)&&(rextC==1'b0||rrtrC==1'b1||(countC!=35&&countC!=36&&countC!=37&&countC!=38)))))
                                        next_stateC <= rec_flglen_shifting;
                                      else
                                        next_stateC <= rec_flglen_sample;
        end
      rec_flglen_shifting : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&(! ( (countC==19&&rextC==1'b0)||(countC==39&&rextC==1'b1) ) ))
            next_stateC <= rec_flglen_sample;
          else
            if (smplpointC==1'b1&&((countC==19&&rextC==1'b0)||(countC==39&&rextC==1'b1))&&rrtrC==1'b0&&rmzeroC==1'b0)
              next_stateC <= rec_acptdat_sample;
            else
              if (smplpointC==1'b1&&((countC==19&&rextC==1'b0)||(countC==39&&rextC==1'b1))&&(rrtrC==1'b1||rmzeroC==1'b1))
                next_stateC <= rec_crc_rescnt;
              else
                next_stateC <= rec_flglen_shifting;
        end
      rec_flglen_shiftstdrtr : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b11;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= rec_flglen_shiftstdrtr;
        end
      rec_flglen_shiftextnor : 
        begin
          rext_setC <= 2'b11;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= rec_flglen_shiftextnor;
        end
      rec_flglen_shiftdlc64 : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 4;
          actvrmlnC <= 1'b1;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc32 : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 3;
          actvrmlnC <= 1'b1;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc16 : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 2;
          actvrmlnC <= 1'b1;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= rec_flglen_setdlc;
        end
      rec_flglen_shiftdlc8 : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 1;
          actvrmlnC <= 1'b1;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= rec_flglen_setdlc;
        end
      rec_flglen_setdlc : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 7;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&(! ( (countC==19&&rextC==1'b0)||(countC==39&&rextC==1'b1) ) ))
            next_stateC <= rec_flglen_sample;
          else
            if (smplpointC==1'b1&&((countC==19&&rextC==1'b0)||(countC==39&&rextC==1'b1))&&rrtrC==1'b0)
              next_stateC <= rec_acptdat_sample;
            else
              next_stateC <= rec_flglen_setdlc;
        end
      rec_flglen_shiftextrtr : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b11;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= rec_flglen_shiftextrtr;
        end
      rec_flglen_noshift : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_flglen_sample;
          else
            next_stateC <= rec_flglen_noshift;
        end
      rec_acptdat_sample : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (stuffrC==1'b1&&stferrorC==1'b0)
            next_stateC <= rec_acptdat_noshift;
          else
            if (stferrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (stferrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                next_stateC <= rec_acptdat_shifting;
        end
      rec_acptdat_shifting : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&startrcrcC==1'b0)
            next_stateC <= rec_acptdat_sample;
          else
            if (startrcrcC==1'b1)
              next_stateC <= rec_acptdat_lastshift;
            else
              next_stateC <= rec_acptdat_shifting;
        end
      rec_acptdat_noshift : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_acptdat_sample;
          else
            next_stateC <= rec_acptdat_noshift;
        end
      rec_acptdat_lastshift : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_crc_rescnt;
          else
            next_stateC <= rec_acptdat_lastshift;
        end
      rec_crc_rescnt : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b1;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= rec_crc_sample;
        end
      rec_crc_sample : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (stuffrC==1'b1&&stferrorC==1'b0)
            next_stateC <= rec_crc_noshift;
          else
            if (stferrorC==1'b1&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (stferrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                if (countC==15)
                  next_stateC <= rec_ack_recdelim;
                else
                  next_stateC <= rec_crc_shifting;
        end
      rec_crc_shifting : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b1;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b1;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_crc_sample;
          else
            next_stateC <= rec_crc_shifting;
        end
      rec_crc_noshift : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b1;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_crc_sample;
          else
            next_stateC <= rec_crc_noshift;
        end
      rec_ack_recdelim : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b1&&crc_okC==1'b0)
            next_stateC <= rec_ack_prepnoack;
          else
            if (inbitC==1'b0&&erroractivC==1'b1)
              next_stateC <= erroractiv_firstdom;
            else
              if (inbitC==1'b0&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                if (inbitC==1'b0&&busofC==1'b1)
                  next_stateC <= busoff_first;
                else
                  next_stateC <= rec_ack_prepgiveack;
        end
      rec_ack_prepgiveack : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b1;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= rec_ack_giveack;
          else
            next_stateC <= rec_ack_prepgiveack;
        end
      rec_ack_giveack : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_ack_checkack;
          else
            next_stateC <= rec_ack_giveack;
        end
      rec_ack_checkack : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (biterrorC==1'b1&&erroractivC==1'b1)
            next_stateC <= erroractiv_firstdom;
          else
            if (biterrorC==1'b1&&errorpassivC==1'b1)
              next_stateC <= errorpassiv_firstrec;
            else
              if (sendpointC==1'b1)
                next_stateC <= rec_ack_stopack;
              else
                next_stateC <= rec_ack_checkack;
        end
      rec_ack_prepnoack : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= rec_ack_noack;
          else
            next_stateC <= rec_ack_prepnoack;
        end
      rec_ack_noack : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&erroractivC==1'b1)
            next_stateC <= erroractiv_firstdom;
          else
            if (smplpointC==1'b1&&errorpassivC==1'b1)
              next_stateC <= errorpassiv_firstrec;
            else
              if (smplpointC==1'b1&&busofC==1'b1)
                next_stateC <= busoff_first;
              else
                next_stateC <= rec_ack_noack;
        end
      rec_ack_stopack : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_edof_sample;
          else
            next_stateC <= rec_ack_stopack;
        end
      rec_edof_sample : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b0&&erroractivC==1'b1)
            next_stateC <= erroractiv_firstdom;
          else
            if (inbitC==1'b0&&errorpassivC==1'b1)
              next_stateC <= errorpassiv_firstrec;
            else
              next_stateC <= rec_edof_check;
        end
      rec_edof_check : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (countC!=7&&smplpointC==1'b1)
            next_stateC <= rec_edof_sample;
          else
            if (countC==7&&inbitC==1'b1)
              next_stateC <= rec_edof_endrec;
            else
              next_stateC <= rec_edof_check;
        end
      rec_edof_endrec : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b1;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= rec_edof_lastbit;
          else
            next_stateC <= rec_edof_endrec;
        end
      rec_edof_lastbit : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b1)
            next_stateC <= rec_edof_inter;
          else
            if (inbitC==1'b0)
              next_stateC <= over_firstdom;
            else
              next_stateC <= rec_edof_lastbit;
        end
      rec_edof_inter : 
        begin
          rext_setC <= 2'b00;
          rrtr_setC <= 2'b00;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b11;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= rec_edof_inter;
        end
      over_firstdom : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= over_senddomb;
          else
            next_stateC <= over_firstdom;
        end
      over_senddomb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= over_check1;
          else
            next_stateC <= over_senddomb;
        end
      over_check1 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=6)
            next_stateC <= over_senddomb;
          else
            if (biterrorC==1'b0&&countC==6)
              next_stateC <= over_preprecb;
            else
              if (biterrorC==1'b1&&erroractivC==1'b1)
                next_stateC <= erroractiv_firstdom;
              else
                if (biterrorC==1'b1&&errorpassivC==1'b1)
                  next_stateC <= errorpassiv_firstrec;
                else
                  if (biterrorC==1'b1&&busofC==1'b1)
                    next_stateC <= busoff_first;
                  else
                    next_stateC <= over_check1;
        end
      over_preprecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= over_wtonrecb;
          else
            next_stateC <= over_preprecb;
        end
      over_wtonrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= over_check2;
          else
            next_stateC <= over_wtonrecb;
        end
      over_inctracounter : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= over_check2;
          else
            next_stateC <= over_inctracounter;
        end
      over_increccounter : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= over_check2;
          else
            next_stateC <= over_increccounter;
        end
      over_check2 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b1&&countC!=7)
            next_stateC <= over_wtonrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&receiverC==1'b1)
              next_stateC <= over_increccounter;
            else
              if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&transmitterC==1'b1)
                next_stateC <= over_inctracounter;
              else
                if (biterrorC==1'b0)
                  next_stateC <= over_prepsend;
                else
                  next_stateC <= over_check2;
        end
      over_prepsend : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= over_sendrecb;
          else
            next_stateC <= over_prepsend;
        end
      over_sendrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= over_check3;
          else
            next_stateC <= over_sendrecb;
        end
      over_check3 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=7)
            next_stateC <= over_sendrecb;
          else
            if (biterrorC==1'b0&&countC==7)
              next_stateC <= over_waitoclk;
            else
              if (biterrorC==1'b1&&countC==7)
                next_stateC <= over_firstdom;
              else
                if (biterrorC==1'b1&&erroractivC==1'b1&&countC!=7)
                  next_stateC <= erroractiv_firstdom;
                else
                  if (biterrorC==1'b1&&errorpassivC==1'b1&&countC!=7)
                    next_stateC <= errorpassiv_firstrec;
                  else
                    if (biterrorC==1'b1&&busofC==1'b1&&countC!=7)
                      next_stateC <= busoff_first;
                    else
                      next_stateC <= over_check3;
        end
      over_waitoclk : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= over_waitoclk;
        end
      erroractiv_firstdom : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b00;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b00;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&onarbitC==1'b1)
            next_stateC <= erroractiv_senddomb;
          else
            if (onarbitC==1'b0&&transmitterC==1'b0&&receiverC==1'b1&&errorC==1'b0)
              next_stateC <= erroractiv_inceinsrec;
            else
              if (onarbitC==1'b0&&transmitterC==1'b0&&receiverC==1'b1&&errorC==1'b1)
                next_stateC <= erroractiv_incachtrec;
              else
                if (onarbitC==1'b0&&transmitterC==1'b1)
                  next_stateC <= erroractiv_incachttra;
                else
                  next_stateC <= erroractiv_firstdom;
        end
      erroractiv_inceinsrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b1;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= erroractiv_senddomb;
          else
            next_stateC <= erroractiv_inceinsrec;
        end
      erroractiv_incachtrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= erroractiv_senddomb;
          else
            next_stateC <= erroractiv_incachtrec;
        end
      erroractiv_incachttra : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= erroractiv_senddomb;
          else
            next_stateC <= erroractiv_incachttra;
        end
      erroractiv_senddomb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check1;
          else
            next_stateC <= erroractiv_senddomb;
        end
      erroractiv_check1 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b1;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=6)
            next_stateC <= erroractiv_senddomb;
          else
            if (biterrorC==1'b0&&countC==6)
              next_stateC <= erroractiv_preprecb;
            else
              if (biterrorC==1'b1&&erroractivC==1'b1)
                next_stateC <= erroractiv_firstdom;
              else
                if (biterrorC==1'b1&&errorpassivC==1'b1)
                  next_stateC <= errorpassiv_firstrec;
                else
                  if (biterrorC==1'b1&&busofC==1'b1)
                    next_stateC <= busoff_first;
                  else
                    next_stateC <= erroractiv_check1;
        end
      erroractiv_preprecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= erroractiv_wtonrecb;
          else
            next_stateC <= erroractiv_preprecb;
        end
      erroractiv_wtonrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b00;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check2;
          else
            next_stateC <= erroractiv_wtonrecb;
        end
      erroractiv_dombitdct : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check2;
          else
            next_stateC <= erroractiv_dombitdct;
        end
      erroractiv_egtdombr : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check2;
          else
            next_stateC <= erroractiv_egtdombr;
        end
      erroractiv_egtdombt : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check2;
          else
            next_stateC <= erroractiv_egtdombt;
        end
      erroractiv_check2 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b00;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b1&&countC!=7&&(countC!=1||receiverC==1'b0||firstC==1'b0))
            next_stateC <= erroractiv_wtonrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b1&&countC==1&&receiverC==1'b1&&firstC==1'b1)
              next_stateC <= erroractiv_dombitdct;
            else
              if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&transmitterC==1'b1&&receiverC==1'b0)
                next_stateC <= erroractiv_egtdombt;
              else
                if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&transmitterC==1'b0&&receiverC==1'b1)
                  next_stateC <= erroractiv_egtdombr;
                else
                  if (biterrorC==1'b0)
                    next_stateC <= erroractiv_prepsend;
                  else
                    next_stateC <= erroractiv_check2;
        end
      erroractiv_prepsend : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= erroractiv_sendrecb;
          else
            next_stateC <= erroractiv_prepsend;
        end
      erroractiv_sendrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= erroractiv_check3;
          else
            next_stateC <= erroractiv_sendrecb;
        end
      erroractiv_check3 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=7)
            next_stateC <= erroractiv_sendrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b0&&countC==7)
              next_stateC <= erroractiv_waitoclk;
            else
              if (biterrorC==1'b1&&erroractivC==1'b1)
                next_stateC <= erroractiv_firstdom;
              else
                if (biterrorC==1'b1&&errorpassivC==1'b1)
                  next_stateC <= errorpassiv_firstrec;
                else
                  if (biterrorC==1'b1&&busofC==1'b1)
                    next_stateC <= busoff_first;
                  else
                    next_stateC <= erroractiv_check3;
        end
      erroractiv_waitoclk : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= erroractiv_waitoclk;
        end
      errorpassiv_firstrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b00;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b00;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&transmitterC==1'b1&&(onarbitC==1'b1||ackerrorC==1'b1))
            next_stateC <= errorpassiv_incsrecb;
          else
            if (onarbitC==1'b0&&transmitterC==1'b0&&receiverC==1'b1&&errorC==1'b0)
              next_stateC <= errorpassiv_inceinsrec;
            else
              if (onarbitC==1'b0&&transmitterC==1'b0&&receiverC==1'b1&&errorC==1'b1)
                next_stateC <= errorpassiv_incachtrec;
              else
                if (onarbitC==1'b0&&transmitterC==1'b1&&ackerrorC==1'b0)
                  next_stateC <= errorpassiv_incachttra;
                else
                  next_stateC <= errorpassiv_firstrec;
        end
      errorpassiv_inceinsrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b1;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_inceinsrec;
        end
      errorpassiv_incachtrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_incachtrec;
        end
      errorpassiv_incachttra : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_incachttra;
        end
      errorpassiv_incsrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b00;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&countC!=0)
            next_stateC <= errorpassiv_check1;
          else
            if (smplpointC==1'b1&&countC==0)
              next_stateC <= errorpassiv_fillpuffer;
            else
              next_stateC <= errorpassiv_incsrecb;
        end
      errorpassiv_fillpuffer : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b0&&transmitterC==1'b1&&ackerrorC==1'b1)
            next_stateC <= errorpassiv_pufferdomi;
          else
            if (inbitC==1'b0&&(transmitterC==1'b0||ackerrorC==1'b0))
              next_stateC <= errorpassiv_pufferdom;
            else
              next_stateC <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferrec : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b11;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_pufferrec;
        end
      errorpassiv_pufferdom : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_pufferdom;
        end
      errorpassiv_pufferdomi : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_incsrecb;
          else
            next_stateC <= errorpassiv_pufferdomi;
        end
      errorpassiv_zersrecbo : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b11;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbz : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= errorpassiv_newcount;
        end
      errorpassiv_zersrecbi : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= errorpassiv_newcount;
        end
      errorpassiv_newcount : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b00;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          next_stateC <= errorpassiv_prepcount;
        end
      errorpassiv_prepcount : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b00;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check1;
          else
            next_stateC <= errorpassiv_prepcount;
        end
      errorpassiv_check1 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b00;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b00;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==pufferC&&biterrorC==1'b1&&transmitterC==1'b1&&ackerrorC==1'b1)
            next_stateC <= errorpassiv_zersrecbi;
          else
            if (sendpointC==1'b1&&biterrorC==pufferC&&biterrorC==1'b1&&(ackerrorC==1'b0||transmitterC==1'b0))
              next_stateC <= errorpassiv_zersrecbz;
            else
              if (sendpointC==1'b1&&biterrorC==pufferC&&biterrorC==1'b0)
                next_stateC <= errorpassiv_zersrecbo;
              else
                if (sendpointC==1'b1&&biterrorC!=pufferC&&countC!=6)
                  next_stateC <= errorpassiv_incsrecb;
                else
                  if (biterrorC!=pufferC&&countC==6)
                    next_stateC <= errorpassiv_preprecb;
                  else
                    next_stateC <= errorpassiv_check1;
        end
      errorpassiv_preprecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b11;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_wtonrecb;
          else
            next_stateC <= errorpassiv_preprecb;
        end
      errorpassiv_wtonrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b00;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check2;
          else
            next_stateC <= errorpassiv_wtonrecb;
        end
      errorpassiv_dombitdct : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check2;
          else
            next_stateC <= errorpassiv_dombitdct;
        end
      errorpassiv_egtdombr : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b1;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check2;
          else
            next_stateC <= errorpassiv_egtdombr;
        end
      errorpassiv_egtdombt : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b1;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check2;
          else
            next_stateC <= errorpassiv_egtdombt;
        end
      errorpassiv_check2 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b00;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b1&&countC!=7&&(countC!=1||receiverC==1'b0||firstC==1'b0))
            next_stateC <= errorpassiv_wtonrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b1&&countC==1&&receiverC==1'b1&&firstC==1'b1)
              next_stateC <= errorpassiv_dombitdct;
            else
              if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&transmitterC==1'b1&&receiverC==1'b0)
                next_stateC <= errorpassiv_egtdombt;
              else
                if (sendpointC==1'b1&&biterrorC==1'b1&&countC==7&&transmitterC==1'b0&&receiverC==1'b1)
                  next_stateC <= errorpassiv_egtdombr;
                else
                  if (biterrorC==1'b0)
                    next_stateC <= errorpassiv_prepsend;
                  else
                    next_stateC <= errorpassiv_check2;
        end
      errorpassiv_prepsend : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1)
            next_stateC <= errorpassiv_sendrecb;
          else
            next_stateC <= errorpassiv_prepsend;
        end
      errorpassiv_sendrecb : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b1;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b1;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= errorpassiv_check3;
          else
            next_stateC <= errorpassiv_sendrecb;
        end
      errorpassiv_check3 : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b1;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (sendpointC==1'b1&&biterrorC==1'b0&&countC!=7)
            next_stateC <= errorpassiv_sendrecb;
          else
            if (sendpointC==1'b1&&biterrorC==1'b0&&countC==7)
              next_stateC <= errorpassiv_waitoclk;
            else
              if (biterrorC==1'b1&&errorpassivC==1'b1)
                next_stateC <= errorpassiv_firstrec;
              else
                if (biterrorC==1'b1&&busofC==1'b1)
                  next_stateC <= busoff_first;
                else
                  next_stateC <= errorpassiv_check3;
        end
      errorpassiv_waitoclk : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b1;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b0;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b1;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b00;
          receiver_setC <= 2'b00;
          error_setC <= 2'b11;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= inter_sample;
          else
            next_stateC <= errorpassiv_waitoclk;
        end
      busoff_first : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= busoff_sample;
          else
            next_stateC <= busoff_first;
        end
      busoff_sample : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b1;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (inbitC==1'b1&&countC!=10)
            next_stateC <= busoff_increm;
          else
            if (inbitC==1'b1&&countC==10)
              next_stateC <= busoff_deccnt;
            else
              next_stateC <= busoff_setzer;
        end
      busoff_increm : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b1;
          rescountC <= 1'b1;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= busoff_sample;
          else
            next_stateC <= busoff_increm;
        end
      busoff_setzer : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b0;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b1;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1)
            next_stateC <= busoff_sample;
          else
            next_stateC <= busoff_setzer;
        end
      busoff_deccnt : 
        begin
          rext_setC <= 2'b10;
          rrtr_setC <= 2'b10;
          actvtcrcC <= 1'b0;
          actvrcrcC <= 1'b0;
          actvtstfC <= 1'b0;
          actvrstfC <= 1'b0;
          actvtsftC <= 1'b0;
          actvrsftC <= 1'b0;
          actvtdctC <= 1'b0;
          actvrdctC <= 1'b1;
          actvtbedC <= 1'b0;
          setbdomC <= 1'b0;
          setbrecC <= 1'b0;
          lcrcC <= 1'b0;
          tshiftC <= 1'b0;
          inconerecC <= 1'b0;
          incegtrecC <= 1'b0;
          incegttraC <= 1'b0;
          lmsgC <= 1'b0;
          decrecC <= 1'b0;
          dectraC <= 1'b0;
          elevrecbC <= 1'b1;
          hardsyncC <= 1'b0;
          resetdstC <= 1'b1;
          resetstfC <= 1'b0;
          inccountC <= 1'b0;
          rescountC <= 1'b0;
          setrmlenoC <= 0;
          actvrmlnC <= 1'b0;
          resrmlenC <= 1'b1;
          ackerror_setC <= 2'b10;
          transmitter_setC <= 2'b10;
          receiver_setC <= 2'b10;
          error_setC <= 2'b10;
          first_setC <= 2'b10;
          activatefastC <= 1'b0;
          puffer_setC <= 2'b10;
          onarbit_setC <= 2'b10;
          en_zerointcrcC <= 1'b1;
          crc_shft_outC <= 1'b0;
          if (smplpointC==1'b1&&busofC==1'b1)
            next_stateC <= busoff_sample;
          else
            if (smplpointC==1'b1&&busofC==1'b0)
              next_stateC <= inter_sample;
            else
              next_stateC <= busoff_deccnt;
        end
      default : 
        begin
        end
    endcase
  end

majorityVoter #(.WIDTH(8)) current_stateVoterA (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_stateVotedA),
    .tmrErr(current_stateTmrErrorA)
    );

majorityVoter #(.WIDTH(8)) current_stateVoterB (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_stateVotedB),
    .tmrErr(current_stateTmrErrorB)
    );

majorityVoter #(.WIDTH(8)) current_stateVoterC (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_stateVotedC),
    .tmrErr(current_stateTmrErrorC)
    );
endmodule

