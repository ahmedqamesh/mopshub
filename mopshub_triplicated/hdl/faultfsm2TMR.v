/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/faultfsm2TMR.v                                                                *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 06/10/2022 13:52:48                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: faultfsm2.v                                                                            *
 *           Git SHA           : c110441b08b692cc54ebd4a3b84a2599430e8f93                           *
 *           Modification time : 2022-08-30 13:51:24                                                *
 *           File Size         : 4593                                                               *
 *           MD5 hash          : 9cbf22118813aaaa34a828de526ff4e1                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module faultfsm2TMR(
  input wire  clock ,
  input wire  reset ,
  input wire  rec_lt96 ,
  input wire  rec_ge96 ,
  input wire  rec_ge128 ,
  input wire  tec_lt96 ,
  input wire  tec_ge96 ,
  input wire  tec_ge128 ,
  input wire  tec_ge256 ,
  input wire  erb_eq128 ,
  output reg  resetcount ,
  output reg  erroractive ,
  output reg  errorpassive ,
  output reg  busoff ,
  output reg  warnsig ,
  output wire  irqsig 
);
localparam [2:0] erroractiv =3'b000;
localparam [2:0] errorpassiv =3'b001;
localparam [2:0] busof =3'b010;
localparam [2:0] resetstate =3'b011;
localparam [2:0] warning =3'b100;
wire resetC;
wire resetB;
wire resetA;
wire clockC;
wire clockB;
wire clockA;
wire [2:0] NEXT_STATEC;
wire [2:0] NEXT_STATEB;
wire [2:0] NEXT_STATEA;
wor CURRENT_STATETmrError;
wire [2:0] CURRENT_STATE;
reg  [2:0] CURRENT_STATEA ;
reg  [2:0] CURRENT_STATEB ;
reg  [2:0] CURRENT_STATEC ;
reg  [2:0] NEXT_STATE ;
wire [2:0] CURRENT_STATEV =  CURRENT_STATE;

always @( posedge clockA )
  begin
    if (resetA==1'b0)
      CURRENT_STATEA <= erroractiv;
    else
      CURRENT_STATEA <= NEXT_STATEA;
  end

always @( posedge clockB )
  begin
    if (resetB==1'b0)
      CURRENT_STATEB <= erroractiv;
    else
      CURRENT_STATEB <= NEXT_STATEB;
  end

always @( posedge clockC )
  begin
    if (resetC==1'b0)
      CURRENT_STATEC <= erroractiv;
    else
      CURRENT_STATEC <= NEXT_STATEC;
  end
assign irqsig =  (CURRENT_STATEV==NEXT_STATE) ? 1'b0 : 1'b1;

always @( CURRENT_STATEV or rec_lt96 or rec_ge96 or rec_ge128 or tec_lt96 or tec_ge96 or tec_ge128 or tec_ge256 or erb_eq128 )
  begin
    case (CURRENT_STATEV)
      erroractiv : 
        begin
          erroractive =  1'b1;
          errorpassive =  1'b0;
          busoff =  1'b0;
          warnsig =  1'b0;
          resetcount =  1'b1;
          if (rec_ge96==1'b1||tec_ge96==1'b1)
            NEXT_STATE =  warning;
          else
            NEXT_STATE =  erroractiv;
        end
      warning : 
        begin
          erroractive =  1'b1;
          errorpassive =  1'b0;
          busoff =  1'b0;
          warnsig =  1'b1;
          resetcount =  1'b1;
          if (rec_ge128==1'b1||tec_ge128==1'b1)
            NEXT_STATE =  errorpassiv;
          else
            if (rec_lt96==1'b1&&tec_lt96==1'b1)
              NEXT_STATE =  erroractiv;
            else
              NEXT_STATE =  warning;
        end
      errorpassiv : 
        begin
          erroractive =  1'b0;
          errorpassive =  1'b1;
          busoff =  1'b0;
          warnsig =  1'b0;
          resetcount =  1'b1;
          if (tec_ge256==1'b1)
            NEXT_STATE =  busof;
          else
            if (tec_ge128==1'b0&&rec_ge128==1'b0)
              NEXT_STATE =  erroractiv;
            else
              NEXT_STATE =  errorpassiv;
        end
      busof : 
        begin
          erroractive =  1'b0;
          errorpassive =  1'b0;
          busoff =  1'b1;
          warnsig =  1'b0;
          resetcount =  1'b1;
          if (erb_eq128==1'b1)
            NEXT_STATE =  resetstate;
          else
            NEXT_STATE =  busof;
        end
      resetstate : 
        begin
          erroractive =  1'b1;
          errorpassive =  1'b0;
          busoff =  1'b0;
          warnsig =  1'b0;
          resetcount =  1'b0;
          NEXT_STATE =  erroractiv;
        end
      default : 
        begin
          erroractive =  1'b0;
          errorpassive =  1'b0;
          busoff =  1'b0;
          warnsig =  1'b0;
          resetcount =  1'b0;
          NEXT_STATE =  CURRENT_STATEV;
        end
    endcase
  end

majorityVoter #(.WIDTH(3)) CURRENT_STATEVoter (
    .inA(CURRENT_STATEA),
    .inB(CURRENT_STATEB),
    .inC(CURRENT_STATEC),
    .out(CURRENT_STATE),
    .tmrErr(CURRENT_STATETmrError)
    );

fanout #(.WIDTH(3)) NEXT_STATEFanout (
    .in(NEXT_STATE),
    .outA(NEXT_STATEA),
    .outB(NEXT_STATEB),
    .outC(NEXT_STATEC)
    );

fanout clockFanout (
    .in(clock),
    .outA(clockA),
    .outB(clockB),
    .outC(clockC)
    );

fanout resetFanout (
    .in(reset),
    .outA(resetA),
    .outB(resetB),
    .outC(resetC)
    );
endmodule

