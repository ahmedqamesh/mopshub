/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/osc_trim_sm_fsmTMR.v                                                          *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:55                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: osc_trim_sm_fsm.v                                                                      *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-28 21:55:51                                                *
 *           File Size         : 14992                                                              *
 *           MD5 hash          : 0a4ca912eb38394d43e99f0f023d3310                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module osc_trim_SMTMR(
  input wire  abortA ,
  input wire  abortB ,
  input wire  abortC ,
  input wire  clkA ,
  input wire  clkB ,
  input wire  clkC ,
  input wire  end_cnt_dbgA ,
  input wire  end_cnt_dbgB ,
  input wire  end_cnt_dbgC ,
  input wire  end_osc_cntA ,
  input wire  end_osc_cntB ,
  input wire  end_osc_cntC ,
  input wire  end_read_canA ,
  input wire  end_read_canB ,
  input wire  end_read_canC ,
  input wire  end_write_canA ,
  input wire  end_write_canB ,
  input wire  end_write_canC ,
  input wire  end_write_elinkA ,
  input wire  end_write_elinkB ,
  input wire  end_write_elinkC ,
  input wire  irq_can_recA ,
  input wire  irq_can_recB ,
  input wire  irq_can_recC ,
  input wire  irq_can_traA ,
  input wire  irq_can_traB ,
  input wire  irq_can_traC ,
  input wire  irq_trim_bus_oscA ,
  input wire  irq_trim_bus_oscB ,
  input wire  irq_trim_bus_oscC ,
  input wire  irq_trim_oscA ,
  input wire  irq_trim_oscB ,
  input wire  irq_trim_oscC ,
  input wire  osc_auto_trim_mopshubA ,
  input wire  osc_auto_trim_mopshubB ,
  input wire  osc_auto_trim_mopshubC ,
  input wire  power_bus_en_doneA ,
  input wire  power_bus_en_doneB ,
  input wire  power_bus_en_doneC ,
  input wire  reset_irq_can_doneA ,
  input wire  reset_irq_can_doneB ,
  input wire  reset_irq_can_doneC ,
  input wire  rstA ,
  input wire  rstB ,
  input wire  rstC ,
  input wire  timeoutrstA ,
  input wire  timeoutrstB ,
  input wire  timeoutrstC ,
  output reg  done_trim_osc_allA ,
  output reg  done_trim_osc_allB ,
  output reg  done_trim_osc_allC ,
  output reg  end_can_procA ,
  output reg  end_can_procB ,
  output reg  end_can_procC ,
  output reg  end_trim_busA ,
  output reg  end_trim_busB ,
  output reg  end_trim_busC ,
  output reg  entimeout_trimA ,
  output reg  entimeout_trimB ,
  output reg  entimeout_trimC ,
  output reg  ext_counter_genA ,
  output reg  ext_counter_genB ,
  output reg  ext_counter_genC ,
  output reg  irq_can_ackA ,
  output reg  irq_can_ackB ,
  output reg  irq_can_ackC ,
  output reg  osc_trim_modeA ,
  output reg  osc_trim_modeB ,
  output reg  osc_trim_modeC ,
  output reg  power_bus_enA ,
  output reg  power_bus_enB ,
  output reg  power_bus_enC ,
  output reg  reset_irq_canA ,
  output reg  reset_irq_canB ,
  output reg  reset_irq_canC ,
  output reg  reset_irq_osc_canA ,
  output reg  reset_irq_osc_canB ,
  output reg  reset_irq_osc_canC ,
  output reg  reset_irq_rec_canA ,
  output reg  reset_irq_rec_canB ,
  output reg  reset_irq_rec_canC ,
  output reg  rst_busA ,
  output reg  rst_busB ,
  output reg  rst_busC ,
  output reg  rst_osc_cntA ,
  output reg  rst_osc_cntB ,
  output reg  rst_osc_cntC ,
  output reg  send_mes_canA ,
  output reg  send_mes_canB ,
  output reg  send_mes_canC ,
  output reg  skip_osc_trimA ,
  output reg  skip_osc_trimB ,
  output reg  skip_osc_trimC ,
  output reg  start_osc_cntA ,
  output reg  start_osc_cntB ,
  output reg  start_osc_cntC ,
  output reg  start_read_canA ,
  output reg  start_read_canB ,
  output reg  start_read_canC ,
  output reg  start_trim_ackA ,
  output reg  start_trim_ackB ,
  output reg  start_trim_ackC ,
  output reg  start_trim_oscA ,
  output reg  start_trim_oscB ,
  output reg  start_trim_oscC ,
  output reg  start_write_elinkA ,
  output reg  start_write_elinkB ,
  output reg  start_write_elinkC ,
  output reg [5:0] statedebA ,
  output reg [5:0] statedebB ,
  output reg [5:0] statedebC 
);
parameter waittoact =6'd0;
parameter reset =6'd1;
parameter ST_Skip_Bus =6'd2;
parameter rst_irq_can =6'd3;
parameter Wait_W_SPI2 =6'd4;
parameter ST_Start_Cnt =6'd5;
parameter Break_Loop =6'd6;
parameter finish_proc =6'd7;
parameter ST_CountRst =6'd8;
parameter Read_Resp =6'd9;
parameter pass_to_elink =6'd10;
parameter Wait_Resp =6'd11;
parameter rst_rec_irq_can =6'd12;
parameter finish_proc1 =6'd13;
parameter rst_tra_irq_can =6'd14;
parameter Trim_ack =6'd15;
parameter Start_write_trim =6'd16;
parameter pass_mes_to_can =6'd17;
parameter send_ack1 =6'd18;
parameter Check_Trim =6'd19;
parameter ST_Done_Trim =6'd20;
parameter ST_Skip_Bus1 =6'd21;
parameter rst_irq_can1 =6'd22;
parameter RST_MOPS_dbg1 =6'd23;
parameter ST_Start_Cnt1 =6'd24;
parameter Count_gen_dbg1 =6'd25;
parameter Break_Loop1 =6'd26;
parameter finish_proc3 =6'd27;
parameter ST_CountRst1 =6'd28;
parameter Check_Trim1 =6'd29;
parameter ST_Done_Trim1 =6'd30;
parameter Read_Resp1 =6'd31;
parameter pass_to_elink1 =6'd32;
parameter Wait_Resp1 =6'd33;
parameter rst_rec_irq_can1 =6'd34;
parameter finish_proc2 =6'd35;
parameter rst_tra_irq_can1 =6'd36;
parameter Trim_ack1 =6'd37;
parameter Start_write_trim1 =6'd38;
parameter pass_mes_to_can1 =6'd39;
parameter send_ack2 =6'd40;
parameter ST_En_power0 =6'd41;
parameter ST_En_power1 =6'd42;
parameter Wait_W_SPI =6'd43;
parameter Wait_W_SPI1 =6'd44;
parameter ST_MOPS_dbg2 =6'd45;
parameter Count_gen_dbg =6'd46;
reg  [5:0] current_stateA ;
reg  [5:0] next_stateA ;
reg  [5:0] current_stateB ;
reg  [5:0] next_stateB ;
reg  [5:0] current_stateC ;
reg  [5:0] next_stateC ;

always @( current_stateA or end_cnt_dbgA or end_osc_cntA or end_read_canA or end_write_canA or end_write_elinkA or irq_can_recA or irq_can_traA or irq_trim_bus_oscA or irq_trim_oscA or osc_auto_trim_mopshubA or power_bus_en_doneA or reset_irq_can_doneA or rstA )
  begin : next_state_block_procA
    case (current_stateA)
      waittoact : 
        begin
          if (irq_trim_oscA==1)
            next_stateA =  Check_Trim;
          else
            if (irq_trim_bus_oscA==1)
              next_stateA =  Check_Trim1;
            else
              next_stateA =  waittoact;
        end
      reset : 
        begin
          if (rstA==1)
            next_stateA =  waittoact;
          else
            next_stateA =  reset;
        end
      ST_Skip_Bus : 
        begin
          next_stateA =  rst_irq_can;
        end
      rst_irq_can : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  Break_Loop;
          else
            next_stateA =  rst_irq_can;
        end
      Wait_W_SPI2 : 
        begin
          if (power_bus_en_doneA==1)
            next_stateA =  ST_MOPS_dbg2;
          else
            next_stateA =  Wait_W_SPI2;
        end
      ST_Start_Cnt : 
        begin
          if (osc_auto_trim_mopshubA==1)
            next_stateA =  ST_MOPS_dbg2;
          else
            next_stateA =  Wait_W_SPI1;
        end
      Break_Loop : 
        begin
          if (end_osc_cntA==1|end_cnt_dbgA==1)
            next_stateA =  ST_CountRst;
          else
            next_stateA =  Count_gen_dbg;
        end
      finish_proc : 
        begin
          next_stateA =  Break_Loop;
        end
      ST_CountRst : 
        begin
          next_stateA =  ST_Done_Trim;
        end
      Read_Resp : 
        begin
          if (end_read_canA==1)
            next_stateA =  pass_to_elink;
          else
            next_stateA =  Read_Resp;
        end
      pass_to_elink : 
        begin
          if (end_write_elinkA==1)
            next_stateA =  rst_rec_irq_can;
          else
            next_stateA =  pass_to_elink;
        end
      Wait_Resp : 
        begin
          if (irq_can_recA==1)
            next_stateA =  Read_Resp;
          else
            next_stateA =  Wait_Resp;
        end
      rst_rec_irq_can : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  finish_proc1;
          else
            next_stateA =  rst_rec_irq_can;
        end
      finish_proc1 : 
        begin
          next_stateA =  finish_proc;
        end
      rst_tra_irq_can : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  Wait_Resp;
          else
            next_stateA =  rst_tra_irq_can;
        end
      Trim_ack : 
        begin
          next_stateA =  Start_write_trim;
        end
      Start_write_trim : 
        begin
          if (end_write_canA==1)
            next_stateA =  pass_mes_to_can;
          else
            next_stateA =  Start_write_trim;
        end
      pass_mes_to_can : 
        begin
          if (irq_can_traA==1)
            next_stateA =  send_ack1;
          else
            next_stateA =  pass_mes_to_can;
        end
      send_ack1 : 
        begin
          next_stateA =  rst_tra_irq_can;
        end
      Check_Trim : 
        begin
          if (osc_auto_trim_mopshubA==1)
            next_stateA =  ST_En_power1;
          else
            next_stateA =  ST_En_power0;
        end
      ST_Done_Trim : 
        begin
          next_stateA =  waittoact;
        end
      ST_Skip_Bus1 : 
        begin
          next_stateA =  rst_irq_can1;
        end
      rst_irq_can1 : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  Break_Loop1;
          else
            next_stateA =  rst_irq_can1;
        end
      RST_MOPS_dbg1 : 
        begin
          next_stateA =  Trim_ack1;
        end
      ST_Start_Cnt1 : 
        begin
          if (osc_auto_trim_mopshubA==1)
            next_stateA =  RST_MOPS_dbg1;
          else
            next_stateA =  Break_Loop1;
        end
      Count_gen_dbg1 : 
        begin
          next_stateA =  ST_Start_Cnt1;
        end
      Break_Loop1 : 
        begin
          if (end_osc_cntA==1|end_cnt_dbgA==1)
            next_stateA =  ST_CountRst1;
          else
            next_stateA =  Count_gen_dbg1;
        end
      finish_proc3 : 
        begin
          next_stateA =  Break_Loop1;
        end
      ST_CountRst1 : 
        begin
          next_stateA =  ST_Done_Trim1;
        end
      Check_Trim1 : 
        begin
          if (osc_auto_trim_mopshubA==1)
            next_stateA =  RST_MOPS_dbg1;
          else
            next_stateA =  Break_Loop1;
        end
      ST_Done_Trim1 : 
        begin
          next_stateA =  waittoact;
        end
      Read_Resp1 : 
        begin
          if (end_read_canA==1)
            next_stateA =  pass_to_elink1;
          else
            next_stateA =  Read_Resp1;
        end
      pass_to_elink1 : 
        begin
          if (end_write_elinkA==1)
            next_stateA =  rst_rec_irq_can1;
          else
            next_stateA =  pass_to_elink1;
        end
      Wait_Resp1 : 
        begin
          if (irq_can_recA==1)
            next_stateA =  Read_Resp1;
          else
            next_stateA =  Wait_Resp1;
        end
      rst_rec_irq_can1 : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  finish_proc2;
          else
            next_stateA =  rst_rec_irq_can1;
        end
      finish_proc2 : 
        begin
          next_stateA =  finish_proc3;
        end
      rst_tra_irq_can1 : 
        begin
          if (reset_irq_can_doneA==1)
            next_stateA =  Wait_Resp1;
          else
            next_stateA =  rst_tra_irq_can1;
        end
      Trim_ack1 : 
        begin
          next_stateA =  Start_write_trim1;
        end
      Start_write_trim1 : 
        begin
          if (end_write_canA==1)
            next_stateA =  pass_mes_to_can1;
          else
            next_stateA =  Start_write_trim1;
        end
      pass_mes_to_can1 : 
        begin
          if (irq_can_traA==1)
            next_stateA =  send_ack2;
          else
            next_stateA =  pass_mes_to_can1;
        end
      send_ack2 : 
        begin
          next_stateA =  rst_tra_irq_can1;
        end
      ST_En_power0 : 
        begin
          next_stateA =  Wait_W_SPI;
        end
      ST_En_power1 : 
        begin
          next_stateA =  Wait_W_SPI2;
        end
      Wait_W_SPI : 
        begin
          if (power_bus_en_doneA==1)
            next_stateA =  Break_Loop;
          else
            next_stateA =  Wait_W_SPI;
        end
      Wait_W_SPI1 : 
        begin
          if (power_bus_en_doneA==1)
            next_stateA =  Break_Loop;
          else
            next_stateA =  Wait_W_SPI1;
        end
      ST_MOPS_dbg2 : 
        begin
          next_stateA =  Trim_ack;
        end
      Count_gen_dbg : 
        begin
          next_stateA =  ST_Start_Cnt;
        end
      default : next_stateA =  reset;
    endcase
  end

always @( current_stateB or end_cnt_dbgB or end_osc_cntB or end_read_canB or end_write_canB or end_write_elinkB or irq_can_recB or irq_can_traB or irq_trim_bus_oscB or irq_trim_oscB or osc_auto_trim_mopshubB or power_bus_en_doneB or reset_irq_can_doneB or rstB )
  begin : next_state_block_procB
    case (current_stateB)
      waittoact : 
        begin
          if (irq_trim_oscB==1)
            next_stateB =  Check_Trim;
          else
            if (irq_trim_bus_oscB==1)
              next_stateB =  Check_Trim1;
            else
              next_stateB =  waittoact;
        end
      reset : 
        begin
          if (rstB==1)
            next_stateB =  waittoact;
          else
            next_stateB =  reset;
        end
      ST_Skip_Bus : 
        begin
          next_stateB =  rst_irq_can;
        end
      rst_irq_can : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  Break_Loop;
          else
            next_stateB =  rst_irq_can;
        end
      Wait_W_SPI2 : 
        begin
          if (power_bus_en_doneB==1)
            next_stateB =  ST_MOPS_dbg2;
          else
            next_stateB =  Wait_W_SPI2;
        end
      ST_Start_Cnt : 
        begin
          if (osc_auto_trim_mopshubB==1)
            next_stateB =  ST_MOPS_dbg2;
          else
            next_stateB =  Wait_W_SPI1;
        end
      Break_Loop : 
        begin
          if (end_osc_cntB==1|end_cnt_dbgB==1)
            next_stateB =  ST_CountRst;
          else
            next_stateB =  Count_gen_dbg;
        end
      finish_proc : 
        begin
          next_stateB =  Break_Loop;
        end
      ST_CountRst : 
        begin
          next_stateB =  ST_Done_Trim;
        end
      Read_Resp : 
        begin
          if (end_read_canB==1)
            next_stateB =  pass_to_elink;
          else
            next_stateB =  Read_Resp;
        end
      pass_to_elink : 
        begin
          if (end_write_elinkB==1)
            next_stateB =  rst_rec_irq_can;
          else
            next_stateB =  pass_to_elink;
        end
      Wait_Resp : 
        begin
          if (irq_can_recB==1)
            next_stateB =  Read_Resp;
          else
            next_stateB =  Wait_Resp;
        end
      rst_rec_irq_can : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  finish_proc1;
          else
            next_stateB =  rst_rec_irq_can;
        end
      finish_proc1 : 
        begin
          next_stateB =  finish_proc;
        end
      rst_tra_irq_can : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  Wait_Resp;
          else
            next_stateB =  rst_tra_irq_can;
        end
      Trim_ack : 
        begin
          next_stateB =  Start_write_trim;
        end
      Start_write_trim : 
        begin
          if (end_write_canB==1)
            next_stateB =  pass_mes_to_can;
          else
            next_stateB =  Start_write_trim;
        end
      pass_mes_to_can : 
        begin
          if (irq_can_traB==1)
            next_stateB =  send_ack1;
          else
            next_stateB =  pass_mes_to_can;
        end
      send_ack1 : 
        begin
          next_stateB =  rst_tra_irq_can;
        end
      Check_Trim : 
        begin
          if (osc_auto_trim_mopshubB==1)
            next_stateB =  ST_En_power1;
          else
            next_stateB =  ST_En_power0;
        end
      ST_Done_Trim : 
        begin
          next_stateB =  waittoact;
        end
      ST_Skip_Bus1 : 
        begin
          next_stateB =  rst_irq_can1;
        end
      rst_irq_can1 : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  Break_Loop1;
          else
            next_stateB =  rst_irq_can1;
        end
      RST_MOPS_dbg1 : 
        begin
          next_stateB =  Trim_ack1;
        end
      ST_Start_Cnt1 : 
        begin
          if (osc_auto_trim_mopshubB==1)
            next_stateB =  RST_MOPS_dbg1;
          else
            next_stateB =  Break_Loop1;
        end
      Count_gen_dbg1 : 
        begin
          next_stateB =  ST_Start_Cnt1;
        end
      Break_Loop1 : 
        begin
          if (end_osc_cntB==1|end_cnt_dbgB==1)
            next_stateB =  ST_CountRst1;
          else
            next_stateB =  Count_gen_dbg1;
        end
      finish_proc3 : 
        begin
          next_stateB =  Break_Loop1;
        end
      ST_CountRst1 : 
        begin
          next_stateB =  ST_Done_Trim1;
        end
      Check_Trim1 : 
        begin
          if (osc_auto_trim_mopshubB==1)
            next_stateB =  RST_MOPS_dbg1;
          else
            next_stateB =  Break_Loop1;
        end
      ST_Done_Trim1 : 
        begin
          next_stateB =  waittoact;
        end
      Read_Resp1 : 
        begin
          if (end_read_canB==1)
            next_stateB =  pass_to_elink1;
          else
            next_stateB =  Read_Resp1;
        end
      pass_to_elink1 : 
        begin
          if (end_write_elinkB==1)
            next_stateB =  rst_rec_irq_can1;
          else
            next_stateB =  pass_to_elink1;
        end
      Wait_Resp1 : 
        begin
          if (irq_can_recB==1)
            next_stateB =  Read_Resp1;
          else
            next_stateB =  Wait_Resp1;
        end
      rst_rec_irq_can1 : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  finish_proc2;
          else
            next_stateB =  rst_rec_irq_can1;
        end
      finish_proc2 : 
        begin
          next_stateB =  finish_proc3;
        end
      rst_tra_irq_can1 : 
        begin
          if (reset_irq_can_doneB==1)
            next_stateB =  Wait_Resp1;
          else
            next_stateB =  rst_tra_irq_can1;
        end
      Trim_ack1 : 
        begin
          next_stateB =  Start_write_trim1;
        end
      Start_write_trim1 : 
        begin
          if (end_write_canB==1)
            next_stateB =  pass_mes_to_can1;
          else
            next_stateB =  Start_write_trim1;
        end
      pass_mes_to_can1 : 
        begin
          if (irq_can_traB==1)
            next_stateB =  send_ack2;
          else
            next_stateB =  pass_mes_to_can1;
        end
      send_ack2 : 
        begin
          next_stateB =  rst_tra_irq_can1;
        end
      ST_En_power0 : 
        begin
          next_stateB =  Wait_W_SPI;
        end
      ST_En_power1 : 
        begin
          next_stateB =  Wait_W_SPI2;
        end
      Wait_W_SPI : 
        begin
          if (power_bus_en_doneB==1)
            next_stateB =  Break_Loop;
          else
            next_stateB =  Wait_W_SPI;
        end
      Wait_W_SPI1 : 
        begin
          if (power_bus_en_doneB==1)
            next_stateB =  Break_Loop;
          else
            next_stateB =  Wait_W_SPI1;
        end
      ST_MOPS_dbg2 : 
        begin
          next_stateB =  Trim_ack;
        end
      Count_gen_dbg : 
        begin
          next_stateB =  ST_Start_Cnt;
        end
      default : next_stateB =  reset;
    endcase
  end

always @( current_stateC or end_cnt_dbgC or end_osc_cntC or end_read_canC or end_write_canC or end_write_elinkC or irq_can_recC or irq_can_traC or irq_trim_bus_oscC or irq_trim_oscC or osc_auto_trim_mopshubC or power_bus_en_doneC or reset_irq_can_doneC or rstC )
  begin : next_state_block_procC
    case (current_stateC)
      waittoact : 
        begin
          if (irq_trim_oscC==1)
            next_stateC =  Check_Trim;
          else
            if (irq_trim_bus_oscC==1)
              next_stateC =  Check_Trim1;
            else
              next_stateC =  waittoact;
        end
      reset : 
        begin
          if (rstC==1)
            next_stateC =  waittoact;
          else
            next_stateC =  reset;
        end
      ST_Skip_Bus : 
        begin
          next_stateC =  rst_irq_can;
        end
      rst_irq_can : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  Break_Loop;
          else
            next_stateC =  rst_irq_can;
        end
      Wait_W_SPI2 : 
        begin
          if (power_bus_en_doneC==1)
            next_stateC =  ST_MOPS_dbg2;
          else
            next_stateC =  Wait_W_SPI2;
        end
      ST_Start_Cnt : 
        begin
          if (osc_auto_trim_mopshubC==1)
            next_stateC =  ST_MOPS_dbg2;
          else
            next_stateC =  Wait_W_SPI1;
        end
      Break_Loop : 
        begin
          if (end_osc_cntC==1|end_cnt_dbgC==1)
            next_stateC =  ST_CountRst;
          else
            next_stateC =  Count_gen_dbg;
        end
      finish_proc : 
        begin
          next_stateC =  Break_Loop;
        end
      ST_CountRst : 
        begin
          next_stateC =  ST_Done_Trim;
        end
      Read_Resp : 
        begin
          if (end_read_canC==1)
            next_stateC =  pass_to_elink;
          else
            next_stateC =  Read_Resp;
        end
      pass_to_elink : 
        begin
          if (end_write_elinkC==1)
            next_stateC =  rst_rec_irq_can;
          else
            next_stateC =  pass_to_elink;
        end
      Wait_Resp : 
        begin
          if (irq_can_recC==1)
            next_stateC =  Read_Resp;
          else
            next_stateC =  Wait_Resp;
        end
      rst_rec_irq_can : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  finish_proc1;
          else
            next_stateC =  rst_rec_irq_can;
        end
      finish_proc1 : 
        begin
          next_stateC =  finish_proc;
        end
      rst_tra_irq_can : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  Wait_Resp;
          else
            next_stateC =  rst_tra_irq_can;
        end
      Trim_ack : 
        begin
          next_stateC =  Start_write_trim;
        end
      Start_write_trim : 
        begin
          if (end_write_canC==1)
            next_stateC =  pass_mes_to_can;
          else
            next_stateC =  Start_write_trim;
        end
      pass_mes_to_can : 
        begin
          if (irq_can_traC==1)
            next_stateC =  send_ack1;
          else
            next_stateC =  pass_mes_to_can;
        end
      send_ack1 : 
        begin
          next_stateC =  rst_tra_irq_can;
        end
      Check_Trim : 
        begin
          if (osc_auto_trim_mopshubC==1)
            next_stateC =  ST_En_power1;
          else
            next_stateC =  ST_En_power0;
        end
      ST_Done_Trim : 
        begin
          next_stateC =  waittoact;
        end
      ST_Skip_Bus1 : 
        begin
          next_stateC =  rst_irq_can1;
        end
      rst_irq_can1 : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  Break_Loop1;
          else
            next_stateC =  rst_irq_can1;
        end
      RST_MOPS_dbg1 : 
        begin
          next_stateC =  Trim_ack1;
        end
      ST_Start_Cnt1 : 
        begin
          if (osc_auto_trim_mopshubC==1)
            next_stateC =  RST_MOPS_dbg1;
          else
            next_stateC =  Break_Loop1;
        end
      Count_gen_dbg1 : 
        begin
          next_stateC =  ST_Start_Cnt1;
        end
      Break_Loop1 : 
        begin
          if (end_osc_cntC==1|end_cnt_dbgC==1)
            next_stateC =  ST_CountRst1;
          else
            next_stateC =  Count_gen_dbg1;
        end
      finish_proc3 : 
        begin
          next_stateC =  Break_Loop1;
        end
      ST_CountRst1 : 
        begin
          next_stateC =  ST_Done_Trim1;
        end
      Check_Trim1 : 
        begin
          if (osc_auto_trim_mopshubC==1)
            next_stateC =  RST_MOPS_dbg1;
          else
            next_stateC =  Break_Loop1;
        end
      ST_Done_Trim1 : 
        begin
          next_stateC =  waittoact;
        end
      Read_Resp1 : 
        begin
          if (end_read_canC==1)
            next_stateC =  pass_to_elink1;
          else
            next_stateC =  Read_Resp1;
        end
      pass_to_elink1 : 
        begin
          if (end_write_elinkC==1)
            next_stateC =  rst_rec_irq_can1;
          else
            next_stateC =  pass_to_elink1;
        end
      Wait_Resp1 : 
        begin
          if (irq_can_recC==1)
            next_stateC =  Read_Resp1;
          else
            next_stateC =  Wait_Resp1;
        end
      rst_rec_irq_can1 : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  finish_proc2;
          else
            next_stateC =  rst_rec_irq_can1;
        end
      finish_proc2 : 
        begin
          next_stateC =  finish_proc3;
        end
      rst_tra_irq_can1 : 
        begin
          if (reset_irq_can_doneC==1)
            next_stateC =  Wait_Resp1;
          else
            next_stateC =  rst_tra_irq_can1;
        end
      Trim_ack1 : 
        begin
          next_stateC =  Start_write_trim1;
        end
      Start_write_trim1 : 
        begin
          if (end_write_canC==1)
            next_stateC =  pass_mes_to_can1;
          else
            next_stateC =  Start_write_trim1;
        end
      pass_mes_to_can1 : 
        begin
          if (irq_can_traC==1)
            next_stateC =  send_ack2;
          else
            next_stateC =  pass_mes_to_can1;
        end
      send_ack2 : 
        begin
          next_stateC =  rst_tra_irq_can1;
        end
      ST_En_power0 : 
        begin
          next_stateC =  Wait_W_SPI;
        end
      ST_En_power1 : 
        begin
          next_stateC =  Wait_W_SPI2;
        end
      Wait_W_SPI : 
        begin
          if (power_bus_en_doneC==1)
            next_stateC =  Break_Loop;
          else
            next_stateC =  Wait_W_SPI;
        end
      Wait_W_SPI1 : 
        begin
          if (power_bus_en_doneC==1)
            next_stateC =  Break_Loop;
          else
            next_stateC =  Wait_W_SPI1;
        end
      ST_MOPS_dbg2 : 
        begin
          next_stateC =  Trim_ack;
        end
      Count_gen_dbg : 
        begin
          next_stateC =  ST_Start_Cnt;
        end
      default : next_stateC =  reset;
    endcase
  end

always @( current_stateA )
  begin : output_block_procA
    done_trim_osc_allA =  0;
    end_can_procA =  0;
    end_trim_busA =  0;
    entimeout_trimA =  1;
    ext_counter_genA =  0;
    irq_can_ackA =  0;
    osc_trim_modeA =  1;
    power_bus_enA =  0;
    reset_irq_canA =  0;
    reset_irq_osc_canA =  0;
    reset_irq_rec_canA =  0;
    rst_busA =  0;
    rst_osc_cntA =  0;
    send_mes_canA =  0;
    skip_osc_trimA =  0;
    start_osc_cntA =  0;
    start_read_canA =  0;
    start_trim_ackA =  0;
    start_trim_oscA =  0;
    start_write_elinkA =  0;
    case (current_stateA)
      waittoact : 
        begin
          entimeout_trimA =  0;
          osc_trim_modeA =  0;
        end
      reset : 
        begin
          entimeout_trimA =  0;
          osc_trim_modeA =  0;
          power_bus_enA =  0;
        end
      ST_Skip_Bus : 
        begin
          skip_osc_trimA =  1;
        end
      rst_irq_can : 
        begin
          reset_irq_osc_canA =  1;
        end
      ST_Start_Cnt : 
        begin
          start_osc_cntA =  1;
          power_bus_enA =  1;
        end
      finish_proc : 
        begin
          end_trim_busA =  1;
        end
      ST_CountRst : 
        begin
          rst_osc_cntA =  1;
        end
      Read_Resp : 
        begin
          start_read_canA =  1;
        end
      pass_to_elink : 
        begin
          start_write_elinkA =  1;
        end
      rst_rec_irq_can : 
        begin
          reset_irq_canA =  1;
          reset_irq_rec_canA =  1;
        end
      finish_proc1 : 
        begin
          end_can_procA =  1;
        end
      rst_tra_irq_can : 
        begin
          reset_irq_canA =  1;
          reset_irq_osc_canA =  1;
        end
      Trim_ack : 
        begin
          start_trim_ackA =  1;
        end
      Start_write_trim : 
        begin
          start_trim_oscA =  1;
        end
      pass_mes_to_can : 
        begin
          send_mes_canA =  1;
        end
      send_ack1 : 
        begin
          irq_can_ackA =  1;
        end
      ST_Done_Trim : 
        begin
          done_trim_osc_allA =  1;
        end
      ST_Skip_Bus1 : 
        begin
          skip_osc_trimA =  1;
        end
      rst_irq_can1 : 
        begin
          reset_irq_osc_canA =  1;
        end
      RST_MOPS_dbg1 : 
        begin
          rst_busA =  1;
        end
      ST_Start_Cnt1 : 
        begin
          start_osc_cntA =  1;
        end
      Count_gen_dbg1 : 
        begin
          ext_counter_genA =  1;
        end
      finish_proc3 : 
        begin
          end_trim_busA =  1;
        end
      ST_CountRst1 : 
        begin
          rst_osc_cntA =  1;
        end
      Check_Trim1 : 
        begin
          power_bus_enA =  0;
        end
      ST_Done_Trim1 : 
        begin
          done_trim_osc_allA =  1;
        end
      Read_Resp1 : 
        begin
          start_read_canA =  1;
        end
      pass_to_elink1 : 
        begin
          start_write_elinkA =  1;
        end
      rst_rec_irq_can1 : 
        begin
          reset_irq_canA =  1;
          reset_irq_rec_canA =  1;
        end
      finish_proc2 : 
        begin
          end_can_procA =  1;
        end
      rst_tra_irq_can1 : 
        begin
          reset_irq_canA =  1;
          reset_irq_osc_canA =  1;
        end
      Trim_ack1 : 
        begin
          start_trim_ackA =  1;
        end
      Start_write_trim1 : 
        begin
          start_trim_oscA =  1;
        end
      pass_mes_to_can1 : 
        begin
          send_mes_canA =  1;
        end
      send_ack2 : 
        begin
          irq_can_ackA =  1;
        end
      ST_En_power0 : 
        begin
          power_bus_enA =  1;
        end
      ST_En_power1 : 
        begin
          power_bus_enA =  1;
        end
      ST_MOPS_dbg2 : 
        begin
          rst_busA =  1;
        end
      Count_gen_dbg : 
        begin
          ext_counter_genA =  1;
        end
    endcase
  end

always @( current_stateB )
  begin : output_block_procB
    done_trim_osc_allB =  0;
    end_can_procB =  0;
    end_trim_busB =  0;
    entimeout_trimB =  1;
    ext_counter_genB =  0;
    irq_can_ackB =  0;
    osc_trim_modeB =  1;
    power_bus_enB =  0;
    reset_irq_canB =  0;
    reset_irq_osc_canB =  0;
    reset_irq_rec_canB =  0;
    rst_busB =  0;
    rst_osc_cntB =  0;
    send_mes_canB =  0;
    skip_osc_trimB =  0;
    start_osc_cntB =  0;
    start_read_canB =  0;
    start_trim_ackB =  0;
    start_trim_oscB =  0;
    start_write_elinkB =  0;
    case (current_stateB)
      waittoact : 
        begin
          entimeout_trimB =  0;
          osc_trim_modeB =  0;
        end
      reset : 
        begin
          entimeout_trimB =  0;
          osc_trim_modeB =  0;
          power_bus_enB =  0;
        end
      ST_Skip_Bus : 
        begin
          skip_osc_trimB =  1;
        end
      rst_irq_can : 
        begin
          reset_irq_osc_canB =  1;
        end
      ST_Start_Cnt : 
        begin
          start_osc_cntB =  1;
          power_bus_enB =  1;
        end
      finish_proc : 
        begin
          end_trim_busB =  1;
        end
      ST_CountRst : 
        begin
          rst_osc_cntB =  1;
        end
      Read_Resp : 
        begin
          start_read_canB =  1;
        end
      pass_to_elink : 
        begin
          start_write_elinkB =  1;
        end
      rst_rec_irq_can : 
        begin
          reset_irq_canB =  1;
          reset_irq_rec_canB =  1;
        end
      finish_proc1 : 
        begin
          end_can_procB =  1;
        end
      rst_tra_irq_can : 
        begin
          reset_irq_canB =  1;
          reset_irq_osc_canB =  1;
        end
      Trim_ack : 
        begin
          start_trim_ackB =  1;
        end
      Start_write_trim : 
        begin
          start_trim_oscB =  1;
        end
      pass_mes_to_can : 
        begin
          send_mes_canB =  1;
        end
      send_ack1 : 
        begin
          irq_can_ackB =  1;
        end
      ST_Done_Trim : 
        begin
          done_trim_osc_allB =  1;
        end
      ST_Skip_Bus1 : 
        begin
          skip_osc_trimB =  1;
        end
      rst_irq_can1 : 
        begin
          reset_irq_osc_canB =  1;
        end
      RST_MOPS_dbg1 : 
        begin
          rst_busB =  1;
        end
      ST_Start_Cnt1 : 
        begin
          start_osc_cntB =  1;
        end
      Count_gen_dbg1 : 
        begin
          ext_counter_genB =  1;
        end
      finish_proc3 : 
        begin
          end_trim_busB =  1;
        end
      ST_CountRst1 : 
        begin
          rst_osc_cntB =  1;
        end
      Check_Trim1 : 
        begin
          power_bus_enB =  0;
        end
      ST_Done_Trim1 : 
        begin
          done_trim_osc_allB =  1;
        end
      Read_Resp1 : 
        begin
          start_read_canB =  1;
        end
      pass_to_elink1 : 
        begin
          start_write_elinkB =  1;
        end
      rst_rec_irq_can1 : 
        begin
          reset_irq_canB =  1;
          reset_irq_rec_canB =  1;
        end
      finish_proc2 : 
        begin
          end_can_procB =  1;
        end
      rst_tra_irq_can1 : 
        begin
          reset_irq_canB =  1;
          reset_irq_osc_canB =  1;
        end
      Trim_ack1 : 
        begin
          start_trim_ackB =  1;
        end
      Start_write_trim1 : 
        begin
          start_trim_oscB =  1;
        end
      pass_mes_to_can1 : 
        begin
          send_mes_canB =  1;
        end
      send_ack2 : 
        begin
          irq_can_ackB =  1;
        end
      ST_En_power0 : 
        begin
          power_bus_enB =  1;
        end
      ST_En_power1 : 
        begin
          power_bus_enB =  1;
        end
      ST_MOPS_dbg2 : 
        begin
          rst_busB =  1;
        end
      Count_gen_dbg : 
        begin
          ext_counter_genB =  1;
        end
    endcase
  end

always @( current_stateC )
  begin : output_block_procC
    done_trim_osc_allC =  0;
    end_can_procC =  0;
    end_trim_busC =  0;
    entimeout_trimC =  1;
    ext_counter_genC =  0;
    irq_can_ackC =  0;
    osc_trim_modeC =  1;
    power_bus_enC =  0;
    reset_irq_canC =  0;
    reset_irq_osc_canC =  0;
    reset_irq_rec_canC =  0;
    rst_busC =  0;
    rst_osc_cntC =  0;
    send_mes_canC =  0;
    skip_osc_trimC =  0;
    start_osc_cntC =  0;
    start_read_canC =  0;
    start_trim_ackC =  0;
    start_trim_oscC =  0;
    start_write_elinkC =  0;
    case (current_stateC)
      waittoact : 
        begin
          entimeout_trimC =  0;
          osc_trim_modeC =  0;
        end
      reset : 
        begin
          entimeout_trimC =  0;
          osc_trim_modeC =  0;
          power_bus_enC =  0;
        end
      ST_Skip_Bus : 
        begin
          skip_osc_trimC =  1;
        end
      rst_irq_can : 
        begin
          reset_irq_osc_canC =  1;
        end
      ST_Start_Cnt : 
        begin
          start_osc_cntC =  1;
          power_bus_enC =  1;
        end
      finish_proc : 
        begin
          end_trim_busC =  1;
        end
      ST_CountRst : 
        begin
          rst_osc_cntC =  1;
        end
      Read_Resp : 
        begin
          start_read_canC =  1;
        end
      pass_to_elink : 
        begin
          start_write_elinkC =  1;
        end
      rst_rec_irq_can : 
        begin
          reset_irq_canC =  1;
          reset_irq_rec_canC =  1;
        end
      finish_proc1 : 
        begin
          end_can_procC =  1;
        end
      rst_tra_irq_can : 
        begin
          reset_irq_canC =  1;
          reset_irq_osc_canC =  1;
        end
      Trim_ack : 
        begin
          start_trim_ackC =  1;
        end
      Start_write_trim : 
        begin
          start_trim_oscC =  1;
        end
      pass_mes_to_can : 
        begin
          send_mes_canC =  1;
        end
      send_ack1 : 
        begin
          irq_can_ackC =  1;
        end
      ST_Done_Trim : 
        begin
          done_trim_osc_allC =  1;
        end
      ST_Skip_Bus1 : 
        begin
          skip_osc_trimC =  1;
        end
      rst_irq_can1 : 
        begin
          reset_irq_osc_canC =  1;
        end
      RST_MOPS_dbg1 : 
        begin
          rst_busC =  1;
        end
      ST_Start_Cnt1 : 
        begin
          start_osc_cntC =  1;
        end
      Count_gen_dbg1 : 
        begin
          ext_counter_genC =  1;
        end
      finish_proc3 : 
        begin
          end_trim_busC =  1;
        end
      ST_CountRst1 : 
        begin
          rst_osc_cntC =  1;
        end
      Check_Trim1 : 
        begin
          power_bus_enC =  0;
        end
      ST_Done_Trim1 : 
        begin
          done_trim_osc_allC =  1;
        end
      Read_Resp1 : 
        begin
          start_read_canC =  1;
        end
      pass_to_elink1 : 
        begin
          start_write_elinkC =  1;
        end
      rst_rec_irq_can1 : 
        begin
          reset_irq_canC =  1;
          reset_irq_rec_canC =  1;
        end
      finish_proc2 : 
        begin
          end_can_procC =  1;
        end
      rst_tra_irq_can1 : 
        begin
          reset_irq_canC =  1;
          reset_irq_osc_canC =  1;
        end
      Trim_ack1 : 
        begin
          start_trim_ackC =  1;
        end
      Start_write_trim1 : 
        begin
          start_trim_oscC =  1;
        end
      pass_mes_to_can1 : 
        begin
          send_mes_canC =  1;
        end
      send_ack2 : 
        begin
          irq_can_ackC =  1;
        end
      ST_En_power0 : 
        begin
          power_bus_enC =  1;
        end
      ST_En_power1 : 
        begin
          power_bus_enC =  1;
        end
      ST_MOPS_dbg2 : 
        begin
          rst_busC =  1;
        end
      Count_gen_dbg : 
        begin
          ext_counter_genC =  1;
        end
    endcase
  end

always @( posedge clkA or negedge rstA )
  begin : clocked_block_procA
    if (!rstA)
      begin
        current_stateA <= reset;
      end
    else
      begin
        if (timeoutrstA)
          begin
            current_stateA <= ST_Skip_Bus;
          end
        else
          if (abortA)
            begin
              current_stateA <= reset;
            end
          else
            begin
              current_stateA <= next_stateA;
            end
      end
  end

always @( posedge clkB or negedge rstB )
  begin : clocked_block_procB
    if (!rstB)
      begin
        current_stateB <= reset;
      end
    else
      begin
        if (timeoutrstB)
          begin
            current_stateB <= ST_Skip_Bus;
          end
        else
          if (abortB)
            begin
              current_stateB <= reset;
            end
          else
            begin
              current_stateB <= next_stateB;
            end
      end
  end

always @( posedge clkC or negedge rstC )
  begin : clocked_block_procC
    if (!rstC)
      begin
        current_stateC <= reset;
      end
    else
      begin
        if (timeoutrstC)
          begin
            current_stateC <= ST_Skip_Bus;
          end
        else
          if (abortC)
            begin
              current_stateC <= reset;
            end
          else
            begin
              current_stateC <= next_stateC;
            end
      end
  end
endmodule

