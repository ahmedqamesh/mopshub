/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/rcrc_top2TMR.v                                                                *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 16/08/2022 12:58:34                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/mopshub_top_board_canakari_ftrim/hdl   *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -c tmrg.cfg -vvv  *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: rcrc_top2.v                                                                            *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-29 13:49:21                                                *
 *           File Size         : 3485                                                               *
 *           MD5 hash          : 3aed53733a7d4f2a14aa48fa83d9333f                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module rcrc2TMR(
  input wire  clockA ,
  input wire  clockB ,
  input wire  clockC ,
  input wire  bitinA ,
  input wire  bitinB ,
  input wire  bitinC ,
  input wire  activA ,
  input wire  activB ,
  input wire  activC ,
  input wire  resetA ,
  input wire  resetB ,
  input wire  resetC ,
  output reg  crc_okA ,
  output reg  crc_okB ,
  output reg  crc_okC 
);
wor enable_iTmrErrorC;
wire enable_iVotedC;
wor edgedTmrErrorC;
wire edgedVotedC;
wor enable_iTmrErrorB;
wire enable_iVotedB;
wor edgedTmrErrorB;
wire edgedVotedB;
wor enable_iTmrErrorA;
wire enable_iVotedA;
wor edgedTmrErrorA;
wire edgedVotedA;
reg  enable_iA ;
reg  enable_iB ;
reg  enable_iC ;
wire reset_iA;
wire reset_iB;
wire reset_iC;
wire [14:0] q_outA;
wire [14:0] q_outB;
wire [14:0] q_outC;
wire [14:0] inpA;
wire [14:0] inpB;
wire [14:0] inpC;
reg  edgedA ;
reg  edgedB ;
reg  edgedC ;
assign reset_iA =  resetA;
assign reset_iB =  resetB;
assign reset_iC =  resetC;
genvar i;

generate
  for(i =  0;i<15;i =  i+1)
    begin 

      rcrc_cell2TMR reg_i (
          .enableA(enable_iVotedA),
          .enableB(enable_iVotedB),
          .enableC(enable_iVotedC),
          .clockA(clockA),
          .clockB(clockB),
          .clockC(clockC),
          .resetA(reset_iA),
          .resetB(reset_iB),
          .resetC(reset_iC),
          .InputA(inpA[i] ),
          .InputB(inpB[i] ),
          .InputC(inpC[i] ),
          .qA(q_outA[i] ),
          .qB(q_outB[i] ),
          .qC(q_outC[i] )
          );
    end

endgenerate

always @( negedge clockA )
  begin
    if (resetA==1'b0)
      enable_iA <= 1'b1;
    else
      begin
        enable_iA <= enable_iVotedA;
        edgedA =  edgedVotedA;
        if (activA==1'b1)
          if (edgedVotedA==1'b0)
            begin
              edgedA =  1'b1;
              enable_iA <= 1'b1;
            end
          else
            edgedA =  1'b1;
        else
          begin
            edgedA =  1'b0;
            enable_iA <= 1'b0;
          end
      end
  end

always @( negedge clockB )
  begin
    if (resetB==1'b0)
      enable_iB <= 1'b1;
    else
      begin
        enable_iB <= enable_iVotedB;
        edgedB =  edgedVotedB;
        if (activB==1'b1)
          if (edgedVotedB==1'b0)
            begin
              edgedB =  1'b1;
              enable_iB <= 1'b1;
            end
          else
            edgedB =  1'b1;
        else
          begin
            edgedB =  1'b0;
            enable_iB <= 1'b0;
          end
      end
  end

always @( negedge clockC )
  begin
    if (resetC==1'b0)
      enable_iC <= 1'b1;
    else
      begin
        enable_iC <= enable_iVotedC;
        edgedC =  edgedVotedC;
        if (activC==1'b1)
          if (edgedVotedC==1'b0)
            begin
              edgedC =  1'b1;
              enable_iC <= 1'b1;
            end
          else
            edgedC =  1'b1;
        else
          begin
            edgedC =  1'b0;
            enable_iC <= 1'b0;
          end
      end
  end

always @( q_outA )
  begin
    if (q_outA==15'd0)
      crc_okA =  1'b1;
    else
      crc_okA =  1'b0;
  end

always @( q_outB )
  begin
    if (q_outB==15'd0)
      crc_okB =  1'b1;
    else
      crc_okB =  1'b0;
  end

always @( q_outC )
  begin
    if (q_outC==15'd0)
      crc_okC =  1'b1;
    else
      crc_okC =  1'b0;
  end
assign inpA[0]  =  bitinA^q_outA[14] ;
assign inpB[0]  =  bitinB^q_outB[14] ;
assign inpC[0]  =  bitinC^q_outC[14] ;
assign inpA[1]  =  q_outA[0] ;
assign inpB[1]  =  q_outB[0] ;
assign inpC[1]  =  q_outC[0] ;
assign inpA[2]  =  q_outA[1] ;
assign inpB[2]  =  q_outB[1] ;
assign inpC[2]  =  q_outC[1] ;
assign inpA[3]  =  q_outA[2] ^q_outA[14] ;
assign inpB[3]  =  q_outB[2] ^q_outB[14] ;
assign inpC[3]  =  q_outC[2] ^q_outC[14] ;
assign inpA[4]  =  q_outA[3] ^q_outA[14] ;
assign inpB[4]  =  q_outB[3] ^q_outB[14] ;
assign inpC[4]  =  q_outC[3] ^q_outC[14] ;
assign inpA[5]  =  q_outA[4] ;
assign inpB[5]  =  q_outB[4] ;
assign inpC[5]  =  q_outC[4] ;
assign inpA[6]  =  q_outA[5] ;
assign inpB[6]  =  q_outB[5] ;
assign inpC[6]  =  q_outC[5] ;
assign inpA[7]  =  q_outA[6] ^q_outA[14] ;
assign inpB[7]  =  q_outB[6] ^q_outB[14] ;
assign inpC[7]  =  q_outC[6] ^q_outC[14] ;
assign inpA[8]  =  q_outA[7] ^q_outA[14] ;
assign inpB[8]  =  q_outB[7] ^q_outB[14] ;
assign inpC[8]  =  q_outC[7] ^q_outC[14] ;
assign inpA[9]  =  q_outA[8] ;
assign inpB[9]  =  q_outB[8] ;
assign inpC[9]  =  q_outC[8] ;
assign inpA[10]  =  q_outA[9] ^q_outA[14] ;
assign inpB[10]  =  q_outB[9] ^q_outB[14] ;
assign inpC[10]  =  q_outC[9] ^q_outC[14] ;
assign inpA[11]  =  q_outA[10] ;
assign inpB[11]  =  q_outB[10] ;
assign inpC[11]  =  q_outC[10] ;
assign inpA[12]  =  q_outA[11] ;
assign inpB[12]  =  q_outB[11] ;
assign inpC[12]  =  q_outC[11] ;
assign inpA[13]  =  q_outA[12] ;
assign inpB[13]  =  q_outB[12] ;
assign inpC[13]  =  q_outC[12] ;
assign inpA[14]  =  q_outA[13] ^q_outA[14] ;
assign inpB[14]  =  q_outB[13] ^q_outB[14] ;
assign inpC[14]  =  q_outC[13] ^q_outC[14] ;

majorityVoter edgedVoterA (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedA),
    .tmrErr(edgedTmrErrorA)
    );

majorityVoter enable_iVoterA (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedA),
    .tmrErr(enable_iTmrErrorA)
    );

majorityVoter edgedVoterB (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedB),
    .tmrErr(edgedTmrErrorB)
    );

majorityVoter enable_iVoterB (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedB),
    .tmrErr(enable_iTmrErrorB)
    );

majorityVoter edgedVoterC (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedC),
    .tmrErr(edgedTmrErrorC)
    );

majorityVoter enable_iVoterC (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedC),
    .tmrErr(enable_iTmrErrorC)
    );
endmodule

