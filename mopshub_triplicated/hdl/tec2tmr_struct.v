//
// Module mopshub_triplicated.tec2TMR.struct
//
// Created:
//          by - dcs.dcs (localhost)
//          at - 09:18:05 05/10/22
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//


module tec2TMR( 
   // Port Declarations
   input   wire           resetA, 
   input   wire           resetB, 
   input   wire           resetC, 
   input   wire           clockA, 
   input   wire           clockB, 
   input   wire           clockC, 
   input   wire           incegttraA, 
   input   wire           incegttraB, 
   input   wire           incegttraC, 
   input   wire           dectraA, 
   input   wire           dectraB, 
   input   wire           dectraC, 
   output  reg            tec_lt96A, 
   output  reg            tec_lt96B, 
   output  reg            tec_lt96C, 
   output  reg            tec_ge96A, 
   output  reg            tec_ge96B, 
   output  reg            tec_ge96C, 
   output  reg            tec_ge128A, 
   output  reg            tec_ge128B, 
   output  reg            tec_ge128C, 
   output  reg            tec_ge256A, 
   output  reg            tec_ge256B, 
   output  reg            tec_ge256C, 
   output  wire    [7:0]  teccountA, 
   output  wire    [7:0]  teccountB, 
   output  wire    [7:0]  teccountC
);


// Internal Declarations


// Local declarations

// Internal signal declarations
wor         edgedTmrErrorC;
wire        edgedVotedC;
wor         counterTmrErrorC;
wire  [8:0] counterVotedC;
wor         edgedTmrErrorB;
wire        edgedVotedB;
wor         counterTmrErrorB;
wire  [8:0] counterVotedB;
wor         edgedTmrErrorA;
wire        edgedVotedA;
wor         counterTmrErrorA;
wire  [8:0] counterVotedA;
reg   [8:0] counterA;
reg   [8:0] counterB;
reg   [8:0] counterC;
reg         edgedA;
reg         edgedB;
reg         edgedC;
wire        actionA;
wire        actionB;
wire        actionC;


// Instances 
majorityVoter #(9) counterVoterA( 
   .inA    (counterA), 
   .inB    (counterB), 
   .inC    (counterC), 
   .out    (counterVotedA), 
   .tmrErr (counterTmrErrorA)
); 

majorityVoter #(9) counterVoterB( 
   .inA    (counterA), 
   .inB    (counterB), 
   .inC    (counterC), 
   .out    (counterVotedB), 
   .tmrErr (counterTmrErrorB)
); 

majorityVoter #(9) counterVoterC( 
   .inA    (counterA), 
   .inB    (counterB), 
   .inC    (counterC), 
   .out    (counterVotedC), 
   .tmrErr (counterTmrErrorC)
); 

majorityVoter edgedVoterA( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedA), 
   .tmrErr (edgedTmrErrorA)
); 

majorityVoter edgedVoterB( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedB), 
   .tmrErr (edgedTmrErrorB)
); 

majorityVoter edgedVoterC( 
   .inA    (edgedA), 
   .inB    (edgedB), 
   .inC    (edgedC), 
   .out    (edgedVotedC), 
   .tmrErr (edgedTmrErrorC)
); 

// HDL Embedded Text Block 1 eb1
assign actionA =  incegttraA|dectraA;
assign actionB =  incegttraB|dectraB;
assign actionC =  incegttraC|dectraC;
assign teccountA =  counterVotedA[7:0] ;
assign teccountB =  counterVotedB[7:0] ;
assign teccountC =  counterVotedC[7:0] ;
// HDL Embedded Text Block 2 eb2
always @( posedge clockA )
  begin
    if (resetA==1'b0)
      begin
        counterA <= 9'd0;
        edgedA <= 1'b0;
      end
    else
      begin
        counterA <= counterVotedA;
        edgedA <= edgedVotedA;
        if (actionA==1'b1)
          begin
            if (edgedVotedA==1'b0)
              begin
                edgedA <= 1'b1;
                if (counterVotedA<=9'd255&&incegttraA==1'b1)
                  counterA <= counterVotedA+8;
                else
                  if (counterVotedA!=9'd0&&dectraA==1'b1)
                    counterA <= counterVotedA-1;
              end
          end
        else
          edgedA <= 1'b0;
      end
  end
// HDL Embedded Text Block 3 eb3
always @( posedge clockB )
  begin
    if (resetB==1'b0)
      begin
        counterB <= 9'd0;
        edgedB <= 1'b0;
      end
    else
      begin
        counterB <= counterVotedB;
        edgedB <= edgedVotedB;
        if (actionB==1'b1)
          begin
            if (edgedVotedB==1'b0)
              begin
                edgedB <= 1'b1;
                if (counterVotedB<=9'd255&&incegttraB==1'b1)
                  counterB <= counterVotedB+8;
                else
                  if (counterVotedB!=9'd0&&dectraB==1'b1)
                    counterB <= counterVotedB-1;
              end
          end
        else
          edgedB <= 1'b0;
      end
  end
// HDL Embedded Text Block 4 eb4
always @( posedge clockC )
  begin
    if (resetC==1'b0)
      begin
        counterC <= 9'd0;
        edgedC <= 1'b0;
      end
    else
      begin
        counterC <= counterVotedC;
        edgedC <= edgedVotedC;
        if (actionC==1'b1)
          begin
            if (edgedVotedC==1'b0)
              begin
                edgedC <= 1'b1;
                if (counterVotedC<=9'd255&&incegttraC==1'b1)
                  counterC <= counterVotedC+8;
                else
                  if (counterVotedC!=9'd0&&dectraC==1'b1)
                    counterC <= counterVotedC-1;
              end
          end
        else
          edgedC <= 1'b0;
      end
  end
// HDL Embedded Text Block 5 eb5
always @( counterVotedA )
  begin
    if (counterVotedA>=9'd256)
      begin
        tec_lt96A <= 1'b0;
        tec_ge96A <= 1'b1;
        tec_ge128A <= 1'b1;
        tec_ge256A <= 1'b1;
      end
    else
      if (counterVotedA>=9'd128&&counterVotedA<9'd256)
        begin
          tec_lt96A <= 1'b0;
          tec_ge96A <= 1'b1;
          tec_ge128A <= 1'b1;
          tec_ge256A <= 1'b0;
        end
      else
        if (counterVotedA<=9'd127&&counterVotedA>=9'd96)
          begin
            tec_lt96A <= 1'b0;
            tec_ge96A <= 1'b1;
            tec_ge128A <= 1'b0;
            tec_ge256A <= 1'b0;
          end
        else
          begin
            tec_lt96A <= 1'b1;
            tec_ge96A <= 1'b0;
            tec_ge128A <= 1'b0;
            tec_ge256A <= 1'b0;
          end
  end
// HDL Embedded Text Block 6 eb6
always @( counterVotedB )
  begin
    if (counterVotedB>=9'd256)
      begin
        tec_lt96B <= 1'b0;
        tec_ge96B <= 1'b1;
        tec_ge128B <= 1'b1;
        tec_ge256B <= 1'b1;
      end
    else
      if (counterVotedB>=9'd128&&counterVotedB<9'd256)
        begin
          tec_lt96B <= 1'b0;
          tec_ge96B <= 1'b1;
          tec_ge128B <= 1'b1;
          tec_ge256B <= 1'b0;
        end
      else
        if (counterVotedB<=9'd127&&counterVotedB>=9'd96)
          begin
            tec_lt96B <= 1'b0;
            tec_ge96B <= 1'b1;
            tec_ge128B <= 1'b0;
            tec_ge256B <= 1'b0;
          end
        else
          begin
            tec_lt96B <= 1'b1;
            tec_ge96B <= 1'b0;
            tec_ge128B <= 1'b0;
            tec_ge256B <= 1'b0;
          end
  end
// HDL Embedded Text Block 7 eb7
always @( counterVotedC )
  begin
    if (counterVotedC>=9'd256)
      begin
        tec_lt96C <= 1'b0;
        tec_ge96C <= 1'b1;
        tec_ge128C <= 1'b1;
        tec_ge256C <= 1'b1;
      end
    else
      if (counterVotedC>=9'd128&&counterVotedC<9'd256)
        begin
          tec_lt96C <= 1'b0;
          tec_ge96C <= 1'b1;
          tec_ge128C <= 1'b1;
          tec_ge256C <= 1'b0;
        end
      else
        if (counterVotedC<=9'd127&&counterVotedC>=9'd96)
          begin
            tec_lt96C <= 1'b0;
            tec_ge96C <= 1'b1;
            tec_ge128C <= 1'b0;
            tec_ge256C <= 1'b0;
          end
        else
          begin
            tec_lt96C <= 1'b1;
            tec_ge96C <= 1'b0;
            tec_ge128C <= 1'b0;
            tec_ge256C <= 1'b0;
          end
  end

endmodule // tec2TMR

