/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/can_elink_bridge_sm_fsmTMR.v                                                  *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:03                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: can_elink_bridge_sm_fsm.v                                                              *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? can_elink_bridge_sm_fsm.v) *
 *           Modification time : 2022-12-04 15:41:31.636209                                         *
 *           File Size         : 14886                                                              *
 *           MD5 hash          : 0906302f5167e8d05101098a3e04e4a0                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`resetall 
`timescale  1ns/10ps
module can_elink_bridge_SMTMR(
  input wire  clk ,
  input wire  end_init ,
  input wire  end_mon_init ,
  input wire  end_power_init ,
  input wire  end_read_can ,
  input wire  end_read_elink ,
  input wire  end_write_can ,
  input wire  end_write_elink ,
  input wire  endwait ,
  input wire  irq_can_rec ,
  input wire  irq_can_tra ,
  input wire  irq_elink_tra ,
  input wire  reset_all_done ,
  input wire  reset_irq_can_done ,
  input wire  rst ,
  input wire  timeoutrst ,
  output reg  abort_mes ,
  output reg  end_can_proc ,
  output reg  entimeout ,
  output reg  read_can_mode ,
  output reg  reset_irq_can ,
  output reg  reset_irq_can_all ,
  output reg  reset_irq_rec_can ,
  output reg  reset_irq_tra_can ,
  output reg  send_mes_can ,
  output reg  sign_on_sig ,
  output reg  start_init_can ,
  output reg  start_mon_init ,
  output reg  start_power_init ,
  output reg  start_read_can ,
  output reg  start_read_elink ,
  output reg  start_write_can ,
  output reg  start_write_elink ,
  output reg [5:0] statedeb 
);
parameter waittoact =5'd0;
parameter reset =5'd1;
parameter initialize =5'd2;
parameter endwaitst =5'd3;
parameter signon =5'd4;
parameter rst_all_irq_can =5'd5;
parameter init_Trim_OSC =5'd6;
parameter Abort_current =5'd7;
parameter init_Mon_ADC =5'd8;
parameter read_elink_mes =5'd9;
parameter Start_write_can =5'd10;
parameter pass_mes_to_can =5'd11;
parameter rst_tra_irq_can =5'd12;
parameter finish_proc =5'd13;
parameter rst_rec_irq_can =5'd14;
parameter pass_mes_to_elink =5'd15;
parameter assign_bus_id =5'd16;
parameter Start_read_elink =5'd17;
wire timeoutrstC;
wire timeoutrstB;
wire timeoutrstA;
wire rstC;
wire rstB;
wire rstA;
wire [4:0] next_stateC;
wire [4:0] next_stateB;
wire [4:0] next_stateA;
wire endwaitC;
wire endwaitB;
wire endwaitA;
wire clkC;
wire clkB;
wire clkA;
wor current_stateTmrError;
wire [4:0] current_state;
reg  [4:0] current_stateA ;
reg  [4:0] current_stateB ;
reg  [4:0] current_stateC ;
reg  [4:0] next_state ;
reg  hds_animation_indicator ;
wire [4:0] current_stateV =  current_state;

always @( current_state or end_init or end_mon_init or end_power_init or end_read_can or end_read_elink or end_write_can or end_write_elink or irq_can_rec or irq_can_tra or irq_elink_tra or reset_all_done or reset_irq_can_done or rst )
  begin : next_state_block_proc
    case (current_state)
      waittoact : 
        begin
          if (irq_can_rec==1)
            begin
              next_state =  assign_bus_id;
              $hdsNextPath(0, 1);
            end
          else
            if (irq_elink_tra==1)
              begin
                next_state =  read_elink_mes;
                $hdsNextPath(0, 2);
              end
            else
              begin
                next_state =  waittoact;
                $hdsNextPath(0, 0);
              end
        end
      reset : 
        begin
          if (rst==1)
            begin
              next_state =  initialize;
              $hdsNextPath(0, 3);
            end
          else
            begin
              next_state =  reset;
              $hdsNextPath(0, 0);
            end
        end
      initialize : 
        begin
          if (end_init==1)
            begin
              next_state =  init_Mon_ADC;
              $hdsNextPath(0, 4);
            end
          else
            begin
              next_state =  initialize;
              $hdsNextPath(0, 0);
            end
        end
      endwaitst : 
        begin
          next_state =  Abort_current;
          $hdsNextPath(0, 5);
        end
      signon : 
        begin
          next_state =  waittoact;
          $hdsNextPath(0, 6);
        end
      rst_all_irq_can : 
        begin
          if (reset_all_done==1)
            begin
              next_state =  waittoact;
              $hdsNextPath(0, 7);
            end
          else
            begin
              next_state =  rst_all_irq_can;
              $hdsNextPath(0, 0);
            end
        end
      init_Trim_OSC : 
        begin
          if (end_power_init==1)
            begin
              next_state =  signon;
              $hdsNextPath(0, 8);
            end
          else
            begin
              next_state =  init_Trim_OSC;
              $hdsNextPath(0, 0);
            end
        end
      Abort_current : 
        begin
          next_state =  rst_all_irq_can;
          $hdsNextPath(0, 9);
        end
      init_Mon_ADC : 
        begin
          if (end_mon_init==1)
            begin
              next_state =  init_Trim_OSC;
              $hdsNextPath(0, 10);
            end
          else
            begin
              next_state =  init_Mon_ADC;
              $hdsNextPath(0, 0);
            end
        end
      read_elink_mes : 
        begin
          if (end_read_elink==1)
            begin
              next_state =  Start_write_can;
              $hdsNextPath(0, 11);
            end
          else
            begin
              next_state =  read_elink_mes;
              $hdsNextPath(0, 0);
            end
        end
      Start_write_can : 
        begin
          if (end_write_can==1)
            begin
              next_state =  pass_mes_to_can;
              $hdsNextPath(0, 12);
            end
          else
            begin
              next_state =  Start_write_can;
              $hdsNextPath(0, 0);
            end
        end
      pass_mes_to_can : 
        begin
          if (irq_can_tra==1)
            begin
              next_state =  rst_tra_irq_can;
              $hdsNextPath(0, 13);
            end
          else
            begin
              next_state =  pass_mes_to_can;
              $hdsNextPath(0, 0);
            end
        end
      rst_tra_irq_can : 
        begin
          if (reset_irq_can_done==1)
            begin
              next_state =  waittoact;
              $hdsNextPath(0, 14);
            end
          else
            begin
              next_state =  rst_tra_irq_can;
              $hdsNextPath(0, 0);
            end
        end
      finish_proc : 
        begin
          next_state =  pass_mes_to_elink;
          $hdsNextPath(0, 15);
        end
      rst_rec_irq_can : 
        begin
          if (reset_irq_can_done==1)
            begin
              next_state =  finish_proc;
              $hdsNextPath(0, 16);
            end
          else
            begin
              next_state =  rst_rec_irq_can;
              $hdsNextPath(0, 0);
            end
        end
      pass_mes_to_elink : 
        begin
          if (end_write_elink==1)
            begin
              next_state =  waittoact;
              $hdsNextPath(0, 17);
            end
          else
            begin
              next_state =  pass_mes_to_elink;
              $hdsNextPath(0, 0);
            end
        end
      assign_bus_id : 
        begin
          next_state =  Start_read_elink;
          $hdsNextPath(0, 18);
        end
      Start_read_elink : 
        begin
          if (end_read_can==1)
            begin
              next_state =  rst_rec_irq_can;
              $hdsNextPath(0, 19);
            end
          else
            begin
              next_state =  Start_read_elink;
              $hdsNextPath(0, 0);
            end
        end
      default : 
        begin
          next_state =  reset;
          $hdsNextPath(0, 0);
        end
    endcase
  end

always @( current_state )
  begin : output_block_proc
    abort_mes =  0;
    end_can_proc =  0;
    entimeout =  1;
    read_can_mode =  0;
    reset_irq_can =  0;
    reset_irq_can_all =  0;
    reset_irq_rec_can =  0;
    reset_irq_tra_can =  0;
    send_mes_can =  0;
    sign_on_sig =  0;
    start_init_can =  0;
    start_mon_init =  0;
    start_power_init =  0;
    start_read_can =  0;
    start_read_elink =  0;
    start_write_can =  0;
    start_write_elink =  0;
    case (current_state)
      waittoact : 
        begin
          entimeout =  0;
        end
      reset : 
        begin
          abort_mes =  0;
          reset_irq_can =  0;
          reset_irq_can_all =  0;
          send_mes_can =  0;
          start_read_can =  0;
          start_read_elink =  0;
          start_write_can =  0;
          start_write_elink =  0;
          start_init_can =  0;
          sign_on_sig =  0;
          entimeout =  0;
          read_can_mode =  0;
        end
      initialize : 
        begin
          start_init_can =  1;
          entimeout =  0;
        end
      signon : 
        begin
          sign_on_sig =  1;
        end
      rst_all_irq_can : 
        begin
          reset_irq_can_all =  1;
        end
      init_Trim_OSC : 
        begin
          start_power_init =  1;
          entimeout =  0;
        end
      Abort_current : 
        begin
          abort_mes =  1;
        end
      init_Mon_ADC : 
        begin
          start_mon_init =  1;
        end
      read_elink_mes : 
        begin
          start_read_elink =  1;
        end
      Start_write_can : 
        begin
          start_write_can =  1;
        end
      pass_mes_to_can : 
        begin
          send_mes_can =  1;
        end
      rst_tra_irq_can : 
        begin
          reset_irq_can =  1;
          reset_irq_tra_can =  1;
        end
      finish_proc : 
        begin
          end_can_proc =  1;
          read_can_mode =  1;
        end
      rst_rec_irq_can : 
        begin
          reset_irq_can =  1;
          reset_irq_rec_can =  1;
          read_can_mode =  1;
        end
      pass_mes_to_elink : 
        begin
          start_write_elink =  1;
          read_can_mode =  1;
        end
      assign_bus_id : 
        begin
          read_can_mode =  1;
        end
      Start_read_elink : 
        begin
          start_read_can =  1;
          read_can_mode =  1;
        end
    endcase
  end

always @( posedge clkA or posedge endwaitA )
  begin : clocked_block_procA
    if (endwaitA)
      begin
        current_stateA <= endwaitst;
      end
    else
      begin
        if (!rstA)
          begin
            current_stateA <= reset;
          end
        else
          if (timeoutrstA)
            begin
              current_stateA <= endwaitst;
            end
          else
            begin
              current_stateA <= next_stateA;
              $hdsClock(0);
            end
      end
  end

always @( posedge clkB or posedge endwaitB )
  begin : clocked_block_procB
    if (endwaitB)
      begin
        current_stateB <= endwaitst;
      end
    else
      begin
        if (!rstB)
          begin
            current_stateB <= reset;
          end
        else
          if (timeoutrstB)
            begin
              current_stateB <= endwaitst;
            end
          else
            begin
              current_stateB <= next_stateB;
              $hdsClock(0);
            end
      end
  end

always @( posedge clkC or posedge endwaitC )
  begin : clocked_block_procC
    if (endwaitC)
      begin
        current_stateC <= endwaitst;
      end
    else
      begin
        if (!rstC)
          begin
            current_stateC <= reset;
          end
        else
          if (timeoutrstC)
            begin
              current_stateC <= endwaitst;
            end
          else
            begin
              current_stateC <= next_stateC;
              $hdsClock(0);
            end
      end
  end

always @( current_state )
  begin
    statedeb =  6'b0;
    statedeb[4:0]  =  current_state;
  end

majorityVoter #(.WIDTH(5)) current_stateVoter (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_state),
    .tmrErr(current_stateTmrError)
    );

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout endwaitFanout (
    .in(endwait),
    .outA(endwaitA),
    .outB(endwaitB),
    .outC(endwaitC)
    );

fanout #(.WIDTH(5)) next_stateFanout (
    .in(next_state),
    .outA(next_stateA),
    .outB(next_stateB),
    .outC(next_stateC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );

fanout timeoutrstFanout (
    .in(timeoutrst),
    .outA(timeoutrstA),
    .outB(timeoutrstB),
    .outC(timeoutrstC)
    );
endmodule

