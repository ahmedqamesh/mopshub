/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/can_elink_bridge_sm_fsmTMR.v                                                  *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 06/10/2022 13:52:39                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: can_elink_bridge_sm_fsm.v                                                              *
 *           Git SHA           : c110441b08b692cc54ebd4a3b84a2599430e8f93                           *
 *           Modification time : 2022-10-06 10:24:27                                                *
 *           File Size         : 10166                                                              *
 *           MD5 hash          : ae94bfe7ac59d98a27fe0cf66f84a7d1                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module can_elink_bridge_SMTMR(
  input wire  clk ,
  input wire  end_init ,
  input wire  end_mon_init ,
  input wire  end_power_init ,
  input wire  end_read_can ,
  input wire  end_read_elink ,
  input wire  end_write_can ,
  input wire  end_write_elink ,
  input wire  endwait ,
  input wire  irq_can_rec ,
  input wire  irq_can_tra ,
  input wire  irq_elink_tra ,
  input wire  reset_all_done ,
  input wire  reset_irq_can_done ,
  input wire  rst ,
  input wire  timeoutrst ,
  output reg  abort_mes ,
  output reg  end_can_proc ,
  output reg  entimeout ,
  output reg  read_can_mode ,
  output reg  reset_irq_can ,
  output reg  reset_irq_can_all ,
  output reg  reset_irq_rec_can ,
  output reg  reset_irq_tra_can ,
  output reg  send_mes_can ,
  output reg  sign_on_sig ,
  output reg  start_init_can ,
  output reg  start_mon_init ,
  output reg  start_power_init ,
  output reg  start_read_can ,
  output reg  start_read_elink ,
  output reg  start_write_can ,
  output reg  start_write_elink ,
  output reg [5:0] statedeb 
);
parameter reset =5'd0;
parameter initialize =5'd1;
parameter waittoact =5'd2;
parameter endwaitst =5'd3;
parameter signon =5'd4;
parameter rst_all_irq_can =5'd5;
parameter init_Trim_OSC =5'd6;
parameter Abort_current =5'd7;
parameter init_Mon_ADC =5'd8;
parameter read_elink_mes =5'd9;
parameter Start_write_can =5'd10;
parameter pass_mes_to_can =5'd11;
parameter rst_tra_irq_can =5'd12;
parameter finish_proc =5'd13;
parameter rst_rec_irq_can =5'd14;
parameter pass_mes_to_elink =5'd15;
parameter assign_bus_id =5'd16;
parameter Start_read_elink =5'd17;
reg  [4:0] current_state ;
reg  [4:0] next_state ;

always @( current_state or end_init or end_mon_init or end_power_init or end_read_can or end_read_elink or end_write_can or end_write_elink or irq_can_rec or irq_can_tra or irq_elink_tra or reset_all_done or reset_irq_can_done or rst )
  begin : next_state_block_proc
    case (current_state)
      reset : 
        begin
          if (rst==1)
            next_state =  initialize;
          else
            next_state =  reset;
        end
      initialize : 
        begin
          if (end_init==1)
            next_state =  init_Mon_ADC;
          else
            next_state =  initialize;
        end
      waittoact : 
        begin
          if (irq_can_rec==1)
            next_state =  assign_bus_id;
          else
            if (irq_elink_tra==1)
              next_state =  read_elink_mes;
            else
              next_state =  waittoact;
        end
      endwaitst : 
        begin
          next_state =  Abort_current;
        end
      signon : 
        begin
          next_state =  waittoact;
        end
      rst_all_irq_can : 
        begin
          if (reset_all_done==1)
            next_state =  waittoact;
          else
            next_state =  rst_all_irq_can;
        end
      init_Trim_OSC : 
        begin
          if (end_power_init==1)
            next_state =  signon;
          else
            next_state =  init_Trim_OSC;
        end
      Abort_current : 
        begin
          next_state =  rst_all_irq_can;
        end
      init_Mon_ADC : 
        begin
          if (end_mon_init==1)
            next_state =  init_Trim_OSC;
          else
            next_state =  init_Mon_ADC;
        end
      read_elink_mes : 
        begin
          if (end_read_elink==1)
            next_state =  Start_write_can;
          else
            next_state =  read_elink_mes;
        end
      Start_write_can : 
        begin
          if (end_write_can==1)
            next_state =  pass_mes_to_can;
          else
            next_state =  Start_write_can;
        end
      pass_mes_to_can : 
        begin
          if (irq_can_tra==1)
            next_state =  rst_tra_irq_can;
          else
            next_state =  pass_mes_to_can;
        end
      rst_tra_irq_can : 
        begin
          if (reset_irq_can_done==1)
            next_state =  waittoact;
          else
            next_state =  rst_tra_irq_can;
        end
      finish_proc : 
        begin
          next_state =  pass_mes_to_elink;
        end
      rst_rec_irq_can : 
        begin
          if (reset_irq_can_done==1)
            next_state =  finish_proc;
          else
            next_state =  rst_rec_irq_can;
        end
      pass_mes_to_elink : 
        begin
          if (end_write_elink==1)
            next_state =  waittoact;
          else
            next_state =  pass_mes_to_elink;
        end
      assign_bus_id : 
        begin
          next_state =  Start_read_elink;
        end
      Start_read_elink : 
        begin
          if (end_read_can==1)
            next_state =  rst_rec_irq_can;
          else
            next_state =  Start_read_elink;
        end
      default : next_state =  reset;
    endcase
  end

always @( current_state )
  begin : output_block_proc
    abort_mes =  0;
    end_can_proc =  0;
    entimeout =  1;
    read_can_mode =  0;
    reset_irq_can =  0;
    reset_irq_can_all =  0;
    reset_irq_rec_can =  0;
    reset_irq_tra_can =  0;
    send_mes_can =  0;
    sign_on_sig =  0;
    start_init_can =  0;
    start_mon_init =  0;
    start_power_init =  0;
    start_read_can =  0;
    start_read_elink =  0;
    start_write_can =  0;
    start_write_elink =  0;
    case (current_state)
      reset : 
        begin
          abort_mes =  0;
          reset_irq_can =  0;
          reset_irq_can_all =  0;
          send_mes_can =  0;
          start_read_can =  0;
          start_read_elink =  0;
          start_write_can =  0;
          start_write_elink =  0;
          start_init_can =  0;
          sign_on_sig =  0;
          entimeout =  0;
          read_can_mode =  0;
        end
      initialize : 
        begin
          start_init_can =  1;
          entimeout =  0;
        end
      waittoact : 
        begin
          entimeout =  0;
        end
      signon : 
        begin
          sign_on_sig =  1;
        end
      rst_all_irq_can : 
        begin
          reset_irq_can_all =  1;
        end
      init_Trim_OSC : 
        begin
          start_power_init =  1;
          entimeout =  0;
        end
      Abort_current : 
        begin
          abort_mes =  1;
        end
      init_Mon_ADC : 
        begin
          start_mon_init =  1;
        end
      read_elink_mes : 
        begin
          start_read_elink =  1;
        end
      Start_write_can : 
        begin
          start_write_can =  1;
        end
      pass_mes_to_can : 
        begin
          send_mes_can =  1;
        end
      rst_tra_irq_can : 
        begin
          reset_irq_can =  1;
          reset_irq_tra_can =  1;
        end
      finish_proc : 
        begin
          end_can_proc =  1;
          read_can_mode =  1;
        end
      rst_rec_irq_can : 
        begin
          reset_irq_can =  1;
          reset_irq_rec_can =  1;
          read_can_mode =  1;
        end
      pass_mes_to_elink : 
        begin
          start_write_elink =  1;
          read_can_mode =  1;
        end
      assign_bus_id : 
        begin
          read_can_mode =  1;
        end
      Start_read_elink : 
        begin
          start_read_can =  1;
          read_can_mode =  1;
        end
    endcase
  end

always @( posedge clk or posedge endwait )
  begin : clocked_block_proc
    if (endwait)
      begin
        current_state <= endwaitst;
      end
    else
      begin
        if (!rst)
          begin
            current_state <= reset;
          end
        else
          if (timeoutrst)
            begin
              current_state <= endwaitst;
            end
          else
            begin
              current_state <= next_state;
            end
      end
  end

always @( current_state )
  begin
    statedeb =  6'b0;
    statedeb[4:0]  =  current_state;
  end
endmodule

