/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./spi_masterTMR.v                                                                      *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/05/2022 14:21:02                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/vhdl_trans/reg             *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv spi_master.v  *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: spi_master.v                                                                           *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-05-05 14:20:33.585676                                         *
 *           File Size         : 2804                                                               *
 *           MD5 hash          : d551718abb480a564990bde83ab1003a                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module spi_masterTMR #(
  parameter  F_CLK  = 50000000,
  parameter  F_SCK  = 25000000
)(
  input  clk ,
  input  rst ,
  input  miso ,
  input  txdat ,
  input  transceive ,
  output  sck ,
  output  mosi ,
  output  rxdat ,
  output  busy 
);
localparam idle =0;
localparam load =1;
localparam tx1 =2;
localparam tx2 =3;
localparam writeback =4;
wire txdatC;
wire txdatB;
wire txdatA;
wire tx_srwC;
wire tx_srwB;
wire tx_srwA;
wire transceiveC;
wire transceiveB;
wire transceiveA;
wire statewC;
wire statewB;
wire statewA;
wire sck_rwC;
wire sck_rwB;
wire sck_rwA;
wire sck_enwC;
wire sck_enwB;
wire sck_enwA;
wire sck_cntwC;
wire sck_cntwB;
wire sck_cntwA;
wire rxdat_rwC;
wire rxdat_rwB;
wire rxdat_rwA;
wire rx_srwC;
wire rx_srwB;
wire rx_srwA;
wire rstC;
wire rstB;
wire rstA;
wire misoC;
wire misoB;
wire misoA;
wire clkC;
wire clkB;
wire clkA;
wire bitcntwC;
wire bitcntwB;
wire bitcntwA;
wor tx_srTmrError;
wire [7:0] tx_sr;
wor stateTmrError;
wire [2:0] state;
wor sck_rTmrError;
wire sck_r;
wor sck_enTmrError;
wire sck_en;
wor sck_cntTmrError;
wire [((F_CLK/(2*F_SCK))-1):0] sck_cnt;
wor rxdat_rTmrError;
wire rxdat_r;
wor rx_srTmrError;
wire [7:0] rx_sr;
wor bitcntTmrError;
wire [7:0] bitcnt;
wire sck_rw =  sck_r;
wire rxdat_rw =  rxdat_r;
wire sck_enw =  sck_en;
wire sck_cntw =  sck_cnt;
wire statew =  state;
wire rx_srw =  rx_sr;
wire tx_srw =  tx_sr;
wire bitcntw =  bitcnt;
reg  sck_rA ;
reg  sck_rB ;
reg  sck_rC ;
reg  rxdat_rA ;
reg  rxdat_rB ;
reg  rxdat_rC ;
reg  sck_enA ;
reg  sck_enB ;
reg  sck_enC ;
reg  [((F_CLK/(2*F_SCK))-1):0] sck_cntA ;
reg  [((F_CLK/(2*F_SCK))-1):0] sck_cntB ;
reg  [((F_CLK/(2*F_SCK))-1):0] sck_cntC ;
reg  [2:0] stateA ;
reg  [2:0] stateB ;
reg  [2:0] stateC ;
reg  [7:0] rx_srA ;
reg  [7:0] rx_srB ;
reg  [7:0] rx_srC ;
reg  [7:0] tx_srA ;
reg  [7:0] tx_srB ;
reg  [7:0] tx_srC ;
initial
  begin
    rx_srA <= 0;
    tx_srA <= 0;
  end
initial
  begin
    rx_srB <= 0;
    tx_srB <= 0;
  end
initial
  begin
    rx_srC <= 0;
    tx_srC <= 0;
  end
reg  [7:0] bitcntA ;
reg  [7:0] bitcntB ;
reg  [7:0] bitcntC ;
initial
  begin
    bitcntA <= 0;
  end
initial
  begin
    bitcntB <= 0;
  end
initial
  begin
    bitcntC <= 0;
  end

always @( posedge clkA )
  begin
    sck_enA <= sck_enwA;
    sck_cntA <= sck_cntwA;
    if (rstA==0)
      begin
        sck_enA <= 0;
      end
    else
      begin
        if (sck_cntA==((F_CLK/(2*F_SCK))-1))
          begin
            sck_enA <= 1;
            sck_cntA <= 0;
          end
        else
          begin
            sck_enA <= 0;
            sck_cntA <= sck_cntA+1;
          end
      end
  end

always @( posedge clkB )
  begin
    sck_enB <= sck_enwB;
    sck_cntB <= sck_cntwB;
    if (rstB==0)
      begin
        sck_enB <= 0;
      end
    else
      begin
        if (sck_cntB==((F_CLK/(2*F_SCK))-1))
          begin
            sck_enB <= 1;
            sck_cntB <= 0;
          end
        else
          begin
            sck_enB <= 0;
            sck_cntB <= sck_cntB+1;
          end
      end
  end

always @( posedge clkC )
  begin
    sck_enC <= sck_enwC;
    sck_cntC <= sck_cntwC;
    if (rstC==0)
      begin
        sck_enC <= 0;
      end
    else
      begin
        if (sck_cntC==((F_CLK/(2*F_SCK))-1))
          begin
            sck_enC <= 1;
            sck_cntC <= 0;
          end
        else
          begin
            sck_enC <= 0;
            sck_cntC <= sck_cntC+1;
          end
      end
  end

always @( posedge clkA )
  begin
    stateA <= statewA;
    sck_rA <= sck_rwA;
    tx_srA <= tx_srwA;
    bitcntA <= bitcntwA;
    rx_srA <= rx_srwA;
    rxdat_rA <= rxdat_rwA;
    if (rstA==0)
      begin
        stateA =  idle;
      end
    else
      begin
        case (stateA)
          idle : 
            begin
              if (transceiveA==1)
                begin
                  stateA <= load;
                end
              sck_rA <= 0;
            end
          load : 
            begin
              tx_srA <= txdatA;
              bitcntA <= 7;
              sck_rA <= 0;
              if (sck_enA==1)
                begin
                  stateA <= tx1;
                end
            end
          tx1 : 
            begin
              if (sck_enA==1)
                begin
                  rx_srA <= rx_srA[6:0] &misoA;
                  sck_rA <= 1;
                  stateA <= tx2;
                end
            end
          tx2 : 
            begin
              if (sck_enA==1)
                begin
                  tx_srA <= tx_srA[6:0] &0;
                  sck_rA <= 0;
                  if (bitcntA==0)
                    begin
                      stateA <= writeback;
                    end
                  else
                    begin
                      stateA <= tx1;
                      bitcntA <= bitcntA-1;
                    end
                end
            end
          writeback : 
            begin
              rxdat_rA <= rx_srA;
              stateA <= idle;
            end
          default : stateA <= idle;
        endcase
      end
  end

always @( posedge clkB )
  begin
    stateB <= statewB;
    sck_rB <= sck_rwB;
    tx_srB <= tx_srwB;
    bitcntB <= bitcntwB;
    rx_srB <= rx_srwB;
    rxdat_rB <= rxdat_rwB;
    if (rstB==0)
      begin
        stateB =  idle;
      end
    else
      begin
        case (stateB)
          idle : 
            begin
              if (transceiveB==1)
                begin
                  stateB <= load;
                end
              sck_rB <= 0;
            end
          load : 
            begin
              tx_srB <= txdatB;
              bitcntB <= 7;
              sck_rB <= 0;
              if (sck_enB==1)
                begin
                  stateB <= tx1;
                end
            end
          tx1 : 
            begin
              if (sck_enB==1)
                begin
                  rx_srB <= rx_srB[6:0] &misoB;
                  sck_rB <= 1;
                  stateB <= tx2;
                end
            end
          tx2 : 
            begin
              if (sck_enB==1)
                begin
                  tx_srB <= tx_srB[6:0] &0;
                  sck_rB <= 0;
                  if (bitcntB==0)
                    begin
                      stateB <= writeback;
                    end
                  else
                    begin
                      stateB <= tx1;
                      bitcntB <= bitcntB-1;
                    end
                end
            end
          writeback : 
            begin
              rxdat_rB <= rx_srB;
              stateB <= idle;
            end
          default : stateB <= idle;
        endcase
      end
  end

always @( posedge clkC )
  begin
    stateC <= statewC;
    sck_rC <= sck_rwC;
    tx_srC <= tx_srwC;
    bitcntC <= bitcntwC;
    rx_srC <= rx_srwC;
    rxdat_rC <= rxdat_rwC;
    if (rstC==0)
      begin
        stateC =  idle;
      end
    else
      begin
        case (stateC)
          idle : 
            begin
              if (transceiveC==1)
                begin
                  stateC <= load;
                end
              sck_rC <= 0;
            end
          load : 
            begin
              tx_srC <= txdatC;
              bitcntC <= 7;
              sck_rC <= 0;
              if (sck_enC==1)
                begin
                  stateC <= tx1;
                end
            end
          tx1 : 
            begin
              if (sck_enC==1)
                begin
                  rx_srC <= rx_srC[6:0] &misoC;
                  sck_rC <= 1;
                  stateC <= tx2;
                end
            end
          tx2 : 
            begin
              if (sck_enC==1)
                begin
                  tx_srC <= tx_srC[6:0] &0;
                  sck_rC <= 0;
                  if (bitcntC==0)
                    begin
                      stateC <= writeback;
                    end
                  else
                    begin
                      stateC <= tx1;
                      bitcntC <= bitcntC-1;
                    end
                end
            end
          writeback : 
            begin
              rxdat_rC <= rx_srC;
              stateC <= idle;
            end
          default : stateC <= idle;
        endcase
      end
  end
assign mosi =  tx_sr[7] ;
assign busy =  (state==idle&&transceive==0) ? 0 : 1;
assign sck =  sck_r;
assign rxdat =  rxdat_r;

majorityVoter #(.WIDTH(8)) bitcntVoter (
    .inA(bitcntA),
    .inB(bitcntB),
    .inC(bitcntC),
    .out(bitcnt),
    .tmrErr(bitcntTmrError)
    );

majorityVoter #(.WIDTH(8)) rx_srVoter (
    .inA(rx_srA),
    .inB(rx_srB),
    .inC(rx_srC),
    .out(rx_sr),
    .tmrErr(rx_srTmrError)
    );

majorityVoter rxdat_rVoter (
    .inA(rxdat_rA),
    .inB(rxdat_rB),
    .inC(rxdat_rC),
    .out(rxdat_r),
    .tmrErr(rxdat_rTmrError)
    );

majorityVoter #(.WIDTH(((((F_CLK/(2*F_SCK))-1))>(0)) ? ((((F_CLK/(2*F_SCK))-1))-(0)+1) : ((0)-(((F_CLK/(2*F_SCK))-1))+1))) sck_cntVoter (
    .inA(sck_cntA),
    .inB(sck_cntB),
    .inC(sck_cntC),
    .out(sck_cnt),
    .tmrErr(sck_cntTmrError)
    );

majorityVoter sck_enVoter (
    .inA(sck_enA),
    .inB(sck_enB),
    .inC(sck_enC),
    .out(sck_en),
    .tmrErr(sck_enTmrError)
    );

majorityVoter sck_rVoter (
    .inA(sck_rA),
    .inB(sck_rB),
    .inC(sck_rC),
    .out(sck_r),
    .tmrErr(sck_rTmrError)
    );

majorityVoter #(.WIDTH(3)) stateVoter (
    .inA(stateA),
    .inB(stateB),
    .inC(stateC),
    .out(state),
    .tmrErr(stateTmrError)
    );

majorityVoter #(.WIDTH(8)) tx_srVoter (
    .inA(tx_srA),
    .inB(tx_srB),
    .inC(tx_srC),
    .out(tx_sr),
    .tmrErr(tx_srTmrError)
    );

fanout bitcntwFanout (
    .in(bitcntw),
    .outA(bitcntwA),
    .outB(bitcntwB),
    .outC(bitcntwC)
    );

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout misoFanout (
    .in(miso),
    .outA(misoA),
    .outB(misoB),
    .outC(misoC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );

fanout rx_srwFanout (
    .in(rx_srw),
    .outA(rx_srwA),
    .outB(rx_srwB),
    .outC(rx_srwC)
    );

fanout rxdat_rwFanout (
    .in(rxdat_rw),
    .outA(rxdat_rwA),
    .outB(rxdat_rwB),
    .outC(rxdat_rwC)
    );

fanout sck_cntwFanout (
    .in(sck_cntw),
    .outA(sck_cntwA),
    .outB(sck_cntwB),
    .outC(sck_cntwC)
    );

fanout sck_enwFanout (
    .in(sck_enw),
    .outA(sck_enwA),
    .outB(sck_enwB),
    .outC(sck_enwC)
    );

fanout sck_rwFanout (
    .in(sck_rw),
    .outA(sck_rwA),
    .outB(sck_rwB),
    .outC(sck_rwC)
    );

fanout statewFanout (
    .in(statew),
    .outA(statewA),
    .outB(statewB),
    .outC(statewC)
    );

fanout transceiveFanout (
    .in(transceive),
    .outA(transceiveA),
    .outB(transceiveB),
    .outC(transceiveC)
    );

fanout tx_srwFanout (
    .in(tx_srw),
    .outA(tx_srwA),
    .outB(tx_srwB),
    .outC(tx_srwC)
    );

fanout txdatFanout (
    .in(txdat),
    .outA(txdatA),
    .outB(txdatB),
    .outC(txdatC)
    );
endmodule



// /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/tmrg/../common/voter.v
module majorityVoter #(
  parameter WIDTH = 1
)( 
  input wire  [WIDTH-1:0] inA,
  input wire  [WIDTH-1:0] inB,
  input wire  [WIDTH-1:0] inC,
  output wire [WIDTH-1:0] out,
  output reg              tmrErr
);
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC) begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/tmrg/../common/fanout.v
module fanout #(
  parameter WIDTH = 1
)(
  input wire  [WIDTH-1:0] in,
  output wire [WIDTH-1:0] outA,
  output wire [WIDTH-1:0] outB,
  output wire [WIDTH-1:0] outC
);
  assign outA = in;
  assign outB = in;
  assign outC = in;
endmodule
