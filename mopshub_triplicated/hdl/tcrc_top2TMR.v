/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/tcrc_top2TMR.v                                                                *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:56                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: tcrc_top2.v                                                                            *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-29 13:49:21                                                *
 *           File Size         : 4838                                                               *
 *           MD5 hash          : 3dbe63acfccaf3721b91ec598b2ae63b                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module tcrc2TMR(
  input wire  clockA ,
  input wire  clockB ,
  input wire  clockC ,
  input wire  bitinA ,
  input wire  bitinB ,
  input wire  bitinC ,
  input wire  activA ,
  input wire  activB ,
  input wire  activC ,
  input wire  resetA ,
  input wire  resetB ,
  input wire  resetC ,
  input wire [14:0] crc_pre_load_extA ,
  input wire [14:0] crc_pre_load_extB ,
  input wire [14:0] crc_pre_load_extC ,
  input wire [14:0] crc_pre_load_remA ,
  input wire [14:0] crc_pre_load_remB ,
  input wire [14:0] crc_pre_load_remC ,
  input wire  extendedA ,
  input wire  extendedB ,
  input wire  extendedC ,
  input wire  loadA ,
  input wire  loadB ,
  input wire  loadC ,
  input wire  load_activA ,
  input wire  load_activB ,
  input wire  load_activC ,
  input wire  crc_shft_outA ,
  input wire  crc_shft_outB ,
  input wire  crc_shft_outC ,
  input wire  zerointcrcA ,
  input wire  zerointcrcB ,
  input wire  zerointcrcC ,
  output wire  crc_tosendA ,
  output wire  crc_tosendB ,
  output wire  crc_tosendC 
);
wor enable_iTmrErrorC;
wire enable_iVotedC;
wor edgedTmrErrorC;
wire edgedVotedC;
wor enable_iTmrErrorB;
wire enable_iVotedB;
wor edgedTmrErrorB;
wire edgedVotedB;
wor enable_iTmrErrorA;
wire enable_iVotedA;
wor edgedTmrErrorA;
wire edgedVotedA;
reg  edgedA ;
reg  edgedB ;
reg  edgedC ;
reg  enable_iA ;
reg  enable_iB ;
reg  enable_iC ;
wire activ_iA;
wire activ_iB;
wire activ_iC;
wire reset_iA;
wire reset_iB;
wire reset_iC;
wire load_iA;
wire load_iB;
wire load_iC;
wire bitin_iA;
wire bitin_iB;
wire bitin_iC;
wire feedbackA;
wire feedbackB;
wire feedbackC;
wire [14:0] q_outA;
wire [14:0] q_outB;
wire [14:0] q_outC;
wire [14:0] inpA;
wire [14:0] inpB;
wire [14:0] inpC;
reg  [14:0] crc_pre_load_iA ;
reg  [14:0] crc_pre_load_iB ;
reg  [14:0] crc_pre_load_iC ;
assign reset_iA =  resetA;
assign reset_iB =  resetB;
assign reset_iC =  resetC;
assign activ_iA =  (activA&(~ crc_shft_outA ))|(load_activA&crc_shft_outA);
assign activ_iB =  (activB&(~ crc_shft_outB ))|(load_activB&crc_shft_outB);
assign activ_iC =  (activC&(~ crc_shft_outC ))|(load_activC&crc_shft_outC);
assign feedbackA =  (~ crc_shft_outA )&q_outA[14] ;
assign feedbackB =  (~ crc_shft_outB )&q_outB[14] ;
assign feedbackC =  (~ crc_shft_outC )&q_outC[14] ;
assign load_iA =  loadA&load_activA;
assign load_iB =  loadB&load_activB;
assign load_iC =  loadC&load_activC;
assign bitin_iA =  (bitinA|crc_shft_outA)&zerointcrcA;
assign bitin_iB =  (bitinB|crc_shft_outB)&zerointcrcB;
assign bitin_iC =  (bitinC|crc_shft_outC)&zerointcrcC;
assign inpA[0]  =  bitin_iA^feedbackA;
assign inpB[0]  =  bitin_iB^feedbackB;
assign inpC[0]  =  bitin_iC^feedbackC;
assign inpA[1]  =  q_outA[0] ;
assign inpB[1]  =  q_outB[0] ;
assign inpC[1]  =  q_outC[0] ;
assign inpA[2]  =  q_outA[1] ;
assign inpB[2]  =  q_outB[1] ;
assign inpC[2]  =  q_outC[1] ;
assign inpA[3]  =  q_outA[2] ^feedbackA;
assign inpB[3]  =  q_outB[2] ^feedbackB;
assign inpC[3]  =  q_outC[2] ^feedbackC;
assign inpA[4]  =  q_outA[3] ^feedbackA;
assign inpB[4]  =  q_outB[3] ^feedbackB;
assign inpC[4]  =  q_outC[3] ^feedbackC;
assign inpA[5]  =  q_outA[4] ;
assign inpB[5]  =  q_outB[4] ;
assign inpC[5]  =  q_outC[4] ;
assign inpA[6]  =  q_outA[5] ;
assign inpB[6]  =  q_outB[5] ;
assign inpC[6]  =  q_outC[5] ;
assign inpA[7]  =  q_outA[6] ^feedbackA;
assign inpB[7]  =  q_outB[6] ^feedbackB;
assign inpC[7]  =  q_outC[6] ^feedbackC;
assign inpA[8]  =  q_outA[7] ^feedbackA;
assign inpB[8]  =  q_outB[7] ^feedbackB;
assign inpC[8]  =  q_outC[7] ^feedbackC;
assign inpA[9]  =  q_outA[8] ;
assign inpB[9]  =  q_outB[8] ;
assign inpC[9]  =  q_outC[8] ;
assign inpA[10]  =  q_outA[9] ^feedbackA;
assign inpB[10]  =  q_outB[9] ^feedbackB;
assign inpC[10]  =  q_outC[9] ^feedbackC;
assign inpA[11]  =  q_outA[10] ;
assign inpB[11]  =  q_outB[10] ;
assign inpC[11]  =  q_outC[10] ;
assign inpA[12]  =  q_outA[11] ;
assign inpB[12]  =  q_outB[11] ;
assign inpC[12]  =  q_outC[11] ;
assign inpA[13]  =  q_outA[12] ;
assign inpB[13]  =  q_outB[12] ;
assign inpC[13]  =  q_outC[12] ;
assign inpA[14]  =  q_outA[13] ^feedbackA;
assign inpB[14]  =  q_outB[13] ^feedbackB;
assign inpC[14]  =  q_outC[13] ^feedbackC;
assign crc_tosendA =  q_outA[14] ;
assign crc_tosendB =  q_outB[14] ;
assign crc_tosendC =  q_outC[14] ;
genvar i;

generate
  for(i =  0;i<15;i =  i+1)
    begin 

      tcrc_cell2TMR reg_i (
          .enableA(enable_iVotedA),
          .enableB(enable_iVotedB),
          .enableC(enable_iVotedC),
          .preloadA(crc_pre_load_iA[i] ),
          .preloadB(crc_pre_load_iB[i] ),
          .preloadC(crc_pre_load_iC[i] ),
          .clockA(clockA),
          .clockB(clockB),
          .clockC(clockC),
          .resetA(reset_iA),
          .resetB(reset_iB),
          .resetC(reset_iC),
          .loadA(load_iA),
          .loadB(load_iB),
          .loadC(load_iC),
          .InputA(inpA[i] ),
          .InputB(inpB[i] ),
          .InputC(inpC[i] ),
          .qA(q_outA[i] ),
          .qB(q_outB[i] ),
          .qC(q_outC[i] )
          );
    end

endgenerate

always @( extendedA or crc_pre_load_extA or crc_pre_load_remA )
  begin
    if (extendedA==1'b1)
      crc_pre_load_iA =  crc_pre_load_extA;
    else
      crc_pre_load_iA =  crc_pre_load_remA;
  end

always @( extendedB or crc_pre_load_extB or crc_pre_load_remB )
  begin
    if (extendedB==1'b1)
      crc_pre_load_iB =  crc_pre_load_extB;
    else
      crc_pre_load_iB =  crc_pre_load_remB;
  end

always @( extendedC or crc_pre_load_extC or crc_pre_load_remC )
  begin
    if (extendedC==1'b1)
      crc_pre_load_iC =  crc_pre_load_extC;
    else
      crc_pre_load_iC =  crc_pre_load_remC;
  end

always @( negedge clockA )
  begin
    if (resetA==1'b0)
      begin
        enable_iA <= 1'b1;
        edgedA =  1'b0;
      end
    else
      begin
        edgedA =  edgedVotedA;
        enable_iA <= enable_iVotedA;
        if (activ_iA==1'b1)
          if (edgedVotedA==1'b0)
            begin
              edgedA =  1'b1;
              enable_iA <= 1'b1;
            end
          else
            begin
              edgedA =  1'b1;
              enable_iA <= 1'b0;
            end
        else
          begin
            edgedA =  1'b0;
            if (loadA==1'b1&&load_activA==1'b1)
              enable_iA <= 1'b1;
            else
              enable_iA <= 1'b0;
          end
      end
  end

always @( negedge clockB )
  begin
    if (resetB==1'b0)
      begin
        enable_iB <= 1'b1;
        edgedB =  1'b0;
      end
    else
      begin
        edgedB =  edgedVotedB;
        enable_iB <= enable_iVotedB;
        if (activ_iB==1'b1)
          if (edgedVotedB==1'b0)
            begin
              edgedB =  1'b1;
              enable_iB <= 1'b1;
            end
          else
            begin
              edgedB =  1'b1;
              enable_iB <= 1'b0;
            end
        else
          begin
            edgedB =  1'b0;
            if (loadB==1'b1&&load_activB==1'b1)
              enable_iB <= 1'b1;
            else
              enable_iB <= 1'b0;
          end
      end
  end

always @( negedge clockC )
  begin
    if (resetC==1'b0)
      begin
        enable_iC <= 1'b1;
        edgedC =  1'b0;
      end
    else
      begin
        edgedC =  edgedVotedC;
        enable_iC <= enable_iVotedC;
        if (activ_iC==1'b1)
          if (edgedVotedC==1'b0)
            begin
              edgedC =  1'b1;
              enable_iC <= 1'b1;
            end
          else
            begin
              edgedC =  1'b1;
              enable_iC <= 1'b0;
            end
        else
          begin
            edgedC =  1'b0;
            if (loadC==1'b1&&load_activC==1'b1)
              enable_iC <= 1'b1;
            else
              enable_iC <= 1'b0;
          end
      end
  end

majorityVoter edgedVoterA (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedA),
    .tmrErr(edgedTmrErrorA)
    );

majorityVoter enable_iVoterA (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedA),
    .tmrErr(enable_iTmrErrorA)
    );

majorityVoter edgedVoterB (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedB),
    .tmrErr(edgedTmrErrorB)
    );

majorityVoter enable_iVoterB (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedB),
    .tmrErr(enable_iTmrErrorB)
    );

majorityVoter edgedVoterC (
    .inA(edgedA),
    .inB(edgedB),
    .inC(edgedC),
    .out(edgedVotedC),
    .tmrErr(edgedTmrErrorC)
    );

majorityVoter enable_iVoterC (
    .inA(enable_iA),
    .inB(enable_iB),
    .inC(enable_iC),
    .out(enable_iVotedC),
    .tmrErr(enable_iTmrErrorC)
    );
endmodule

