/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/can_interface_sm_fsmTMR.v                                                     *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:03                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: can_interface_sm_fsm.v                                                                 *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? can_interface_sm_fsm.v) *
 *           Modification time : 2022-12-04 15:41:31.638209                                         *
 *           File Size         : 22741                                                              *
 *           MD5 hash          : 556dfcce7b3af8120f683613a4f761c5                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`resetall 
`timescale  1ns/10ps
module can_interface_SMTMR(
  input wire  abort ,
  input wire  clk ,
  input wire  end_can_proc ,
  input wire  end_cnt ,
  input wire  init ,
  input wire  reset_irq_can ,
  input wire  reset_irq_can_all ,
  input wire  rst ,
  input wire  send_mes ,
  input wire  start_osc_trim ,
  input wire  start_read ,
  input wire  start_write ,
  input wire  timeoutrst ,
  output reg [4:0] addr ,
  output reg  cs_can ,
  output reg  en_rec_reg ,
  output reg  end_init ,
  output reg  end_osc_trim ,
  output reg  end_read ,
  output reg  end_write ,
  output reg  initi ,
  output reg  read ,
  output reg  reset_all_done ,
  output reg  reset_irq_can_done ,
  output reg  reset_sig_can ,
  output reg  reset_sig_can_all ,
  output reg  rst_cnt ,
  output reg  set_bus_id ,
  output reg  start_cnt ,
  output reg  start_init ,
  output reg [6:0] statedeb ,
  output reg  trim ,
  output reg  write 
);
parameter waittoact =7'd0;
parameter reset =7'd1;
parameter start =7'd2;
parameter start1 =7'd3;
parameter ST_CountRst =7'd4;
parameter ST_Start_Cnt =7'd5;
parameter prescalar =7'd6;
parameter general =7'd7;
parameter encom =7'd8;
parameter accmask =7'd9;
parameter accmask1 =7'd10;
parameter idr31 =7'd11;
parameter idr41 =7'd12;
parameter endinit =7'd13;
parameter waitCAN =7'd14;
parameter prescalar1 =7'd15;
parameter general1 =7'd16;
parameter encom1 =7'd17;
parameter idr3 =7'd18;
parameter idr4 =7'd19;
parameter accmask2 =7'd20;
parameter accmask3 =7'd21;
parameter RB1 =7'd22;
parameter store_RB1 =7'd23;
parameter store_idr1 =7'd24;
parameter idr1 =7'd25;
parameter RB2 =7'd26;
parameter store_RB2 =7'd27;
parameter RB3 =7'd28;
parameter RB4 =7'd29;
parameter store_RB3 =7'd30;
parameter end_readst =7'd31;
parameter store_RB4 =7'd32;
parameter Wait_bits =7'd33;
parameter set_d3 =7'd34;
parameter set_d1 =7'd35;
parameter set_gen =7'd36;
parameter set_id1 =7'd37;
parameter set_tc =7'd38;
parameter set_d4 =7'd39;
parameter set_d2 =7'd40;
parameter Set_bus_Id2 =7'd41;
parameter set_gen1 =7'd42;
parameter set_id2 =7'd43;
parameter set_tc1 =7'd44;
parameter set_d5 =7'd45;
parameter set_d6 =7'd46;
parameter set_d7 =7'd47;
parameter set_d8 =7'd48;
parameter rstirq =7'd49;
parameter general2 =7'd50;
parameter general5 =7'd51;
parameter rstirq2 =7'd52;
parameter rstirq1 =7'd53;
parameter general3 =7'd54;
parameter ST_CountRst1 =7'd55;
parameter loop_rst =7'd56;
parameter general6 =7'd57;
parameter rstirq3 =7'd58;
parameter finishtrim =7'd59;
parameter ST_Start_Trim =7'd60;
parameter general4 =7'd61;
parameter id2 =7'd62;
parameter d5 =7'd63;
parameter d6 =7'd64;
parameter d7 =7'd65;
parameter d8 =7'd66;
parameter tc1 =7'd67;
parameter general7 =7'd68;
parameter id3 =7'd69;
parameter d9 =7'd70;
parameter d10 =7'd71;
parameter d11 =7'd72;
parameter d12 =7'd73;
parameter tc2 =7'd74;
wire timeoutrstC;
wire timeoutrstB;
wire timeoutrstA;
wire rstC;
wire rstB;
wire rstA;
wire [6:0] next_stateC;
wire [6:0] next_stateB;
wire [6:0] next_stateA;
wire [5:0] csm_next_timerC;
wire [5:0] csm_next_timerB;
wire [5:0] csm_next_timerA;
wire clkC;
wire clkB;
wire clkA;
wire abortC;
wire abortB;
wire abortA;
wor current_stateTmrError;
wire [6:0] current_state;
wor csm_timerTmrError;
wire [5:0] csm_timer;
reg  [6:0] current_stateA ;
reg  [6:0] current_stateB ;
reg  [6:0] current_stateC ;
reg  [6:0] next_state ;
reg  [5:0] csm_timerA ;
reg  [5:0] csm_timerB ;
reg  [5:0] csm_timerC ;
reg  [5:0] csm_next_timer ;
reg  csm_timeout ;
reg  csm_to_waitCAN ;
reg  csm_to_end_readst ;
reg  csm_to_Wait_bits ;
reg  csm_to_ST_Start_Trim ;
wire [5:0] current_stateV =  current_state;
wire [5:0] csm_timerV =  csm_timer;

always @( csm_timeout or current_state or end_cnt or init or reset_irq_can or reset_irq_can_all or rst or send_mes or start_osc_trim or start_read or start_write )
  begin : next_state_block_proc
    csm_to_waitCAN =  1'b0;
    csm_to_end_readst =  1'b0;
    csm_to_Wait_bits =  1'b0;
    csm_to_ST_Start_Trim =  1'b0;
    case (current_state)
      waittoact : 
        begin
          if (reset_irq_can==1)
            next_state =  general2;
          else
            if (start_read==1)
              begin
                next_state =  Wait_bits;
                csm_to_Wait_bits =  1'b1;
              end
            else
              if (init==1)
                next_state =  start;
              else
                if (start_write==1)
                  next_state =  Set_bus_Id2;
                else
                  if (reset_irq_can_all==1)
                    next_state =  general6;
                  else
                    if (start_osc_trim==1)
                      begin
                        next_state =  ST_Start_Trim;
                        csm_to_ST_Start_Trim =  1'b1;
                      end
                    else
                      next_state =  waittoact;
        end
      reset : 
        begin
          if (rst==1)
            next_state =  waittoact;
          else
            next_state =  reset;
        end
      start : 
        begin
          next_state =  waitCAN;
          csm_to_waitCAN =  1'b1;
        end
      start1 : 
        begin
          next_state =  general3;
        end
      ST_CountRst : 
        begin
          next_state =  endinit;
        end
      ST_Start_Cnt : 
        begin
          next_state =  start;
        end
      prescalar : 
        begin
          next_state =  prescalar1;
        end
      general : 
        begin
          next_state =  general1;
        end
      encom : 
        begin
          next_state =  encom1;
        end
      accmask : 
        begin
          next_state =  accmask3;
        end
      accmask1 : 
        begin
          if (end_cnt==1)
            next_state =  ST_CountRst;
          else
            next_state =  ST_Start_Cnt;
        end
      idr31 : 
        begin
          next_state =  idr4;
        end
      idr41 : 
        begin
          next_state =  accmask2;
        end
      endinit : 
        begin
          next_state =  waittoact;
        end
      waitCAN : 
        begin
          if (csm_timeout&&(init==1))
            next_state =  prescalar;
          else
            next_state =  waitCAN;
        end
      prescalar1 : 
        begin
          next_state =  general;
        end
      general1 : 
        begin
          next_state =  encom;
        end
      encom1 : 
        begin
          next_state =  idr3;
        end
      idr3 : 
        begin
          next_state =  idr31;
        end
      idr4 : 
        begin
          next_state =  idr41;
        end
      accmask2 : 
        begin
          next_state =  accmask;
        end
      accmask3 : 
        begin
          next_state =  accmask1;
        end
      RB1 : 
        begin
          next_state =  store_RB1;
        end
      store_RB1 : 
        begin
          next_state =  RB2;
        end
      store_idr1 : 
        begin
          next_state =  RB1;
        end
      idr1 : 
        begin
          next_state =  store_idr1;
        end
      RB2 : 
        begin
          next_state =  store_RB2;
        end
      store_RB2 : 
        begin
          next_state =  RB3;
        end
      RB3 : 
        begin
          next_state =  store_RB3;
        end
      RB4 : 
        begin
          next_state =  store_RB4;
        end
      store_RB3 : 
        begin
          next_state =  RB4;
        end
      end_readst : 
        begin
          if (csm_timeout)
            next_state =  waittoact;
          else
            next_state =  end_readst;
        end
      store_RB4 : 
        begin
          next_state =  end_readst;
          csm_to_end_readst =  1'b1;
        end
      Wait_bits : 
        begin
          if (csm_timeout)
            next_state =  idr1;
          else
            next_state =  Wait_bits;
        end
      set_d3 : 
        begin
          next_state =  set_d5;
        end
      set_d1 : 
        begin
          next_state =  set_d2;
        end
      set_gen : 
        begin
          next_state =  set_gen1;
        end
      set_id1 : 
        begin
          next_state =  set_id2;
        end
      set_tc : 
        begin
          next_state =  waittoact;
        end
      set_d4 : 
        begin
          if (send_mes==1)
            next_state =  set_tc1;
          else
            next_state =  set_d4;
        end
      set_d2 : 
        begin
          next_state =  set_d7;
        end
      Set_bus_Id2 : 
        begin
          next_state =  set_gen;
        end
      set_gen1 : 
        begin
          next_state =  set_id1;
        end
      set_id2 : 
        begin
          next_state =  set_d8;
        end
      set_tc1 : 
        begin
          next_state =  set_tc;
        end
      set_d5 : 
        begin
          next_state =  set_d4;
        end
      set_d6 : 
        begin
          next_state =  set_d3;
        end
      set_d7 : 
        begin
          next_state =  set_d6;
        end
      set_d8 : 
        begin
          next_state =  set_d1;
        end
      rstirq : 
        begin
          next_state =  rstirq2;
        end
      general2 : 
        begin
          next_state =  general5;
        end
      general5 : 
        begin
          next_state =  rstirq;
        end
      rstirq2 : 
        begin
          next_state =  waittoact;
        end
      rstirq1 : 
        begin
          next_state =  rstirq3;
        end
      general3 : 
        begin
          next_state =  rstirq1;
        end
      ST_CountRst1 : 
        begin
          next_state =  waittoact;
        end
      loop_rst : 
        begin
          if (end_cnt==1)
            next_state =  ST_CountRst1;
          else
            next_state =  start1;
        end
      general6 : 
        begin
          next_state =  general3;
        end
      rstirq3 : 
        begin
          next_state =  loop_rst;
        end
      finishtrim : 
        begin
          next_state =  waittoact;
        end
      ST_Start_Trim : 
        begin
          if (csm_timeout&&(start_osc_trim==1))
            next_state =  general4;
          else
            next_state =  ST_Start_Trim;
        end
      general4 : 
        begin
          next_state =  general7;
        end
      id2 : 
        begin
          next_state =  id3;
        end
      d5 : 
        begin
          next_state =  d9;
        end
      d6 : 
        begin
          next_state =  d10;
        end
      d7 : 
        begin
          next_state =  d11;
        end
      d8 : 
        begin
          next_state =  d12;
        end
      tc1 : 
        begin
          next_state =  tc2;
        end
      general7 : 
        begin
          next_state =  id2;
        end
      id3 : 
        begin
          next_state =  d5;
        end
      d9 : 
        begin
          next_state =  d6;
        end
      d10 : 
        begin
          next_state =  d7;
        end
      d11 : 
        begin
          next_state =  d8;
        end
      d12 : 
        begin
          if (send_mes==1)
            next_state =  tc1;
          else
            next_state =  d12;
        end
      tc2 : 
        begin
          next_state =  finishtrim;
        end
      default : next_state =  reset;
    endcase
  end

always @( current_state )
  begin : output_block_proc
    addr =  5'b11111;
    cs_can =  0;
    en_rec_reg =  0;
    end_init =  0;
    end_osc_trim =  0;
    end_read =  0;
    end_write =  0;
    initi =  0;
    read =  1;
    reset_all_done =  0;
    reset_irq_can_done =  0;
    reset_sig_can =  0;
    reset_sig_can_all =  0;
    rst_cnt =  0;
    set_bus_id =  0;
    start_cnt =  0;
    start_init =  0;
    trim =  0;
    write =  1;
    case (current_state)
      start : 
        begin
          start_init =  1;
        end
      start1 : 
        begin
          start_cnt =  1;
        end
      ST_CountRst : 
        begin
          rst_cnt =  1;
        end
      ST_Start_Cnt : 
        begin
          start_cnt =  1;
        end
      prescalar : 
        begin
          initi =  1;
          addr =  5'b01111;
          write =  0;
        end
      general : 
        begin
          initi =  1;
          addr =  5'b01110;
          write =  0;
        end
      encom : 
        begin
          initi =  1;
          addr =  5'b10010;
          write =  0;
        end
      accmask : 
        begin
          initi =  1;
          addr =  5'b10001;
          write =  0;
        end
      accmask1 : 
        begin
          initi =  1;
          addr =  5'b10000;
          write =  0;
          cs_can =  1;
        end
      idr31 : 
        begin
          addr =  5'b00101;
          initi =  1;
          write =  0;
          cs_can =  1;
        end
      idr41 : 
        begin
          initi =  1;
          addr =  5'b00100;
          write =  0;
          cs_can =  1;
        end
      endinit : 
        begin
          end_init =  1;
        end
      prescalar1 : 
        begin
          initi =  1;
          addr =  5'b01111;
          write =  0;
          cs_can =  1;
        end
      general1 : 
        begin
          initi =  1;
          addr =  5'b01110;
          write =  0;
          cs_can =  1;
        end
      encom1 : 
        begin
          initi =  1;
          addr =  5'b10010;
          write =  0;
          cs_can =  1;
        end
      idr3 : 
        begin
          addr =  5'b00101;
          initi =  1;
          write =  0;
        end
      idr4 : 
        begin
          initi =  1;
          addr =  5'b00100;
          write =  0;
        end
      accmask2 : 
        begin
          initi =  1;
          addr =  5'b10001;
          write =  0;
        end
      accmask3 : 
        begin
          initi =  1;
          addr =  5'b10000;
          write =  0;
          cs_can =  1;
        end
      RB1 : 
        begin
          read =  0;
          addr =  5'b00011;
          cs_can =  1;
        end
      store_RB1 : 
        begin
          read =  0;
          addr =  5'b00011;
          cs_can =  1;
          en_rec_reg =  1;
        end
      store_idr1 : 
        begin
          read =  0;
          addr =  5'b00101;
          cs_can =  1;
          en_rec_reg =  1;
        end
      idr1 : 
        begin
          read =  0;
          addr =  5'b00101;
          cs_can =  1;
        end
      RB2 : 
        begin
          read =  0;
          addr =  5'b00010;
          cs_can =  1;
        end
      store_RB2 : 
        begin
          read =  0;
          addr =  5'b00010;
          cs_can =  1;
          en_rec_reg =  1;
        end
      RB3 : 
        begin
          read =  0;
          addr =  5'b00001;
          cs_can =  1;
        end
      RB4 : 
        begin
          read =  0;
          addr =  5'b00000;
          cs_can =  1;
        end
      store_RB3 : 
        begin
          read =  0;
          addr =  5'b00001;
          cs_can =  1;
          en_rec_reg =  1;
        end
      end_readst : 
        begin
          end_read =  1;
          addr =  5'b11111;
        end
      store_RB4 : 
        begin
          read =  0;
          addr =  5'b00000;
          cs_can =  1;
          en_rec_reg =  1;
        end
      set_d3 : 
        begin
          write =  0;
          addr =  5'b01000;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_d1 : 
        begin
          write =  0;
          addr =  5'b01010;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_gen : 
        begin
          write =  0;
          addr =  5'b01110;
          set_bus_id =  1;
        end
      set_id1 : 
        begin
          write =  0;
          addr =  5'b01100;
          set_bus_id =  1;
        end
      set_tc : 
        begin
          write =  0;
          addr =  5'b01101;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_d4 : 
        begin
          write =  0;
          addr =  5'b00111;
          cs_can =  1;
          end_write =  1;
          set_bus_id =  1;
        end
      set_d2 : 
        begin
          write =  0;
          addr =  5'b01001;
          set_bus_id =  1;
        end
      Set_bus_Id2 : 
        begin
          set_bus_id =  1;
        end
      set_gen1 : 
        begin
          write =  0;
          addr =  5'b01110;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_id2 : 
        begin
          write =  0;
          addr =  5'b01100;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_tc1 : 
        begin
          write =  0;
          addr =  5'b01101;
          set_bus_id =  1;
        end
      set_d5 : 
        begin
          write =  0;
          addr =  5'b00111;
          end_write =  1;
          set_bus_id =  1;
        end
      set_d6 : 
        begin
          write =  0;
          addr =  5'b01000;
          set_bus_id =  1;
        end
      set_d7 : 
        begin
          write =  0;
          addr =  5'b01001;
          cs_can =  1;
          set_bus_id =  1;
        end
      set_d8 : 
        begin
          write =  0;
          addr =  5'b01010;
          set_bus_id =  1;
        end
      rstirq : 
        begin
          write =  0;
          reset_sig_can =  1;
          addr =  5'b10010;
        end
      general2 : 
        begin
          write =  0;
          reset_sig_can =  1;
          addr =  5'b01110;
        end
      general5 : 
        begin
          write =  0;
          reset_sig_can =  1;
          cs_can =  1;
          addr =  5'b01110;
        end
      rstirq2 : 
        begin
          write =  0;
          reset_sig_can =  1;
          cs_can =  1;
          addr =  5'b10010;
          reset_irq_can_done =  1;
        end
      rstirq1 : 
        begin
          write =  0;
          addr =  5'b10010;
          reset_sig_can =  1;
          reset_sig_can_all =  1;
        end
      general3 : 
        begin
          write =  0;
          cs_can =  1;
          addr =  5'b01110;
          reset_sig_can =  1;
          reset_sig_can_all =  1;
        end
      ST_CountRst1 : 
        begin
          rst_cnt =  1;
          reset_all_done =  1;
        end
      general6 : 
        begin
          write =  0;
          addr =  5'b01110;
          reset_sig_can =  1;
          reset_sig_can_all =  1;
        end
      rstirq3 : 
        begin
          write =  0;
          cs_can =  1;
          addr =  5'b10010;
          reset_sig_can =  1;
          reset_sig_can_all =  1;
        end
      finishtrim : 
        begin
          end_osc_trim =  1;
        end
      general4 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01110;
        end
      id2 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01100;
        end
      d5 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01010;
        end
      d6 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01001;
        end
      d7 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01000;
        end
      d8 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b00111;
          end_write =  1;
        end
      tc1 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01101;
        end
      general7 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01110;
          cs_can =  1;
        end
      id3 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01100;
          cs_can =  1;
        end
      d9 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01010;
          cs_can =  1;
        end
      d10 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01001;
          cs_can =  1;
        end
      d11 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01000;
          cs_can =  1;
        end
      d12 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b00111;
          end_write =  1;
          cs_can =  1;
        end
      tc2 : 
        begin
          write =  0;
          trim =  1;
          addr =  5'b01101;
          cs_can =  1;
        end
    endcase
  end

always @( posedge clkA )
  begin : clocked_block_procA
    if (!rstA)
      begin
        current_stateA <= reset;
        csm_timerA <= 6'd0;
      end
    else
      if (timeoutrstA)
        begin
          current_stateA <= reset;
          csm_timerA <= 6'd0;
        end
      else
        if (abortA)
          begin
            current_stateA <= reset;
            csm_timerA <= 6'd0;
          end
        else
          begin
            current_stateA <= next_stateA;
            csm_timerA <= csm_next_timerA;
          end
  end

always @( posedge clkB )
  begin : clocked_block_procB
    if (!rstB)
      begin
        current_stateB <= reset;
        csm_timerB <= 6'd0;
      end
    else
      if (timeoutrstB)
        begin
          current_stateB <= reset;
          csm_timerB <= 6'd0;
        end
      else
        if (abortB)
          begin
            current_stateB <= reset;
            csm_timerB <= 6'd0;
          end
        else
          begin
            current_stateB <= next_stateB;
            csm_timerB <= csm_next_timerB;
          end
  end

always @( posedge clkC )
  begin : clocked_block_procC
    if (!rstC)
      begin
        current_stateC <= reset;
        csm_timerC <= 6'd0;
      end
    else
      if (timeoutrstC)
        begin
          current_stateC <= reset;
          csm_timerC <= 6'd0;
        end
      else
        if (abortC)
          begin
            current_stateC <= reset;
            csm_timerC <= 6'd0;
          end
        else
          begin
            current_stateC <= next_stateC;
            csm_timerC <= csm_next_timerC;
          end
  end

always @( csm_timer or csm_to_waitCAN or csm_to_end_readst or csm_to_Wait_bits or csm_to_ST_Start_Trim )
  begin : csm_wait_block_proc
    csm_timeout =  (csm_timer==6'd0);
    if (csm_to_waitCAN==1'b1)
      begin
        csm_next_timer =  6'd9;
      end
    else
      if (csm_to_end_readst==1'b1)
        begin
          csm_next_timer =  6'd3;
        end
      else
        if (csm_to_Wait_bits==1'b1)
          begin
            csm_next_timer =  6'd19;
          end
        else
          if (csm_to_ST_Start_Trim==1'b1)
            begin
              csm_next_timer =  6'd59;
            end
          else
            begin
              csm_next_timer =  (csm_timeout) ? 6'd0 : (csm_timer-6'd1);
            end
  end

always @( current_state )
  statedeb =  current_state;

majorityVoter #(.WIDTH(6)) csm_timerVoter (
    .inA(csm_timerA),
    .inB(csm_timerB),
    .inC(csm_timerC),
    .out(csm_timer),
    .tmrErr(csm_timerTmrError)
    );

majorityVoter #(.WIDTH(7)) current_stateVoter (
    .inA(current_stateA),
    .inB(current_stateB),
    .inC(current_stateC),
    .out(current_state),
    .tmrErr(current_stateTmrError)
    );

fanout abortFanout (
    .in(abort),
    .outA(abortA),
    .outB(abortB),
    .outC(abortC)
    );

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout #(.WIDTH(6)) csm_next_timerFanout (
    .in(csm_next_timer),
    .outA(csm_next_timerA),
    .outB(csm_next_timerB),
    .outC(csm_next_timerC)
    );

fanout #(.WIDTH(7)) next_stateFanout (
    .in(next_state),
    .outA(next_stateA),
    .outB(next_stateB),
    .outC(next_stateC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );

fanout timeoutrstFanout (
    .in(timeoutrst),
    .outA(timeoutrstA),
    .outB(timeoutrstB),
    .outC(timeoutrstC)
    );
endmodule

