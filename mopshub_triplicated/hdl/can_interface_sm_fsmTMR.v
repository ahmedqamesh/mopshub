/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/can_interface_sm_fsmTMR.v                                                     *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 03/04/2022 20:08:32                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/triplicated/mopshub_top_canakari_ftrim/hdl *
 * cmd     : /mnt/c/Users/Lucas/Desktop/mopshub_triplication/tmrg-master/bin/tmrg -vv -c tmrg.cfg   *
 * tmrg rev:                                                                                        *
 *                                                                                                  *
 * src file: can_interface_sm_fsm.v                                                                 *
 *           Git SHA           : File not in git repository!                                        *
 *           Modification time : 2022-03-28 21:55:50                                                *
 *           File Size         : 16718                                                              *
 *           MD5 hash          : 3d3277ff9b467294dab808130f034bf2                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module can_interface_SMTMR(
  input wire  abortA ,
  input wire  abortB ,
  input wire  abortC ,
  input wire  clkA ,
  input wire  clkB ,
  input wire  clkC ,
  input wire  end_can_procA ,
  input wire  end_can_procB ,
  input wire  end_can_procC ,
  input wire  end_cntA ,
  input wire  end_cntB ,
  input wire  end_cntC ,
  input wire  initA ,
  input wire  initB ,
  input wire  initC ,
  input wire  reset_irq_canA ,
  input wire  reset_irq_canB ,
  input wire  reset_irq_canC ,
  input wire  reset_irq_can_allA ,
  input wire  reset_irq_can_allB ,
  input wire  reset_irq_can_allC ,
  input wire  rstA ,
  input wire  rstB ,
  input wire  rstC ,
  input wire  send_mesA ,
  input wire  send_mesB ,
  input wire  send_mesC ,
  input wire  start_osc_trimA ,
  input wire  start_osc_trimB ,
  input wire  start_osc_trimC ,
  input wire  start_readA ,
  input wire  start_readB ,
  input wire  start_readC ,
  input wire  start_writeA ,
  input wire  start_writeB ,
  input wire  start_writeC ,
  input wire  timeoutrstA ,
  input wire  timeoutrstB ,
  input wire  timeoutrstC ,
  output reg [4:0] addrA ,
  output reg [4:0] addrB ,
  output reg [4:0] addrC ,
  output reg  cs_canA ,
  output reg  cs_canB ,
  output reg  cs_canC ,
  output reg  en_rec_regA ,
  output reg  en_rec_regB ,
  output reg  en_rec_regC ,
  output reg  end_initA ,
  output reg  end_initB ,
  output reg  end_initC ,
  output reg  end_osc_trimA ,
  output reg  end_osc_trimB ,
  output reg  end_osc_trimC ,
  output reg  end_readA ,
  output reg  end_readB ,
  output reg  end_readC ,
  output reg  end_writeA ,
  output reg  end_writeB ,
  output reg  end_writeC ,
  output reg  initiA ,
  output reg  initiB ,
  output reg  initiC ,
  output reg  readA ,
  output reg  readB ,
  output reg  readC ,
  output reg  reset_all_doneA ,
  output reg  reset_all_doneB ,
  output reg  reset_all_doneC ,
  output reg  reset_irq_can_doneA ,
  output reg  reset_irq_can_doneB ,
  output reg  reset_irq_can_doneC ,
  output reg  reset_sig_canA ,
  output reg  reset_sig_canB ,
  output reg  reset_sig_canC ,
  output reg  reset_sig_can_allA ,
  output reg  reset_sig_can_allB ,
  output reg  reset_sig_can_allC ,
  output reg  rst_cntA ,
  output reg  rst_cntB ,
  output reg  rst_cntC ,
  output reg  set_bus_idA ,
  output reg  set_bus_idB ,
  output reg  set_bus_idC ,
  output reg  start_cntA ,
  output reg  start_cntB ,
  output reg  start_cntC ,
  output reg  start_initA ,
  output reg  start_initB ,
  output reg  start_initC ,
  output reg [5:0] statedebA ,
  output reg [5:0] statedebB ,
  output reg [5:0] statedebC ,
  output reg  trimA ,
  output reg  trimB ,
  output reg  trimC ,
  output reg  writeA ,
  output reg  writeB ,
  output reg  writeC 
);
parameter waittoact =6'd0;
parameter reset =6'd1;
parameter prescalar =6'd2;
parameter general =6'd3;
parameter encom =6'd4;
parameter accmask =6'd5;
parameter accmask1 =6'd6;
parameter idr3 =6'd7;
parameter idr4 =6'd8;
parameter endinit =6'd9;
parameter start =6'd10;
parameter waitCAN =6'd11;
parameter RB1 =6'd12;
parameter store_RB1 =6'd13;
parameter store_idr1 =6'd14;
parameter idr1 =6'd15;
parameter RB2 =6'd16;
parameter store_RB2 =6'd17;
parameter RB3 =6'd18;
parameter RB4 =6'd19;
parameter store_RB3 =6'd20;
parameter end_readst =6'd21;
parameter store_RB4 =6'd22;
parameter set_d3 =6'd23;
parameter set_d1 =6'd24;
parameter set_gen =6'd25;
parameter rstirq =6'd26;
parameter general2 =6'd27;
parameter ST_CountRst =6'd28;
parameter rstirq1 =6'd29;
parameter general3 =6'd30;
parameter start1 =6'd31;
parameter ST_CountRst1 =6'd32;
parameter loop_rst =6'd33;
parameter ST_Start_Cnt =6'd34;
parameter finishtrim =6'd35;
parameter ST_Start_Trim =6'd36;
parameter general4 =6'd37;
parameter id2 =6'd38;
parameter d5 =6'd39;
parameter d6 =6'd40;
parameter d7 =6'd41;
parameter d8 =6'd42;
parameter tc1 =6'd43;
parameter set_id1 =6'd44;
parameter set_tc =6'd45;
parameter set_d4 =6'd46;
parameter set_d2 =6'd47;
parameter Set_bus_Id2 =6'd48;
parameter Wait_bits =6'd49;
reg  [5:0] current_stateA ;
reg  [5:0] next_stateA ;
reg  [5:0] current_stateB ;
reg  [5:0] next_stateB ;
reg  [5:0] current_stateC ;
reg  [5:0] next_stateC ;
reg  [7:0] csm_timerA ;
reg  [7:0] csm_timerB ;
reg  [7:0] csm_timerC ;
reg  [7:0] csm_next_timerA ;
reg  [7:0] csm_next_timerB ;
reg  [7:0] csm_next_timerC ;
reg  csm_timeoutA ;
reg  csm_timeoutB ;
reg  csm_timeoutC ;
reg  csm_to_waitCANA ;
reg  csm_to_waitCANB ;
reg  csm_to_waitCANC ;
reg  csm_to_end_readstA ;
reg  csm_to_end_readstB ;
reg  csm_to_end_readstC ;
reg  csm_to_ST_Start_TrimA ;
reg  csm_to_ST_Start_TrimB ;
reg  csm_to_ST_Start_TrimC ;
reg  csm_to_Wait_bitsA ;
reg  csm_to_Wait_bitsB ;
reg  csm_to_Wait_bitsC ;

always @( csm_timeoutA or current_stateA or end_cntA or initA or reset_irq_canA or reset_irq_can_allA or rstA or send_mesA or start_osc_trimA or start_readA or start_writeA )
  begin : next_state_block_procA
    csm_to_waitCANA =  1'b0;
    csm_to_end_readstA =  1'b0;
    csm_to_ST_Start_TrimA =  1'b0;
    csm_to_Wait_bitsA =  1'b0;
    case (current_stateA)
      waittoact : 
        begin
          if (reset_irq_canA==1)
            next_stateA =  general2;
          else
            if (start_readA==1)
              begin
                next_stateA =  Wait_bits;
                csm_to_Wait_bitsA =  1'b1;
              end
            else
              if (initA==1)
                next_stateA =  start;
              else
                if (start_writeA==1)
                  next_stateA =  Set_bus_Id2;
                else
                  if (reset_irq_can_allA==1)
                    next_stateA =  general3;
                  else
                    if (start_osc_trimA==1)
                      begin
                        next_stateA =  ST_Start_Trim;
                        csm_to_ST_Start_TrimA =  1'b1;
                      end
                    else
                      next_stateA =  waittoact;
        end
      reset : 
        begin
          if (rstA==1)
            next_stateA =  waittoact;
          else
            next_stateA =  reset;
        end
      prescalar : 
        begin
          next_stateA =  general;
        end
      general : 
        begin
          next_stateA =  encom;
        end
      encom : 
        begin
          next_stateA =  idr3;
        end
      accmask : 
        begin
          next_stateA =  accmask1;
        end
      accmask1 : 
        begin
          if (end_cntA==1)
            next_stateA =  ST_CountRst;
          else
            next_stateA =  ST_Start_Cnt;
        end
      idr3 : 
        begin
          next_stateA =  idr4;
        end
      idr4 : 
        begin
          next_stateA =  accmask;
        end
      endinit : 
        begin
          next_stateA =  waittoact;
        end
      start : 
        begin
          next_stateA =  waitCAN;
          csm_to_waitCANA =  1'b1;
        end
      waitCAN : 
        begin
          if (csm_timeoutA&&(initA==1))
            next_stateA =  prescalar;
          else
            next_stateA =  waitCAN;
        end
      RB1 : 
        begin
          next_stateA =  store_RB1;
        end
      store_RB1 : 
        begin
          next_stateA =  RB2;
        end
      store_idr1 : 
        begin
          next_stateA =  RB1;
        end
      idr1 : 
        begin
          next_stateA =  store_idr1;
        end
      RB2 : 
        begin
          next_stateA =  store_RB2;
        end
      store_RB2 : 
        begin
          next_stateA =  RB3;
        end
      RB3 : 
        begin
          next_stateA =  store_RB3;
        end
      RB4 : 
        begin
          next_stateA =  store_RB4;
        end
      store_RB3 : 
        begin
          next_stateA =  RB4;
        end
      end_readst : 
        begin
          if (csm_timeoutA)
            next_stateA =  waittoact;
          else
            next_stateA =  end_readst;
        end
      store_RB4 : 
        begin
          next_stateA =  end_readst;
          csm_to_end_readstA =  1'b1;
        end
      set_d3 : 
        begin
          next_stateA =  set_d4;
        end
      set_d1 : 
        begin
          next_stateA =  set_d2;
        end
      set_gen : 
        begin
          next_stateA =  set_id1;
        end
      rstirq : 
        begin
          next_stateA =  waittoact;
        end
      general2 : 
        begin
          next_stateA =  rstirq;
        end
      ST_CountRst : 
        begin
          next_stateA =  endinit;
        end
      rstirq1 : 
        begin
          next_stateA =  loop_rst;
        end
      general3 : 
        begin
          next_stateA =  rstirq1;
        end
      start1 : 
        begin
          next_stateA =  general3;
        end
      ST_CountRst1 : 
        begin
          next_stateA =  waittoact;
        end
      loop_rst : 
        begin
          if (end_cntA==1)
            next_stateA =  ST_CountRst1;
          else
            next_stateA =  start1;
        end
      ST_Start_Cnt : 
        begin
          next_stateA =  start;
        end
      finishtrim : 
        begin
          next_stateA =  waittoact;
        end
      ST_Start_Trim : 
        begin
          if (csm_timeoutA&&(start_osc_trimA==1))
            next_stateA =  general4;
          else
            next_stateA =  ST_Start_Trim;
        end
      general4 : 
        begin
          next_stateA =  id2;
        end
      id2 : 
        begin
          next_stateA =  d5;
        end
      d5 : 
        begin
          next_stateA =  d6;
        end
      d6 : 
        begin
          next_stateA =  d7;
        end
      d7 : 
        begin
          next_stateA =  d8;
        end
      d8 : 
        begin
          if (send_mesA==1)
            next_stateA =  tc1;
          else
            next_stateA =  d8;
        end
      tc1 : 
        begin
          next_stateA =  finishtrim;
        end
      set_id1 : 
        begin
          next_stateA =  set_d1;
        end
      set_tc : 
        begin
          next_stateA =  waittoact;
        end
      set_d4 : 
        begin
          if (send_mesA==1)
            next_stateA =  set_tc;
          else
            next_stateA =  set_d4;
        end
      set_d2 : 
        begin
          next_stateA =  set_d3;
        end
      Set_bus_Id2 : 
        begin
          next_stateA =  set_gen;
        end
      Wait_bits : 
        begin
          if (csm_timeoutA)
            next_stateA =  idr1;
          else
            next_stateA =  Wait_bits;
        end
      default : next_stateA =  reset;
    endcase
  end

always @( csm_timeoutB or current_stateB or end_cntB or initB or reset_irq_canB or reset_irq_can_allB or rstB or send_mesB or start_osc_trimB or start_readB or start_writeB )
  begin : next_state_block_procB
    csm_to_waitCANB =  1'b0;
    csm_to_end_readstB =  1'b0;
    csm_to_ST_Start_TrimB =  1'b0;
    csm_to_Wait_bitsB =  1'b0;
    case (current_stateB)
      waittoact : 
        begin
          if (reset_irq_canB==1)
            next_stateB =  general2;
          else
            if (start_readB==1)
              begin
                next_stateB =  Wait_bits;
                csm_to_Wait_bitsB =  1'b1;
              end
            else
              if (initB==1)
                next_stateB =  start;
              else
                if (start_writeB==1)
                  next_stateB =  Set_bus_Id2;
                else
                  if (reset_irq_can_allB==1)
                    next_stateB =  general3;
                  else
                    if (start_osc_trimB==1)
                      begin
                        next_stateB =  ST_Start_Trim;
                        csm_to_ST_Start_TrimB =  1'b1;
                      end
                    else
                      next_stateB =  waittoact;
        end
      reset : 
        begin
          if (rstB==1)
            next_stateB =  waittoact;
          else
            next_stateB =  reset;
        end
      prescalar : 
        begin
          next_stateB =  general;
        end
      general : 
        begin
          next_stateB =  encom;
        end
      encom : 
        begin
          next_stateB =  idr3;
        end
      accmask : 
        begin
          next_stateB =  accmask1;
        end
      accmask1 : 
        begin
          if (end_cntB==1)
            next_stateB =  ST_CountRst;
          else
            next_stateB =  ST_Start_Cnt;
        end
      idr3 : 
        begin
          next_stateB =  idr4;
        end
      idr4 : 
        begin
          next_stateB =  accmask;
        end
      endinit : 
        begin
          next_stateB =  waittoact;
        end
      start : 
        begin
          next_stateB =  waitCAN;
          csm_to_waitCANB =  1'b1;
        end
      waitCAN : 
        begin
          if (csm_timeoutB&&(initB==1))
            next_stateB =  prescalar;
          else
            next_stateB =  waitCAN;
        end
      RB1 : 
        begin
          next_stateB =  store_RB1;
        end
      store_RB1 : 
        begin
          next_stateB =  RB2;
        end
      store_idr1 : 
        begin
          next_stateB =  RB1;
        end
      idr1 : 
        begin
          next_stateB =  store_idr1;
        end
      RB2 : 
        begin
          next_stateB =  store_RB2;
        end
      store_RB2 : 
        begin
          next_stateB =  RB3;
        end
      RB3 : 
        begin
          next_stateB =  store_RB3;
        end
      RB4 : 
        begin
          next_stateB =  store_RB4;
        end
      store_RB3 : 
        begin
          next_stateB =  RB4;
        end
      end_readst : 
        begin
          if (csm_timeoutB)
            next_stateB =  waittoact;
          else
            next_stateB =  end_readst;
        end
      store_RB4 : 
        begin
          next_stateB =  end_readst;
          csm_to_end_readstB =  1'b1;
        end
      set_d3 : 
        begin
          next_stateB =  set_d4;
        end
      set_d1 : 
        begin
          next_stateB =  set_d2;
        end
      set_gen : 
        begin
          next_stateB =  set_id1;
        end
      rstirq : 
        begin
          next_stateB =  waittoact;
        end
      general2 : 
        begin
          next_stateB =  rstirq;
        end
      ST_CountRst : 
        begin
          next_stateB =  endinit;
        end
      rstirq1 : 
        begin
          next_stateB =  loop_rst;
        end
      general3 : 
        begin
          next_stateB =  rstirq1;
        end
      start1 : 
        begin
          next_stateB =  general3;
        end
      ST_CountRst1 : 
        begin
          next_stateB =  waittoact;
        end
      loop_rst : 
        begin
          if (end_cntB==1)
            next_stateB =  ST_CountRst1;
          else
            next_stateB =  start1;
        end
      ST_Start_Cnt : 
        begin
          next_stateB =  start;
        end
      finishtrim : 
        begin
          next_stateB =  waittoact;
        end
      ST_Start_Trim : 
        begin
          if (csm_timeoutB&&(start_osc_trimB==1))
            next_stateB =  general4;
          else
            next_stateB =  ST_Start_Trim;
        end
      general4 : 
        begin
          next_stateB =  id2;
        end
      id2 : 
        begin
          next_stateB =  d5;
        end
      d5 : 
        begin
          next_stateB =  d6;
        end
      d6 : 
        begin
          next_stateB =  d7;
        end
      d7 : 
        begin
          next_stateB =  d8;
        end
      d8 : 
        begin
          if (send_mesB==1)
            next_stateB =  tc1;
          else
            next_stateB =  d8;
        end
      tc1 : 
        begin
          next_stateB =  finishtrim;
        end
      set_id1 : 
        begin
          next_stateB =  set_d1;
        end
      set_tc : 
        begin
          next_stateB =  waittoact;
        end
      set_d4 : 
        begin
          if (send_mesB==1)
            next_stateB =  set_tc;
          else
            next_stateB =  set_d4;
        end
      set_d2 : 
        begin
          next_stateB =  set_d3;
        end
      Set_bus_Id2 : 
        begin
          next_stateB =  set_gen;
        end
      Wait_bits : 
        begin
          if (csm_timeoutB)
            next_stateB =  idr1;
          else
            next_stateB =  Wait_bits;
        end
      default : next_stateB =  reset;
    endcase
  end

always @( csm_timeoutC or current_stateC or end_cntC or initC or reset_irq_canC or reset_irq_can_allC or rstC or send_mesC or start_osc_trimC or start_readC or start_writeC )
  begin : next_state_block_procC
    csm_to_waitCANC =  1'b0;
    csm_to_end_readstC =  1'b0;
    csm_to_ST_Start_TrimC =  1'b0;
    csm_to_Wait_bitsC =  1'b0;
    case (current_stateC)
      waittoact : 
        begin
          if (reset_irq_canC==1)
            next_stateC =  general2;
          else
            if (start_readC==1)
              begin
                next_stateC =  Wait_bits;
                csm_to_Wait_bitsC =  1'b1;
              end
            else
              if (initC==1)
                next_stateC =  start;
              else
                if (start_writeC==1)
                  next_stateC =  Set_bus_Id2;
                else
                  if (reset_irq_can_allC==1)
                    next_stateC =  general3;
                  else
                    if (start_osc_trimC==1)
                      begin
                        next_stateC =  ST_Start_Trim;
                        csm_to_ST_Start_TrimC =  1'b1;
                      end
                    else
                      next_stateC =  waittoact;
        end
      reset : 
        begin
          if (rstC==1)
            next_stateC =  waittoact;
          else
            next_stateC =  reset;
        end
      prescalar : 
        begin
          next_stateC =  general;
        end
      general : 
        begin
          next_stateC =  encom;
        end
      encom : 
        begin
          next_stateC =  idr3;
        end
      accmask : 
        begin
          next_stateC =  accmask1;
        end
      accmask1 : 
        begin
          if (end_cntC==1)
            next_stateC =  ST_CountRst;
          else
            next_stateC =  ST_Start_Cnt;
        end
      idr3 : 
        begin
          next_stateC =  idr4;
        end
      idr4 : 
        begin
          next_stateC =  accmask;
        end
      endinit : 
        begin
          next_stateC =  waittoact;
        end
      start : 
        begin
          next_stateC =  waitCAN;
          csm_to_waitCANC =  1'b1;
        end
      waitCAN : 
        begin
          if (csm_timeoutC&&(initC==1))
            next_stateC =  prescalar;
          else
            next_stateC =  waitCAN;
        end
      RB1 : 
        begin
          next_stateC =  store_RB1;
        end
      store_RB1 : 
        begin
          next_stateC =  RB2;
        end
      store_idr1 : 
        begin
          next_stateC =  RB1;
        end
      idr1 : 
        begin
          next_stateC =  store_idr1;
        end
      RB2 : 
        begin
          next_stateC =  store_RB2;
        end
      store_RB2 : 
        begin
          next_stateC =  RB3;
        end
      RB3 : 
        begin
          next_stateC =  store_RB3;
        end
      RB4 : 
        begin
          next_stateC =  store_RB4;
        end
      store_RB3 : 
        begin
          next_stateC =  RB4;
        end
      end_readst : 
        begin
          if (csm_timeoutC)
            next_stateC =  waittoact;
          else
            next_stateC =  end_readst;
        end
      store_RB4 : 
        begin
          next_stateC =  end_readst;
          csm_to_end_readstC =  1'b1;
        end
      set_d3 : 
        begin
          next_stateC =  set_d4;
        end
      set_d1 : 
        begin
          next_stateC =  set_d2;
        end
      set_gen : 
        begin
          next_stateC =  set_id1;
        end
      rstirq : 
        begin
          next_stateC =  waittoact;
        end
      general2 : 
        begin
          next_stateC =  rstirq;
        end
      ST_CountRst : 
        begin
          next_stateC =  endinit;
        end
      rstirq1 : 
        begin
          next_stateC =  loop_rst;
        end
      general3 : 
        begin
          next_stateC =  rstirq1;
        end
      start1 : 
        begin
          next_stateC =  general3;
        end
      ST_CountRst1 : 
        begin
          next_stateC =  waittoact;
        end
      loop_rst : 
        begin
          if (end_cntC==1)
            next_stateC =  ST_CountRst1;
          else
            next_stateC =  start1;
        end
      ST_Start_Cnt : 
        begin
          next_stateC =  start;
        end
      finishtrim : 
        begin
          next_stateC =  waittoact;
        end
      ST_Start_Trim : 
        begin
          if (csm_timeoutC&&(start_osc_trimC==1))
            next_stateC =  general4;
          else
            next_stateC =  ST_Start_Trim;
        end
      general4 : 
        begin
          next_stateC =  id2;
        end
      id2 : 
        begin
          next_stateC =  d5;
        end
      d5 : 
        begin
          next_stateC =  d6;
        end
      d6 : 
        begin
          next_stateC =  d7;
        end
      d7 : 
        begin
          next_stateC =  d8;
        end
      d8 : 
        begin
          if (send_mesC==1)
            next_stateC =  tc1;
          else
            next_stateC =  d8;
        end
      tc1 : 
        begin
          next_stateC =  finishtrim;
        end
      set_id1 : 
        begin
          next_stateC =  set_d1;
        end
      set_tc : 
        begin
          next_stateC =  waittoact;
        end
      set_d4 : 
        begin
          if (send_mesC==1)
            next_stateC =  set_tc;
          else
            next_stateC =  set_d4;
        end
      set_d2 : 
        begin
          next_stateC =  set_d3;
        end
      Set_bus_Id2 : 
        begin
          next_stateC =  set_gen;
        end
      Wait_bits : 
        begin
          if (csm_timeoutC)
            next_stateC =  idr1;
          else
            next_stateC =  Wait_bits;
        end
      default : next_stateC =  reset;
    endcase
  end

always @( current_stateA )
  begin : output_block_procA
    addrA =  5'b11111;
    cs_canA =  0;
    en_rec_regA =  0;
    end_initA =  0;
    end_osc_trimA =  0;
    end_readA =  0;
    end_writeA =  0;
    initiA =  0;
    readA =  1;
    reset_all_doneA =  0;
    reset_irq_can_doneA =  0;
    reset_sig_canA =  0;
    reset_sig_can_allA =  0;
    rst_cntA =  0;
    set_bus_idA =  0;
    start_cntA =  0;
    start_initA =  0;
    trimA =  0;
    writeA =  1;
    case (current_stateA)
      prescalar : 
        begin
          initiA =  1;
          addrA =  5'b01111;
          writeA =  0;
          cs_canA =  1;
        end
      general : 
        begin
          initiA =  1;
          addrA =  5'b01110;
          writeA =  0;
          cs_canA =  1;
        end
      encom : 
        begin
          initiA =  1;
          addrA =  5'b10010;
          writeA =  0;
          cs_canA =  1;
        end
      accmask : 
        begin
          initiA =  1;
          addrA =  5'b10001;
          writeA =  0;
          cs_canA =  1;
        end
      accmask1 : 
        begin
          initiA =  1;
          addrA =  5'b10000;
          writeA =  0;
          cs_canA =  1;
        end
      idr3 : 
        begin
          addrA =  5'b00101;
          initiA =  1;
          writeA =  0;
          cs_canA =  1;
        end
      idr4 : 
        begin
          initiA =  1;
          addrA =  5'b00100;
          writeA =  0;
          cs_canA =  1;
        end
      endinit : 
        begin
          end_initA =  1;
        end
      start : 
        begin
          start_initA =  1;
        end
      RB1 : 
        begin
          readA =  0;
          addrA =  5'b00011;
          cs_canA =  1;
        end
      store_RB1 : 
        begin
          readA =  0;
          addrA =  5'b00011;
          cs_canA =  1;
          en_rec_regA =  1;
        end
      store_idr1 : 
        begin
          readA =  0;
          addrA =  5'b00101;
          cs_canA =  1;
          en_rec_regA =  1;
        end
      idr1 : 
        begin
          readA =  0;
          addrA =  5'b00101;
          cs_canA =  1;
        end
      RB2 : 
        begin
          readA =  0;
          addrA =  5'b00010;
          cs_canA =  1;
        end
      store_RB2 : 
        begin
          readA =  0;
          addrA =  5'b00010;
          cs_canA =  1;
          en_rec_regA =  1;
        end
      RB3 : 
        begin
          readA =  0;
          addrA =  5'b00001;
          cs_canA =  1;
        end
      RB4 : 
        begin
          readA =  0;
          addrA =  5'b00000;
          cs_canA =  1;
        end
      store_RB3 : 
        begin
          readA =  0;
          addrA =  5'b00001;
          cs_canA =  1;
          en_rec_regA =  1;
        end
      end_readst : 
        begin
          end_readA =  1;
          addrA =  5'b11111;
        end
      store_RB4 : 
        begin
          readA =  0;
          addrA =  5'b00000;
          cs_canA =  1;
          en_rec_regA =  1;
        end
      set_d3 : 
        begin
          writeA =  0;
          addrA =  5'b01000;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      set_d1 : 
        begin
          writeA =  0;
          addrA =  5'b01010;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      set_gen : 
        begin
          writeA =  0;
          addrA =  5'b01110;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      rstirq : 
        begin
          writeA =  0;
          reset_sig_canA =  1;
          cs_canA =  1;
          addrA =  5'b10010;
          reset_irq_can_doneA =  1;
        end
      general2 : 
        begin
          writeA =  0;
          reset_sig_canA =  1;
          cs_canA =  1;
          addrA =  5'b01110;
        end
      ST_CountRst : 
        begin
          rst_cntA =  1;
        end
      rstirq1 : 
        begin
          writeA =  0;
          cs_canA =  1;
          addrA =  5'b10010;
          reset_sig_canA =  1;
          reset_sig_can_allA =  1;
        end
      general3 : 
        begin
          writeA =  0;
          cs_canA =  1;
          addrA =  5'b01110;
          reset_sig_canA =  1;
          reset_sig_can_allA =  1;
        end
      start1 : 
        begin
          start_cntA =  1;
        end
      ST_CountRst1 : 
        begin
          rst_cntA =  1;
          reset_all_doneA =  1;
        end
      ST_Start_Cnt : 
        begin
          start_cntA =  1;
        end
      finishtrim : 
        begin
          end_osc_trimA =  1;
        end
      general4 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01110;
          cs_canA =  1;
        end
      id2 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01100;
          cs_canA =  1;
        end
      d5 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01010;
          cs_canA =  1;
        end
      d6 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01001;
          cs_canA =  1;
        end
      d7 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01000;
          cs_canA =  1;
        end
      d8 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b00111;
          end_writeA =  1;
          cs_canA =  1;
        end
      tc1 : 
        begin
          writeA =  0;
          trimA =  1;
          addrA =  5'b01101;
          cs_canA =  1;
        end
      set_id1 : 
        begin
          writeA =  0;
          addrA =  5'b01100;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      set_tc : 
        begin
          writeA =  0;
          addrA =  5'b01101;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      set_d4 : 
        begin
          writeA =  0;
          addrA =  5'b00111;
          cs_canA =  1;
          end_writeA =  1;
          set_bus_idA =  1;
        end
      set_d2 : 
        begin
          writeA =  0;
          addrA =  5'b01001;
          cs_canA =  1;
          set_bus_idA =  1;
        end
      Set_bus_Id2 : 
        begin
          set_bus_idA =  1;
        end
    endcase
  end

always @( current_stateB )
  begin : output_block_procB
    addrB =  5'b11111;
    cs_canB =  0;
    en_rec_regB =  0;
    end_initB =  0;
    end_osc_trimB =  0;
    end_readB =  0;
    end_writeB =  0;
    initiB =  0;
    readB =  1;
    reset_all_doneB =  0;
    reset_irq_can_doneB =  0;
    reset_sig_canB =  0;
    reset_sig_can_allB =  0;
    rst_cntB =  0;
    set_bus_idB =  0;
    start_cntB =  0;
    start_initB =  0;
    trimB =  0;
    writeB =  1;
    case (current_stateB)
      prescalar : 
        begin
          initiB =  1;
          addrB =  5'b01111;
          writeB =  0;
          cs_canB =  1;
        end
      general : 
        begin
          initiB =  1;
          addrB =  5'b01110;
          writeB =  0;
          cs_canB =  1;
        end
      encom : 
        begin
          initiB =  1;
          addrB =  5'b10010;
          writeB =  0;
          cs_canB =  1;
        end
      accmask : 
        begin
          initiB =  1;
          addrB =  5'b10001;
          writeB =  0;
          cs_canB =  1;
        end
      accmask1 : 
        begin
          initiB =  1;
          addrB =  5'b10000;
          writeB =  0;
          cs_canB =  1;
        end
      idr3 : 
        begin
          addrB =  5'b00101;
          initiB =  1;
          writeB =  0;
          cs_canB =  1;
        end
      idr4 : 
        begin
          initiB =  1;
          addrB =  5'b00100;
          writeB =  0;
          cs_canB =  1;
        end
      endinit : 
        begin
          end_initB =  1;
        end
      start : 
        begin
          start_initB =  1;
        end
      RB1 : 
        begin
          readB =  0;
          addrB =  5'b00011;
          cs_canB =  1;
        end
      store_RB1 : 
        begin
          readB =  0;
          addrB =  5'b00011;
          cs_canB =  1;
          en_rec_regB =  1;
        end
      store_idr1 : 
        begin
          readB =  0;
          addrB =  5'b00101;
          cs_canB =  1;
          en_rec_regB =  1;
        end
      idr1 : 
        begin
          readB =  0;
          addrB =  5'b00101;
          cs_canB =  1;
        end
      RB2 : 
        begin
          readB =  0;
          addrB =  5'b00010;
          cs_canB =  1;
        end
      store_RB2 : 
        begin
          readB =  0;
          addrB =  5'b00010;
          cs_canB =  1;
          en_rec_regB =  1;
        end
      RB3 : 
        begin
          readB =  0;
          addrB =  5'b00001;
          cs_canB =  1;
        end
      RB4 : 
        begin
          readB =  0;
          addrB =  5'b00000;
          cs_canB =  1;
        end
      store_RB3 : 
        begin
          readB =  0;
          addrB =  5'b00001;
          cs_canB =  1;
          en_rec_regB =  1;
        end
      end_readst : 
        begin
          end_readB =  1;
          addrB =  5'b11111;
        end
      store_RB4 : 
        begin
          readB =  0;
          addrB =  5'b00000;
          cs_canB =  1;
          en_rec_regB =  1;
        end
      set_d3 : 
        begin
          writeB =  0;
          addrB =  5'b01000;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      set_d1 : 
        begin
          writeB =  0;
          addrB =  5'b01010;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      set_gen : 
        begin
          writeB =  0;
          addrB =  5'b01110;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      rstirq : 
        begin
          writeB =  0;
          reset_sig_canB =  1;
          cs_canB =  1;
          addrB =  5'b10010;
          reset_irq_can_doneB =  1;
        end
      general2 : 
        begin
          writeB =  0;
          reset_sig_canB =  1;
          cs_canB =  1;
          addrB =  5'b01110;
        end
      ST_CountRst : 
        begin
          rst_cntB =  1;
        end
      rstirq1 : 
        begin
          writeB =  0;
          cs_canB =  1;
          addrB =  5'b10010;
          reset_sig_canB =  1;
          reset_sig_can_allB =  1;
        end
      general3 : 
        begin
          writeB =  0;
          cs_canB =  1;
          addrB =  5'b01110;
          reset_sig_canB =  1;
          reset_sig_can_allB =  1;
        end
      start1 : 
        begin
          start_cntB =  1;
        end
      ST_CountRst1 : 
        begin
          rst_cntB =  1;
          reset_all_doneB =  1;
        end
      ST_Start_Cnt : 
        begin
          start_cntB =  1;
        end
      finishtrim : 
        begin
          end_osc_trimB =  1;
        end
      general4 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01110;
          cs_canB =  1;
        end
      id2 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01100;
          cs_canB =  1;
        end
      d5 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01010;
          cs_canB =  1;
        end
      d6 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01001;
          cs_canB =  1;
        end
      d7 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01000;
          cs_canB =  1;
        end
      d8 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b00111;
          end_writeB =  1;
          cs_canB =  1;
        end
      tc1 : 
        begin
          writeB =  0;
          trimB =  1;
          addrB =  5'b01101;
          cs_canB =  1;
        end
      set_id1 : 
        begin
          writeB =  0;
          addrB =  5'b01100;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      set_tc : 
        begin
          writeB =  0;
          addrB =  5'b01101;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      set_d4 : 
        begin
          writeB =  0;
          addrB =  5'b00111;
          cs_canB =  1;
          end_writeB =  1;
          set_bus_idB =  1;
        end
      set_d2 : 
        begin
          writeB =  0;
          addrB =  5'b01001;
          cs_canB =  1;
          set_bus_idB =  1;
        end
      Set_bus_Id2 : 
        begin
          set_bus_idB =  1;
        end
    endcase
  end

always @( current_stateC )
  begin : output_block_procC
    addrC =  5'b11111;
    cs_canC =  0;
    en_rec_regC =  0;
    end_initC =  0;
    end_osc_trimC =  0;
    end_readC =  0;
    end_writeC =  0;
    initiC =  0;
    readC =  1;
    reset_all_doneC =  0;
    reset_irq_can_doneC =  0;
    reset_sig_canC =  0;
    reset_sig_can_allC =  0;
    rst_cntC =  0;
    set_bus_idC =  0;
    start_cntC =  0;
    start_initC =  0;
    trimC =  0;
    writeC =  1;
    case (current_stateC)
      prescalar : 
        begin
          initiC =  1;
          addrC =  5'b01111;
          writeC =  0;
          cs_canC =  1;
        end
      general : 
        begin
          initiC =  1;
          addrC =  5'b01110;
          writeC =  0;
          cs_canC =  1;
        end
      encom : 
        begin
          initiC =  1;
          addrC =  5'b10010;
          writeC =  0;
          cs_canC =  1;
        end
      accmask : 
        begin
          initiC =  1;
          addrC =  5'b10001;
          writeC =  0;
          cs_canC =  1;
        end
      accmask1 : 
        begin
          initiC =  1;
          addrC =  5'b10000;
          writeC =  0;
          cs_canC =  1;
        end
      idr3 : 
        begin
          addrC =  5'b00101;
          initiC =  1;
          writeC =  0;
          cs_canC =  1;
        end
      idr4 : 
        begin
          initiC =  1;
          addrC =  5'b00100;
          writeC =  0;
          cs_canC =  1;
        end
      endinit : 
        begin
          end_initC =  1;
        end
      start : 
        begin
          start_initC =  1;
        end
      RB1 : 
        begin
          readC =  0;
          addrC =  5'b00011;
          cs_canC =  1;
        end
      store_RB1 : 
        begin
          readC =  0;
          addrC =  5'b00011;
          cs_canC =  1;
          en_rec_regC =  1;
        end
      store_idr1 : 
        begin
          readC =  0;
          addrC =  5'b00101;
          cs_canC =  1;
          en_rec_regC =  1;
        end
      idr1 : 
        begin
          readC =  0;
          addrC =  5'b00101;
          cs_canC =  1;
        end
      RB2 : 
        begin
          readC =  0;
          addrC =  5'b00010;
          cs_canC =  1;
        end
      store_RB2 : 
        begin
          readC =  0;
          addrC =  5'b00010;
          cs_canC =  1;
          en_rec_regC =  1;
        end
      RB3 : 
        begin
          readC =  0;
          addrC =  5'b00001;
          cs_canC =  1;
        end
      RB4 : 
        begin
          readC =  0;
          addrC =  5'b00000;
          cs_canC =  1;
        end
      store_RB3 : 
        begin
          readC =  0;
          addrC =  5'b00001;
          cs_canC =  1;
          en_rec_regC =  1;
        end
      end_readst : 
        begin
          end_readC =  1;
          addrC =  5'b11111;
        end
      store_RB4 : 
        begin
          readC =  0;
          addrC =  5'b00000;
          cs_canC =  1;
          en_rec_regC =  1;
        end
      set_d3 : 
        begin
          writeC =  0;
          addrC =  5'b01000;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      set_d1 : 
        begin
          writeC =  0;
          addrC =  5'b01010;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      set_gen : 
        begin
          writeC =  0;
          addrC =  5'b01110;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      rstirq : 
        begin
          writeC =  0;
          reset_sig_canC =  1;
          cs_canC =  1;
          addrC =  5'b10010;
          reset_irq_can_doneC =  1;
        end
      general2 : 
        begin
          writeC =  0;
          reset_sig_canC =  1;
          cs_canC =  1;
          addrC =  5'b01110;
        end
      ST_CountRst : 
        begin
          rst_cntC =  1;
        end
      rstirq1 : 
        begin
          writeC =  0;
          cs_canC =  1;
          addrC =  5'b10010;
          reset_sig_canC =  1;
          reset_sig_can_allC =  1;
        end
      general3 : 
        begin
          writeC =  0;
          cs_canC =  1;
          addrC =  5'b01110;
          reset_sig_canC =  1;
          reset_sig_can_allC =  1;
        end
      start1 : 
        begin
          start_cntC =  1;
        end
      ST_CountRst1 : 
        begin
          rst_cntC =  1;
          reset_all_doneC =  1;
        end
      ST_Start_Cnt : 
        begin
          start_cntC =  1;
        end
      finishtrim : 
        begin
          end_osc_trimC =  1;
        end
      general4 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01110;
          cs_canC =  1;
        end
      id2 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01100;
          cs_canC =  1;
        end
      d5 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01010;
          cs_canC =  1;
        end
      d6 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01001;
          cs_canC =  1;
        end
      d7 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01000;
          cs_canC =  1;
        end
      d8 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b00111;
          end_writeC =  1;
          cs_canC =  1;
        end
      tc1 : 
        begin
          writeC =  0;
          trimC =  1;
          addrC =  5'b01101;
          cs_canC =  1;
        end
      set_id1 : 
        begin
          writeC =  0;
          addrC =  5'b01100;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      set_tc : 
        begin
          writeC =  0;
          addrC =  5'b01101;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      set_d4 : 
        begin
          writeC =  0;
          addrC =  5'b00111;
          cs_canC =  1;
          end_writeC =  1;
          set_bus_idC =  1;
        end
      set_d2 : 
        begin
          writeC =  0;
          addrC =  5'b01001;
          cs_canC =  1;
          set_bus_idC =  1;
        end
      Set_bus_Id2 : 
        begin
          set_bus_idC =  1;
        end
    endcase
  end

always @( posedge clkA )
  begin : clocked_block_procA
    if (!rstA)
      begin
        current_stateA <= reset;
        csm_timerA <= 8'd0;
      end
    else
      if (timeoutrstA)
        begin
          current_stateA <= reset;
          csm_timerA <= 8'd0;
        end
      else
        if (abortA)
          begin
            current_stateA <= reset;
            csm_timerA <= 8'd0;
          end
        else
          begin
            current_stateA <= next_stateA;
            csm_timerA <= csm_next_timerA;
          end
  end

always @( posedge clkB )
  begin : clocked_block_procB
    if (!rstB)
      begin
        current_stateB <= reset;
        csm_timerB <= 8'd0;
      end
    else
      if (timeoutrstB)
        begin
          current_stateB <= reset;
          csm_timerB <= 8'd0;
        end
      else
        if (abortB)
          begin
            current_stateB <= reset;
            csm_timerB <= 8'd0;
          end
        else
          begin
            current_stateB <= next_stateB;
            csm_timerB <= csm_next_timerB;
          end
  end

always @( posedge clkC )
  begin : clocked_block_procC
    if (!rstC)
      begin
        current_stateC <= reset;
        csm_timerC <= 8'd0;
      end
    else
      if (timeoutrstC)
        begin
          current_stateC <= reset;
          csm_timerC <= 8'd0;
        end
      else
        if (abortC)
          begin
            current_stateC <= reset;
            csm_timerC <= 8'd0;
          end
        else
          begin
            current_stateC <= next_stateC;
            csm_timerC <= csm_next_timerC;
          end
  end

always @( csm_timerA or csm_to_waitCANA or csm_to_end_readstA or csm_to_ST_Start_TrimA or csm_to_Wait_bitsA )
  begin : csm_wait_block_procA
    csm_timeoutA =  (csm_timerA==8'd0);
    if (csm_to_waitCANA==1'b1)
      begin
        csm_next_timerA =  8'd149;
      end
    else
      if (csm_to_end_readstA==1'b1)
        begin
          csm_next_timerA =  8'd3;
        end
      else
        if (csm_to_ST_Start_TrimA==1'b1)
          begin
            csm_next_timerA =  8'd59;
          end
        else
          if (csm_to_Wait_bitsA==1'b1)
            begin
              csm_next_timerA =  8'd239;
            end
          else
            begin
              csm_next_timerA =  (csm_timeoutA) ? 8'd0 : (csm_timerA-8'd1);
            end
  end

always @( csm_timerB or csm_to_waitCANB or csm_to_end_readstB or csm_to_ST_Start_TrimB or csm_to_Wait_bitsB )
  begin : csm_wait_block_procB
    csm_timeoutB =  (csm_timerB==8'd0);
    if (csm_to_waitCANB==1'b1)
      begin
        csm_next_timerB =  8'd149;
      end
    else
      if (csm_to_end_readstB==1'b1)
        begin
          csm_next_timerB =  8'd3;
        end
      else
        if (csm_to_ST_Start_TrimB==1'b1)
          begin
            csm_next_timerB =  8'd59;
          end
        else
          if (csm_to_Wait_bitsB==1'b1)
            begin
              csm_next_timerB =  8'd239;
            end
          else
            begin
              csm_next_timerB =  (csm_timeoutB) ? 8'd0 : (csm_timerB-8'd1);
            end
  end

always @( csm_timerC or csm_to_waitCANC or csm_to_end_readstC or csm_to_ST_Start_TrimC or csm_to_Wait_bitsC )
  begin : csm_wait_block_procC
    csm_timeoutC =  (csm_timerC==8'd0);
    if (csm_to_waitCANC==1'b1)
      begin
        csm_next_timerC =  8'd149;
      end
    else
      if (csm_to_end_readstC==1'b1)
        begin
          csm_next_timerC =  8'd3;
        end
      else
        if (csm_to_ST_Start_TrimC==1'b1)
          begin
            csm_next_timerC =  8'd59;
          end
        else
          if (csm_to_Wait_bitsC==1'b1)
            begin
              csm_next_timerC =  8'd239;
            end
          else
            begin
              csm_next_timerC =  (csm_timeoutC) ? 8'd0 : (csm_timerC-8'd1);
            end
  end

always @( current_stateA )
  statedebA =  current_stateA;

always @( current_stateB )
  statedebB =  current_stateB;

always @( current_stateC )
  statedebC =  current_stateC;
endmodule

