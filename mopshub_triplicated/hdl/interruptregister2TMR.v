/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./output/interruptregister2TMR.v                                                       *
 *                                                                                                  *
 * user    : lucas                                                                                  *
 * host    : DESKTOP-BFDSFP2                                                                        *
 * date    : 05/12/2022 13:28:23                                                                    *
 *                                                                                                  *
 * workdir : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/triplicated/mopshub_top_board_16/hdl *
 * cmd     : /mnt/c/Users/Lucas/Documents/GitHub/mopshub_triplicated/tmrg-master/bin/tmrg -vv -c    *
 *           tmrg.cfg                                                                               *
 * tmrg rev: b25f042058e4e97751df2a0933c24aeadd5a78a5                                               *
 *                                                                                                  *
 * src file: interruptregister2.v                                                                   *
 *           Git SHA           : b25f042058e4e97751df2a0933c24aeadd5a78a5 (?? interruptregister2.v) *
 *           Modification time : 2022-11-10 21:22:58                                                *
 *           File Size         : 2868                                                               *
 *           MD5 hash          : bd7e7e5669175843ce4eb731fe69d8ac                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module interrupregister2TMR(
  input wire  clk ,
  input wire  rst ,
  input wire  cpu ,
  input wire  can ,
  input wire  onoffnin ,
  input wire  iestatusp ,
  input wire  iesuctrap ,
  input wire  iesucrecp ,
  input wire  irqstatusp ,
  input wire  irqsuctrap ,
  input wire  irqsucrecp ,
  input wire  irqstatusc ,
  input wire  irqsuctrac ,
  input wire  irqsucrecc ,
  output wire [15:0] register 
);
wire rstC;
wire rstB;
wire rstA;
wire [15:0] registerC;
wire [15:0] registerB;
wire [15:0] registerA;
wire onoffninC;
wire onoffninB;
wire onoffninA;
wire irqsuctrapC;
wire irqsuctrapB;
wire irqsuctrapA;
wire irqsuctracC;
wire irqsuctracB;
wire irqsuctracA;
wire irqsucrecpC;
wire irqsucrecpB;
wire irqsucrecpA;
wire irqsucreccC;
wire irqsucreccB;
wire irqsucreccA;
wire irqstatuspC;
wire irqstatuspB;
wire irqstatuspA;
wire irqstatuscC;
wire irqstatuscB;
wire irqstatuscA;
wire iesuctrapC;
wire iesuctrapB;
wire iesuctrapA;
wire iesucrecpC;
wire iesucrecpB;
wire iesucrecpA;
wire iestatuspC;
wire iestatuspB;
wire iestatuspA;
wire cpuC;
wire cpuB;
wire cpuA;
wire clkC;
wire clkB;
wire clkA;
wire canC;
wire canB;
wire canA;
wor register_iTmrError;
wire [15:0] register_i;
reg  [15:0] register_iA ;
reg  [15:0] register_iB ;
reg  [15:0] register_iC ;
assign register =  register_i;

always @( posedge clkA )
  begin
    if (rstA==1'b0)
      begin
        register_iA <= 16'd0;
      end
    else
      if (canA==1'b1)
        begin
          if (irqstatuscA==1'b1)
            register_iA[2]  <= irqstatuscA;
          if (irqsuctracA==1'b1)
            register_iA[1]  <= irqsuctracA;
          if (irqsucreccA==1'b1)
            register_iA[0]  <= irqsucreccA;
        end
      else
        if (cpuA==1'b1)
          begin
            register_iA[15]  <= onoffninA;
            register_iA[6]  <= iestatuspA;
            register_iA[5]  <= iesuctrapA;
            register_iA[4]  <= iesucrecpA;
            if (irqstatuspA==1'b0)
              register_iA[2]  <= irqstatuspA;
            if (irqsuctrapA==1'b0)
              register_iA[1]  <= irqsuctrapA;
            if (irqsucrecpA==1'b0)
              register_iA[0]  <= irqsucrecpA;
          end
        else
          register_iA <= registerA;
  end

always @( posedge clkB )
  begin
    if (rstB==1'b0)
      begin
        register_iB <= 16'd0;
      end
    else
      if (canB==1'b1)
        begin
          if (irqstatuscB==1'b1)
            register_iB[2]  <= irqstatuscB;
          if (irqsuctracB==1'b1)
            register_iB[1]  <= irqsuctracB;
          if (irqsucreccB==1'b1)
            register_iB[0]  <= irqsucreccB;
        end
      else
        if (cpuB==1'b1)
          begin
            register_iB[15]  <= onoffninB;
            register_iB[6]  <= iestatuspB;
            register_iB[5]  <= iesuctrapB;
            register_iB[4]  <= iesucrecpB;
            if (irqstatuspB==1'b0)
              register_iB[2]  <= irqstatuspB;
            if (irqsuctrapB==1'b0)
              register_iB[1]  <= irqsuctrapB;
            if (irqsucrecpB==1'b0)
              register_iB[0]  <= irqsucrecpB;
          end
        else
          register_iB <= registerB;
  end

always @( posedge clkC )
  begin
    if (rstC==1'b0)
      begin
        register_iC <= 16'd0;
      end
    else
      if (canC==1'b1)
        begin
          if (irqstatuscC==1'b1)
            register_iC[2]  <= irqstatuscC;
          if (irqsuctracC==1'b1)
            register_iC[1]  <= irqsuctracC;
          if (irqsucreccC==1'b1)
            register_iC[0]  <= irqsucreccC;
        end
      else
        if (cpuC==1'b1)
          begin
            register_iC[15]  <= onoffninC;
            register_iC[6]  <= iestatuspC;
            register_iC[5]  <= iesuctrapC;
            register_iC[4]  <= iesucrecpC;
            if (irqstatuspC==1'b0)
              register_iC[2]  <= irqstatuspC;
            if (irqsuctrapC==1'b0)
              register_iC[1]  <= irqsuctrapC;
            if (irqsucrecpC==1'b0)
              register_iC[0]  <= irqsucrecpC;
          end
        else
          register_iC <= registerC;
  end

majorityVoter #(.WIDTH(16)) register_iVoter (
    .inA(register_iA),
    .inB(register_iB),
    .inC(register_iC),
    .out(register_i),
    .tmrErr(register_iTmrError)
    );

fanout canFanout (
    .in(can),
    .outA(canA),
    .outB(canB),
    .outC(canC)
    );

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout cpuFanout (
    .in(cpu),
    .outA(cpuA),
    .outB(cpuB),
    .outC(cpuC)
    );

fanout iestatuspFanout (
    .in(iestatusp),
    .outA(iestatuspA),
    .outB(iestatuspB),
    .outC(iestatuspC)
    );

fanout iesucrecpFanout (
    .in(iesucrecp),
    .outA(iesucrecpA),
    .outB(iesucrecpB),
    .outC(iesucrecpC)
    );

fanout iesuctrapFanout (
    .in(iesuctrap),
    .outA(iesuctrapA),
    .outB(iesuctrapB),
    .outC(iesuctrapC)
    );

fanout irqstatuscFanout (
    .in(irqstatusc),
    .outA(irqstatuscA),
    .outB(irqstatuscB),
    .outC(irqstatuscC)
    );

fanout irqstatuspFanout (
    .in(irqstatusp),
    .outA(irqstatuspA),
    .outB(irqstatuspB),
    .outC(irqstatuspC)
    );

fanout irqsucreccFanout (
    .in(irqsucrecc),
    .outA(irqsucreccA),
    .outB(irqsucreccB),
    .outC(irqsucreccC)
    );

fanout irqsucrecpFanout (
    .in(irqsucrecp),
    .outA(irqsucrecpA),
    .outB(irqsucrecpB),
    .outC(irqsucrecpC)
    );

fanout irqsuctracFanout (
    .in(irqsuctrac),
    .outA(irqsuctracA),
    .outB(irqsuctracB),
    .outC(irqsuctracC)
    );

fanout irqsuctrapFanout (
    .in(irqsuctrap),
    .outA(irqsuctrapA),
    .outB(irqsuctrapB),
    .outC(irqsuctrapC)
    );

fanout onoffninFanout (
    .in(onoffnin),
    .outA(onoffninA),
    .outB(onoffninB),
    .outC(onoffninC)
    );

fanout #(.WIDTH(16)) registerFanout (
    .in(register),
    .outA(registerA),
    .outB(registerB),
    .outC(registerC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );
endmodule

